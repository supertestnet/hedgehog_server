<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <title>Hedgehog</title>
        <!-- <script src="https://bundle.run/buffer@6.0.3"></script> -->
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/buffer.js"></script>
        <script>var Buffer = buffer.Buffer;</script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/chain_client.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/qrcode.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/bolt11.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/ripemd160.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/super_nostr.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/tapscript@1.5.3"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/noble-secp256k1@1.2.14"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/base58check.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/bech32.js"></script>
        <!-- <script src="https://supertestnet.github.io/brick-wallet/chain_client.js"></script> -->
        <!-- <script src="https://supertestnet.github.io/bitcoin-chess/js/qrcode.js"></script> -->
        <!-- <script src="https://supertestnet.github.io/bolt11_browser/bolt11.js"></script> -->
        <!-- <script src="https://unpkg.com/@dashincubator/ripemd160/ripemd160.js"></script> -->
        <!-- <script src="https://supertestnet.github.io/bankify/super_nostr.js"></script> -->
        <!-- <script src="https://unpkg.com/@cmdcode/tapscript@1.5.3"></script> -->
        <!-- <script src="https://bundle.run/noble-secp256k1@1.2.14"></script> -->
        <!-- <script src="https://bundle.run/base58check@2.0.0"></script> -->
        <!-- <script src="https://bundle.run/bech32@2.0.0"></script> -->
        <script>
            var hedgehog = {
                state: {},
                keypairs: {},
                network: "testnet",
                backup_pubkey: "a".repeat( 64 ),
                anchor_value: 0,
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                getPrivkey: () => hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ),
                getPubkey: privkey => nobleSecp256k1.getPublicKey( privkey, true ).substring( 2 ),
                getAddressData: ( scripts, index ) => {
                    var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( hedgehog.backup_pubkey, { tree, target: tree[ index ] });
                    var address = tapscript.Address.p2tr.fromPubKey( tpubkey, hedgehog.network );
                    return [ address, tree, cblock ];
                },
                getChannelScripts: chan_id => {
                    var state = hedgehog.state[ chan_id ];
                    return [ [ state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ] ];
                },
                sha256: async s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var arr = await crypto.subtle.digest( 'SHA-256', s );
                    return hedgehog.bytesToHex( new Uint8Array( arr ) );
                },
                isValidAddress: address => {
                    try {
                        return !!tapscript.Address.decode( address ).script;
                    } catch( e ) {return;}
                    return;
                },
                getVin: ( txid, vout, amnt, addy, sequence = 0xffffffff - 2 ) => ({
                    txid,
                    vout,
                    sequence,
                    prevout: {
                        value: amnt,
                        scriptPubKey: hedgehog.isValidAddress( addy ) ? tapscript.Address.toScriptPubKey( addy ) : addy,
                    },
                }),
                getVout: ( amnt, addy ) => ({
                    value: amnt,
                    scriptPubKey: hedgehog.isValidAddress( addy ) ? tapscript.Address.toScriptPubKey( addy ) : addy,
                }),
                getMidstateScripts: ( chan_id, am_sender, revocation_hash, uses_htlc, sender_is_funding_htlc, creating_counterparties_version ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //the midstate can be revoked by the recipient, so we need to find out
                    //which user can do that and which revocation hash is required -- namely,
                    //the one for which the recipient alone knows the preimage (until they
                    //revoke it)
                    if ( am_sender && am_alice ) {
                        var senders_pub = state.alices_pub;
                        var revhash = state.bobs_revocation_hashes[ state.bobs_revocation_hashes.length - 1 ];
                    }
                    if ( am_sender && !am_alice ) {
                        var senders_pub = state.bobs_pub;
                        var revhash = state.alices_revocation_hashes[ state.alices_revocation_hashes.length - 1 ];
                    }
                    if ( !am_sender && am_alice ) {
                        var senders_pub = state.bobs_pub;
                        var revhash = state.alices_revocation_hashes[ state.alices_revocation_hashes.length - 1 ];
                    }
                    if ( !am_sender && !am_alice ) {
                        var senders_pub = state.alices_pub;
                        var revhash = state.bobs_revocation_hashes[ state.bobs_revocation_hashes.length - 1 ];
                    }

                    //in some cases, the revocation hash is not *the latest* one, but is supplied by
                    //the person spending the money, because they are spending a midstate that does
                    //not represent the latest state -- e.g. this happens in a justice transaction
                    if ( revocation_hash ) revhash = revocation_hash;

                    //prepare and return the midstate scripts
                    var midstate_scripts = [
                        //the first branch allows for both parties to finalize the state
                        //it also allows the recipient to conditionally revoke this state later
                        [ state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ],
                        //the second branch allows the sender to recover the funds if the recipient disappears after initiating a force closure -- this is called a disappearance transaction
                        //TODO: change the 6 to 2026
                        [ senders_pub, "OP_CHECKSIGVERIFY", 6, "OP_CHECKSEQUENCEVERIFY" ],
                        //the third branch allows the recipient to absolutely revoke this state
                        [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", revhash, "OP_EQUALVERIFY", senders_pub, "OP_CHECKSIG" ],
                    ];

                    //in some cases, tx1 and tx2 must be different for Alice and Bob, otherwise one
                    //can broadcast a transaction that puts the money into a state the other one has
                    //revoked. Thus we need to know who is broadcasting the tx that funds the midstate
                    //and use that to modify it so that neither party has the sigs necessary for
                    //forcing the other one's money into a state they revoked
                    if ( uses_htlc ) {
                        /*
                            When Bob sends an htlc to Alice, he creates two txs:
                            - one where he creates his own version and writes "bob_is_funding_this"
                            - one where he creates alice's version and writes "alice_is_funding_this"
                            
                            When Alice receives an htlc from Bob, she creates two txs:
                            - one where she creates her own version and writes "alice_is_funding_this"
                            - one where she creates bob's version and writes "bob_is_funding_this"

                            When Alice sends an htlc to Bob, she creates two txs:
                            - one where she creates her own version and writes "alice_is_funding_this"
                            - one where she creates bob's version and writes "bob_is_funding_this"

                            When Bob receives an htlc from Alice, he creates two txs:
                            - one where he creates his own version and writes "bob_is_funding_this"
                            - one where he creates alice's version and writes "alice_is_funding_this"
                        */
                        if ( am_alice === creating_counterparties_version ) var extra_branch = [ "OP_RETURN", "bob_is_funding_this" ];
                        else var extra_branch = [ "OP_RETURN", "alice_is_funding_this" ];
                        midstate_scripts.push( extra_branch );
                    }

                    return midstate_scripts;
                },
                getInitialHTLCScripts: ( chan_id, sender_is_funder, am_sender, pmthash, relative_timelock ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //the initial HTLC address can be swept by whichever party did *not* fund it after a long delay, so we need to find out which user can do that
                    if ( sender_is_funder && am_sender && am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( sender_is_funder && !am_sender && am_alice ) var sweepers_pub = state.alices_pub;
                    if ( sender_is_funder && am_sender && !am_alice ) var sweepers_pub = state.alices_pub;
                    if ( sender_is_funder && !am_sender && !am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( !sender_is_funder && am_sender && am_alice ) var sweepers_pub = state.alices_pub;
                    if ( !sender_is_funder && !am_sender && am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( !sender_is_funder && am_sender && !am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( !sender_is_funder && !am_sender && !am_alice ) var sweepers_pub = state.alices_pub;
                    var counterpartys_pub = state.alices_pub;
                    if ( sweepers_pub === state.alices_pub ) var counterpartys_pub = state.bobs_pub;

                    //in the initial htlc, both paths require both parties to cosign, and one path – the “reveal path,” as opposed to the “recovery path” – also requires the recipient to reveal a preimage
                    return [
                        //the first branch is the "reveal path" and it allows both parties to
                        //spend the money if they cosign and reveal a preimage
                        [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", pmthash, "OP_EQUALVERIFY", state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ],
                        //the second branch is the "recovery path" and it does not require a preimage
                        //but is otherwise the same
                        [ state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ],
                        //the third branch allows whichever party did *not* fund the address to sweep it
                        //after a long delay
                        [ sweepers_pub, "OP_CHECKSIGVERIFY", relative_timelock, "OP_CHECKSEQUENCEVERIFY" ],
                    ];
                },
                getStandardHTLCScripts: ( senders_pubkey, counterpartys_pubkey, pmthash, relative_timelock ) => {
                    return [
                        [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", pmthash, "OP_EQUALVERIFY", senders_pubkey, "OP_CHECKSIG" ],
                        [ relative_timelock, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", counterpartys_pubkey, "OP_CHECKSIG" ],
                    ];
                },
                getRevocableScripts: ( chan_id, sender_is_revoker, am_sender, revhash ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //the revocation address can be revoked by one party, so we need to find out
                    //which user can do that
                    if ( sender_is_revoker && am_sender && am_alice ) var revokers_pub = state.alices_pub;
                    if ( sender_is_revoker && !am_sender && am_alice ) var revokers_pub = state.bobs_pub;
                    if ( sender_is_revoker && am_sender && !am_alice ) var revokers_pub = state.bobs_pub;
                    if ( sender_is_revoker && !am_sender && !am_alice ) var revokers_pub = state.alices_pub;
                    if ( !sender_is_revoker && am_sender && am_alice ) var revokers_pub = state.bobs_pub;
                    if ( !sender_is_revoker && !am_sender && am_alice ) var revokers_pub = state.alices_pub;
                    if ( !sender_is_revoker && am_sender && !am_alice ) var revokers_pub = state.alices_pub;
                    if ( !sender_is_revoker && !am_sender && !am_alice ) var revokers_pub = state.bobs_pub;
                    var counterpartys_pub = state.alices_pub;
                    if ( revokers_pub === state.alices_pub ) counterpartys_pub = state.bobs_pub;

                    //in a revocable script, the soon-to-be revoker can recover the money after
                    //a delay, or their counterparty can sweep the money if they learn the
                    //revocation secret
                    return [
                        //the first branch allows the revoker to spend the money after a delay
                        //TODO: change the 6 to 2016
                        [ revokers_pub, "OP_CHECKSIGVERIFY", 6, "OP_CHECKSEQUENCEVERIFY" ],
                        //the second branch allows the counterparty to sweep the money if they
                        //learn the revocation secret
                        [ "OP_SHA256", revhash, "OP_EQUALVERIFY", counterpartys_pub, "OP_CHECKSIGVERIFY" ],
                    ];
                },
                getTx1: ( chan_id, am_sender, htlc_addy_and_amnt, midstate_scripts_override, extra_outputs ) => {
                    //tx1 is used during a force closure
                    //it takes money from the channel and puts it in the midstate
                    //prepare variables necessary for creating tx1
                    var state = hedgehog.state[ chan_id ];
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var channel = hedgehog.getAddressData( channel_scripts, 0 )[ 0 ];
                    var uses_htlc = !!htlc_addy_and_amnt;
                    var sender_is_funding_htlc = htlc_addy_and_amnt ? htlc_addy_and_amnt[ 2 ] : null;
                    var revhash = htlc_addy_and_amnt ? htlc_addy_and_amnt[ 3 ] : null;
                    var creating_counterparties_version = false;
                    if ( htlc_addy_and_amnt && htlc_addy_and_amnt.length > 4 && htlc_addy_and_amnt[ 4 ] ) {
                        creating_counterparties_version = htlc_addy_and_amnt[ 4 ];
                    }
                    var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, revhash, uses_htlc, sender_is_funding_htlc, creating_counterparties_version );
                    if ( midstate_scripts_override ) midstate_scripts = midstate_scripts_override;
                    var midstate = hedgehog.getAddressData( midstate_scripts, 0 )[ 0 ];

                    //prepare the vouts
                    var vout = [
                        hedgehog.getVout( state.funding_txinfo[ 2 ] - hedgehog.anchor_value, midstate ),
                        hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                    ];

                    //modify the vouts to include all pending htlcs
                    if ( extra_outputs.length ) {
                        var amnt_to_subtract_from_main_amnt = 0;
                        extra_outputs.forEach( htlc => {
                            var { htlc_address, amnt } = htlc;
                            vout.push( hedgehog.getVout( amnt, htlc_address ) );
                            amnt_to_subtract_from_main_amnt = amnt_to_subtract_from_main_amnt + amnt;
                        });
                        if ( htlc_addy_and_amnt ) amnt_to_subtract_from_main_amnt = amnt_to_subtract_from_main_amnt + htlc_addy_and_amnt[ 1 ];
                        vout[ 0 ] = hedgehog.getVout( state.funding_txinfo[ 2 ] - hedgehog.anchor_value - amnt_to_subtract_from_main_amnt, midstate );
                    }

                    //if the payment creates a new htlc, modify the vouts to include it
                    if ( htlc_addy_and_amnt ) {
                        var [ htlc_address, htlc_amnt ] = htlc_addy_and_amnt;
                        vout.push( hedgehog.getVout( htlc_amnt, htlc_address ) );
                        if ( !extra_outputs.length ) vout[ 0 ] = hedgehog.getVout( state.funding_txinfo[ 2 ] - hedgehog.anchor_value - htlc_amnt, midstate );
                    }

                    //prepare and return tx1
                    return tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( state.funding_txinfo[ 0 ], state.funding_txinfo[ 1 ], state.funding_txinfo[ 2 ], channel ),
                        ],
                        vout,
                    });
                },
                getTx2: ( chan_id, am_sender, tx1_txid, midstate, recipients_new_balance, sum_of_alices_htlcs = 0, sum_of_bobs_htlcs = 0, am_alice_for_tx2, amnt_in_output_0 ) => {
                    //tx2 is used during a force closure
                    //it takes money from the midstate and creates the latest state
                    //prepare variables necessary for creating tx2
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = am_alice_for_tx2;
                    if ( am_sender && am_alice ) var recipients_pub = state.bobs_pub;
                    if ( am_sender && !am_alice ) var recipients_pub = state.alices_pub;
                    if ( !am_sender && am_alice ) var recipients_pub = state.alices_pub;
                    if ( !am_sender && !am_alice ) var recipients_pub = state.bobs_pub;
                    if ( recipients_pub === state.alices_pub ) var senders_pub = state.bobs_pub;
                    else var senders_pub = state.alices_pub;
                    var sender_is_alice = ( am_sender && am_alice ) || ( !am_sender && !am_alice );

                    //figure out what amount each user should get in this transaction
                    if ( !state.channel_states.length ) var total_in_channel = recipients_new_balance;
                    else var total_in_channel = state.channel_states[ 0 ].amnt;
                    var alices_amnt = total_in_channel - recipients_new_balance;
                    var bobs_amnt = recipients_new_balance;
                    if ( recipients_pub === state.alices_pub ) {
                        var alices_amnt = recipients_new_balance;
                        var bobs_amnt = total_in_channel - recipients_new_balance;
                    }

                    //account for the loss of ( hedgehog.anchor_value + hedgehog.anchor_value ) sats due to anchor outputs
                    //note that hedgehog.anchor_value is the dust limit for v3 "anchor outputs"
                    if ( sender_is_alice ) alices_amnt = alices_amnt - hedgehog.anchor_value - hedgehog.anchor_value;
                    else bobs_amnt = bobs_amnt - hedgehog.anchor_value - hedgehog.anchor_value;

                    //subtract alice's htlcs from her amount and bob's htlcs from his
                    alices_amnt = alices_amnt - sum_of_alices_htlcs;
                    bobs_amnt = bobs_amnt - sum_of_bobs_htlcs;

                    //prepare and return tx2
                    var tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( tx1_txid, 0, amnt_in_output_0, midstate, 3 ),
                        ],
                        vout: [
                            hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                        ],
                    });
                    //note that 330 sats is the dust limit for taproot addresses other than anchor outputs
                    if ( alices_amnt > 330 ) tx.vout.push( hedgehog.getVout( alices_amnt, [ 1, state.alices_pub ] ) );
                    if ( bobs_amnt > 330 ) tx.vout.push( hedgehog.getVout( bobs_amnt, [ 1, state.bobs_pub ] ) );
                    return tx;
                },
                getConditionalRevocationTx: ( prev_tx1_txid, prev_tx1, tx2 ) => {
                    return tapscript.Tx.create({
                        version: 3,
                        vin: [{
                            txid: prev_tx1_txid,
                            vout: 0,
                            prevout: prev_tx1.vout[ 0 ],
                        }],
                        vout: tx2.vout,
                    });
                },
                getTxData: ( chan_id, am_alice, am_sender, amnt, sender, htlc_addy_and_amnt, use_custom_midstate_revhash, midstate_scripts_override, extra_outputs = [], do_not_delete ) => {
                    //prepare variables necessary for returning the required txdata
                    var state = hedgehog.state[ chan_id ];
                    var uses_htlc = !!htlc_addy_and_amnt;
                    var sender_is_funding_htlc;
                    var midstate_revhash = null;
                    var sender_of_htlc = null;
                    if ( htlc_addy_and_amnt ) {
                        sender_is_funding_htlc = htlc_addy_and_amnt[ 2 ];
                        if ( use_custom_midstate_revhash ) midstate_revhash = htlc_addy_and_amnt[ 3 ];
                        if ( htlc_addy_and_amnt.length > 5 && htlc_addy_and_amnt[ 5 ] ) sender_of_htlc = htlc_addy_and_amnt[ 5 ];
                    }

                    //find out if the sender of *this* tx also sent the *previous* tx
                    var sender_previously_sent = false;
                    if ( state.channel_states.length ) sender_previously_sent = state.channel_states[ state.channel_states.length - 1 ].from === sender;

                    //if the sender *did* send the previous tx you must remove whatever revocation
                    //preimage and hash they created after sending that tx, because you are replacing
                    //that state with a new one that sends the recipient more money, and that new
                    //state will use a different revocation preimage and hash
                    if ( sender_previously_sent && !do_not_delete ) {
                        if ( am_sender ) {
                            if ( am_alice ) {
                                state.alices_revocation_preimages.pop();
                                state.alices_revocation_hashes.pop();
                            } else {
                                state.bobs_revocation_preimages.pop();
                                state.bobs_revocation_hashes.pop();
                            }
                        } else {
                            if ( am_alice ) {
                                state.bobs_revocation_preimages.pop();
                                state.bobs_revocation_hashes.pop();
                            } else {
                                state.alices_revocation_preimages.pop();
                                state.alices_revocation_hashes.pop();
                            }
                        }
                    }

                    //prepare tx1 and the variables needed for broadcasting it
                    var tx1 = hedgehog.getTx1( chan_id, am_sender, htlc_addy_and_amnt, midstate_scripts_override, extra_outputs );
                    var amnt_in_output_0 = Number( tx1.vout[ 0 ].value );
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ _, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );

                    //prepare the variables needed for creating and broadcasting tx2
                    var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, midstate_revhash, uses_htlc, sender_is_funding_htlc );
                    if ( midstate_scripts_override ) midstate_scripts = midstate_scripts_override;
                    var absolute_revocation_hash = midstate_scripts[ 2 ][ 4 ];
                    var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 0 );

                    //find out how much money the sender and recipient are supposed to get via tx2
                    if ( !state.channel_states.length ) var balances = [ 0, 0 ];
                    else var balances = hedgehog.getBalances( chan_id );
                    if ( am_sender ) {
                        var recipients_old_balance = am_alice ? balances[ 1 ] : balances[ 0 ];
                    } else {
                        var recipients_old_balance = am_alice ? balances[ 0 ] : balances[ 1 ];
                    }
                    var recipients_new_balance = recipients_old_balance + amnt;
                    if ( !state.channel_states.length ) recipients_new_balance = recipients_new_balance - hedgehog.anchor_value - hedgehog.anchor_value;

                    //if the user was the last to send, modify recipients_new_balance so that it is
                    //the previous amount sent plus the new amount -- unless the last transaction
                    //sent money via an htlc, because then the previous amount sent was really 0
                    if ( sender_previously_sent ) {
                        var prev_state = state.channel_states[ state.channel_states.length - 1 ];
                        var prev_update_added_htlc = prev_state.added_htlc;
                        if ( !prev_update_added_htlc ) {
                            var amnt_recipient_had = prev_state.amnt + hedgehog.anchor_value + hedgehog.anchor_value - prev_state.amnt_sent;
                            var amnt_sent_previously = prev_state.amnt_sent;
                            if ( am_sender ) amnt = amnt_sent_previously + amnt;
                            var recipients_new_balance = amnt_recipient_had + amnt - hedgehog.anchor_value - hedgehog.anchor_value;
                        }
                    }

                    //in an htlc is used, the recipient's balance should not change
                    if ( uses_htlc ) recipients_new_balance = recipients_old_balance;

                    //prepare tx2
                    //we need to know the sum of each party's pending htlcs to deduct them from that user's tx2 balance
                    var sum_of_alices_htlcs = 0;
                    var sum_of_bobs_htlcs = 0;
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    extra_outputs.forEach( htlc => {
                        if ( htlc.sender === "alice" ) sum_of_alices_htlcs = sum_of_alices_htlcs + htlc.amnt;
                        else sum_of_bobs_htlcs = sum_of_bobs_htlcs + htlc.amnt;
                    });
                    if ( htlc_addy_and_amnt ) {
                        if ( sender_of_htlc === "alice" ) sum_of_alices_htlcs = htlc_addy_and_amnt[ 1 ];
                        else sum_of_bobs_htlcs = htlc_addy_and_amnt[ 1 ];
                    }
                    var tx2 = hedgehog.getTx2( chan_id, am_sender, tx1_txid, midstate, recipients_new_balance, sum_of_alices_htlcs, sum_of_bobs_htlcs, am_alice, amnt_in_output_0 );

                    //if the sender received money at any point, they must revoke the most recent tx by
                    //which they received money, so we prepare that tx if necessary so they can sign it
                    var conditional_revocation_needed = hedgehog.conditionalRevocationNeeded( chan_id, am_sender );
                    if ( conditional_revocation_needed ) {
                        var prev_tx1 = tapscript.Tx.decode( conditional_revocation_needed );
                        var prev_tx1_txid = tapscript.Tx.util.getTxid( prev_tx1 );
                        var conditional_revocation_tx = hedgehog.getConditionalRevocationTx( prev_tx1_txid, prev_tx1, tx2 );
                    }

                    //return all the variables and txs needed for creating the new state
                    var txs = [ recipients_new_balance, channel_tree, channel_cblock, midstate_scripts, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ];
                    if ( conditional_revocation_needed ) txs.push( conditional_revocation_tx, prev_tx1 );
                    return txs;
                },
                getBalances: chan_id => {
                    var state = hedgehog.state[ chan_id ];
                    var total_in_channel = state.channel_states[ 0 ].amnt;
                    //find the last state that didn't send an htlc -- note that
                    //when htlcs are sent, neither party's balance should change
                    //because the payment is pending until the htlc resolves, at
                    //which point, *that* is when their balances should change
                    var findPrevState = ( possible_last_state ) => {
                        var prev_state = state.channel_states[ state.channel_states.length - possible_last_state ];
                        var htlc_was_added = prev_state.added_htlc;
                        if ( !htlc_was_added ) return prev_state;
                        possible_last_state = possible_last_state + 1;
                        return findPrevState( possible_last_state );
                    }
                    var prev_state = findPrevState( 1 );
                    var last_sender = prev_state.from;
                    var last_senders_amount = total_in_channel - prev_state.amnt;
                    var htlc_was_added = prev_state.added_htlc;
                    var balances = [ last_senders_amount, prev_state.amnt + hedgehog.anchor_value + hedgehog.anchor_value ];
                    if ( last_sender !== "alice" ) balances = [ prev_state.amnt + hedgehog.anchor_value + hedgehog.anchor_value, last_senders_amount ];
                    return balances;
                },
                conditionalRevocationNeeded: ( chan_id, am_sender ) => {
                    //prepare variables necessary for finding out if a conditional revocation is necessary
                    var tx_to_be_revoked = null;
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //we start by assuming we are the sender, though we will change that assumption momentarily if needed. if we are the sender, we must revoke the last state where we received money. the creator of that state was our counterparty, who sent us money in that state. so if we are alice, we must seek the last state created by bob, i.e. where bob was the sender. if, however, we are not the sender, then we seek to ensure the sender revoked the last state where *they* received money, which is a state where *we* were the sender; so, if we are alice and we are *not* the sender of *this* transaction, we seek the last state where the sender was *alice,* i.e. ourselves, because that is the state where we last sent money, and that is the state we must ensure our counterparty revoked.
                    if ( am_alice && am_sender ) var sender = "bob";
                    if ( !am_alice && am_sender ) var sender = "alice";
                    if ( am_alice && !am_sender ) var sender = "alice";
                    if ( !am_alice && !am_sender ) var sender = "bob";

                    //return the most recent state where the recipient received money, if any
                    //I parse a strinigified version of the object to create a deep clone
                    //so that the original is unmodified by my reversing of it
                    var reversed = JSON.parse( JSON.stringify( state.channel_states ) );
                    reversed = reversed.reverse();
                    reversed.every( ( item, index ) => {
                        if ( item.from === sender ) {
                            tx_to_be_revoked = item[ "tx1" ];
                            return;
                        }
                        return true;
                    });
                    return tx_to_be_revoked;
                },
                absoluteRevocationNeeded: ( chan_id, am_sender ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    //this function is used twice: when sending and when receiving i.e. validating
                    //when sending, you revoke the state two transactions ago, because the most *recent*
                    //state is one you're *allowed to* broadcast per the hedgehog protocol, and the
                    //*current* state is also allowed. But you're not allowed to broadcast and states
                    //before then. So, every time you make a new transaction, you get the revocation preimage
                    //from two transactions ago and reveal it to your recipient so that you can no longer
                    //broadcast that old state.
                    //As the recipient, you check the validity of the revocation preimage by grabing your
                    //counterparty's revocation hash from two transactions ago and ensuring that the
                    //preimage they revealed to you hashes to that hash. Which is why this function
                    //returns the revoation hash from two transactions ago if you are the recipient.
                    if ( am_alice && am_sender ) return state.alices_revocation_preimages[ state.alices_revocation_preimages.length - 2 ];
                    if ( !am_alice && am_sender ) return state.bobs_revocation_preimages[ state.bobs_revocation_preimages.length - 2 ];
                    if ( am_alice && !am_sender ) return state.bobs_revocation_hashes[ state.bobs_revocation_hashes.length - 2 ];
                    if ( !am_alice && !am_sender ) return state.alices_revocation_hashes[ state.alices_revocation_hashes.length - 2 ];
                },
                conditionallyRevokeChannelStates: async ( chan_id, prev_tx1, sig, vout ) => {
                    var state = hedgehog.state[ chan_id ];
                    var real_txid = tapscript.Tx.util.getTxid( prev_tx1 );
                    state.channel_states.forEach( item => {
                        var expected_txid = tapscript.Tx.util.getTxid( item.tx1 );
                        if ( expected_txid !== real_txid ) return;
                        item[ "conditional_revocation_sig" ] = sig;
                        item[ "conditional_revocation_vout" ] = vout;
                    });
                },
                fullyRevokeChannelStates: async ( chan_id, preimage ) => {
                    var state = hedgehog.state[ chan_id ];
                    var real_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    state.channel_states.forEach( item => {
                        var expected_hash = item.absolute_revocation_hash;
                        if ( expected_hash !== real_hash ) return;
                        item[ "absolute_revocation_preimage" ] = preimage;
                    });
                },
                prepChannel: bobs_pubkey_and_hash => {
                    //make a channel id
                    var chan_id = "a_" + hedgehog.getPrivkey().substring( 0, 32 );

                    //initialize the channel state
                    hedgehog.state[ chan_id ] = {
                        alices_priv: null,
                        bobs_priv: null,
                        alices_pub: null,
                        bobs_pub: null,
                        alices_revocation_preimages: [],
                        alices_revocation_hashes: [],
                        bobs_revocation_preimages: [],
                        bobs_revocation_hashes: [],
                        funding_txinfo: [],
                        channel_states: [],
                        data_for_preparing_htlcs: {},
                    }
                    var state = hedgehog.state[ chan_id ];

                    //prepare alice's privkey and pubkey
                    if ( !state.alices_priv ) state.alices_priv = hedgehog.getPrivkey();
                    state.alices_pub = hedgehog.getPubkey( state.alices_priv );

                    //store bob's pubkey and hash
                    state.bobs_pub = bobs_pubkey_and_hash[ 0 ];
                    state.bobs_revocation_hashes.push( bobs_pubkey_and_hash[ 1 ] );
                    return chan_id;
                },
                openChannel: async ( bobs_pubkey_and_hash, txdata, data_from_alice, chan_id ) => {
                    //if we pass in an existing chan_id then we skip the first few steps
                    //because only alice does that and she only does it if she already
                    //did the first few steps using the prepChannel() method
                    if ( !chan_id ) {
                        //alice always opens a channel to bob and pushes all funds to his side
                        //bob always opens a channel by receiving data from alice and validating it
                        //consequently the first thing bob must do is change the chan_id to a version
                        //he can use, distinguished by having the first character be a_ if the channel
                        //data is stored by alice and b_ if the channel data is stored by bob
                        //and therefore the first thing we do is detect whether we are alice or bob
                        //by checking if the object data_from_alice exists -- if so, we must be bob
                        //so we change the chan_id so that it doesn't start with a_ but b_
                        if ( data_from_alice ) var chan_id = "b_" + data_from_alice.chan_id.substring( 2 );
                        else var chan_id = "a_" + hedgehog.getPrivkey().substring( 0, 32 );

                        //initialize the channel state
                        hedgehog.state[ chan_id ] = {
                            alices_priv: null,
                            bobs_priv: null,
                            alices_pub: null,
                            bobs_pub: null,
                            alices_revocation_preimages: [],
                            alices_revocation_hashes: [],
                            bobs_revocation_preimages: [],
                            bobs_revocation_hashes: [],
                            funding_txinfo: [],
                            channel_states: [],
                            data_for_preparing_htlcs: {},
                        }
                        var state = hedgehog.state[ chan_id ];
                    } else {
                        var state = hedgehog.state[ chan_id ];
                        if ( !bobs_pubkey_and_hash ) bobs_pubkey_and_hash = [ state.bobs_pub, state.bobs_revocation_hashes[ 0 ] ];
                        state.bobs_revocation_hashes.pop();
                    }

                    //if we are alice, the array bobs_pubkey_and_hash will exist, because alice
                    //needs that info in order to open a channel to bob
                    if ( bobs_pubkey_and_hash ) {
                        //prepare alice's privkey and pubkey
                        if ( !state.alices_priv ) state.alices_priv = hedgehog.getPrivkey();
                        state.alices_pub = hedgehog.getPubkey( state.alices_priv );

                        //store bob's pubkey and hash
                        state.bobs_pub = bobs_pubkey_and_hash[ 0 ];
                        state.bobs_revocation_hashes.push( bobs_pubkey_and_hash[ 1 ] );

                        //prepare the channel address
                        var channel_scripts = hedgehog.getChannelScripts( chan_id );
                        var channel = hedgehog.getAddressData( channel_scripts, 0 )[ 0 ];

                        //fund the channel
                        console.log( 'send money to this channel address:' );
                        console.log( channel );
                        if ( txdata ) var [ txid, vout, amnt ] = txdata;
                        else {
                            var txid = prompt( `send money into the address in your console and enter the txid` );
                            var vout = Number( prompt( `and the vout` ) );
                            var amnt = Number( prompt( `and the amount` ) );
                        }
                        state.funding_txinfo = [ txid, vout, amnt ];

                        //send bob the data he needs to validate this channel
                        var data_for_bob = await hedgehog.send( chan_id, amnt );
                        data_for_bob[ "funding_txinfo" ] = state.funding_txinfo;
                        data_for_bob[ "alices_pub" ] = state.alices_pub;
                        data_for_bob[ "bobs_pub" ] = state.bobs_pub;
                        return data_for_bob;
                    }

                    //if we are bob, the data_from_alice object will exist
                    if ( data_from_alice ) {
                        //bob's private key was generated previously and stored in an object called keypairs
                        //so we get the private key and Bob's preimage from there and store them in state,
                        //ready for future use
                        var my_pub = data_from_alice.bobs_pub;
                        state.bobs_priv = hedgehog.keypairs[ my_pub ][ "privkey" ];
                        state.bobs_pub = my_pub;
                        state.bobs_revocation_preimages.push( hedgehog.keypairs[ my_pub ][ "preimage" ] );
                        var hash = await hedgehog.sha256( hedgehog.hexToBytes( state.bobs_revocation_preimages[ 0 ] ) );
                        state.bobs_revocation_hashes.push( hash );
                        delete hedgehog.keypairs[ my_pub ];

                        //we also store alice's pubkey and the funding info
                        state.alices_pub = data_from_alice.alices_pub;
                        state.funding_txinfo = data_from_alice.funding_txinfo;

                        //validate the channel opening data
                        var initial_state_is_valid = await hedgehog.receive( data_from_alice );
                        return initial_state_is_valid;
                    }
                },
                send: async ( chan_id, amnt, overwrite_extra_outputs ) => {
                    //prepare the variables you need to send money
                    var state = hedgehog.state[ chan_id ];
                    var am_sender = true;
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var sender = am_alice ? "alice" : "bob";

                    //get the transaction data
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    if ( overwrite_extra_outputs ) extra_outputs = overwrite_extra_outputs;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, null, null, null, extra_outputs );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_scripts, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    //getTxData always returns 11 items. It also returns two additional items if a conditional revocation was needed on a prior state, so in that circumstance we also grab those two additional items so that we can sign them
                    if ( txs.length > 11 ) {
                        var conditional_revocation_tx = txs[ 11 ];
                        var prev_tx1 = txs[ 11 ];
                    }

                    //sign everything and, if necessary, prepare to revoke previous states
                    var to_midstate_sig = tapscript.Signer.taproot.sign( privkey, tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var finalizer_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, {extension: midstate_tree[ 0 ] }).hex;
                    if ( conditional_revocation_needed ) var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, conditional_revocation_tx, 0, {extension: channel_tree[ 0 ] }).hex;
                    var absolute_revocation_needed = hedgehog.absoluteRevocationNeeded( chan_id, am_sender );

                    //update your state
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: amnt,
                        tx1: tapscript.Tx.encode( tx1 ).hex,
                        tx2: JSON.stringify( tx2 ),
                        midstate_scripts,
                        absolute_revocation_hash,
                        added_htlc: false,
                        extra_outputs,
                        absolute_revocation_preimage: null,
                        conditional_revocation_sig: null,
                        conditional_revocation_vout: null,
                    }
                    state.channel_states.push( ch_state );

                    //generate the hash you want your counterparty to use when they next send you money
                    var revocation_preimage = hedgehog.getPrivkey();
                    var revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_preimage ) );
                    if ( am_alice ) {
                        state.alices_revocation_preimages.push( revocation_preimage );
                        state.alices_revocation_hashes.push( revocation_hash );
                    } else {
                        state.bobs_revocation_preimages.push( revocation_preimage );
                        state.bobs_revocation_hashes.push( revocation_hash );
                    }
                    // console.log( 'tx1:' );
                    // console.log( tx1 );
                    // console.log( tapscript.Tx.util.getTxid( tx1 ) );
                    // console.log( 'tx2:' );
                    // console.log( tx2 );
                    // console.log( tapscript.Tx.util.getTxid( tx2 ) );

                    //send your counterparty the data they need to validate the new state
                    var obj = {
                        to_midstate_sig,
                        finalizer_sig,
                        amnt,
                        chan_id,
                        revocation_hash,
                    }
                    if ( conditional_revocation_needed ) obj[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( absolute_revocation_needed ) obj[ "absolute_revocation_preimage" ] = absolute_revocation_needed;
                    return obj;
                },
                receive: async ( data_from_sender, overwrite_extra_outputs ) => {
                    //prepare the variables necessary for validating the new state
                    var chan_id = data_from_sender.chan_id;
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    var am_sender = false;
                    var sender = am_alice ? "bob" : "alice";
                    var amnt = data_from_sender.amnt;

                    //do not allow the sender to reuse a revocation hash
                    var revocation_hash = data_from_sender.revocation_hash;
                    var counterpartys_revhashes = state.alices_revocation_hashes;
                    if ( am_alice ) counterpartys_revhashes = state.bobs_revocation_hashes;
                    if ( counterpartys_revhashes.includes( revocation_hash ) ) return;

                    //get the transaction data
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    if ( overwrite_extra_outputs ) extra_outputs = overwrite_extra_outputs;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, null, null, null, extra_outputs );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_scripts, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    //getTxData always returns 11 items. It also returns two additional items if a conditional revocation was needed on a prior state, so in that circumstance we also grab those two additional items so that we can validate the signatures involving them
                    if ( txs.length > 11 ) {
                        var conditional_revocation_tx = txs[ 11 ];
                        var prev_tx1 = txs[ 12 ];
                    }

                    //validate the signatures
                    var to_midstate_sig = data_from_sender.to_midstate_sig;
                    var to_midstate_sighash = tapscript.Signer.taproot.hash( tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    if ( am_alice ) var senders_pub = state.bobs_pub;
                    else var senders_pub = state.alices_pub;
                    var to_midstate_sig_is_valid = await nobleSecp256k1.schnorr.verify( to_midstate_sig, to_midstate_sighash, senders_pub );
                    var finalizer_sig = data_from_sender.finalizer_sig;
                    var finalizer_sighash = tapscript.Signer.taproot.hash( tx2, 0, {extension: midstate_tree[ 0 ] }).hex;
                    var finalizer_sig_is_valid = await nobleSecp256k1.schnorr.verify( finalizer_sig, finalizer_sighash, senders_pub );

                    //if necessary, validate the revocation data for prior states
                    if ( conditional_revocation_needed ) {
                        var conditional_revocation_sig = data_from_sender.conditional_revocation_sig;
                        var conditional_revocation_sighash = tapscript.Signer.taproot.hash( conditional_revocation_tx, 0, {extension: channel_tree[ 0 ] }).hex;
                        var conditional_revocation_sig_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_revocation_sighash, senders_pub );
                    }
                    var absolute_revocation_needed = hedgehog.absoluteRevocationNeeded( chan_id, am_sender );
                    if ( absolute_revocation_needed ) {
                        var absolute_revocation_preimage = data_from_sender.absolute_revocation_preimage;
                        var hash = await hedgehog.sha256( hedgehog.hexToBytes( absolute_revocation_preimage ) );
                        if ( hash !== absolute_revocation_needed ) return;
                    }
                    // console.log( 'tx1:' );
                    // console.log( tx1 );
                    // console.log( tapscript.Tx.util.getTxid( tx1 ) );
                    // console.log( 'tx2:' );
                    // console.log( tx2 );
                    // console.log( tapscript.Tx.util.getTxid( tx2 ) );
                    // console.log( 'to_midstate_sig_is_valid, right?', to_midstate_sig_is_valid );
                    // console.log( 'finalizer_sig_is_valid, right?', finalizer_sig_is_valid );
                    if ( !to_midstate_sig_is_valid || !finalizer_sig_is_valid ) return;
                    if ( conditional_revocation_needed && !conditional_revocation_sig_is_valid ) return;

                    //store the revocation data given by your counterparty for future use
                    if ( am_alice ) state.bobs_revocation_hashes.push( revocation_hash );
                    else state.alices_revocation_hashes.push( revocation_hash );
                    if ( conditional_revocation_needed ) await hedgehog.conditionallyRevokeChannelStates( chan_id, prev_tx1, conditional_revocation_sig, conditional_revocation_tx.vout );
                    if ( absolute_revocation_needed ) await hedgehog.fullyRevokeChannelStates( chan_id, absolute_revocation_preimage );

                    //update your state
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: amnt,
                        to_midstate_sig,
                        finalizer_sig,
                        tx1: tapscript.Tx.encode( tx1 ).hex,
                        tx2: JSON.stringify( tx2 ),
                        midstate_scripts,
                        absolute_revocation_hash,
                        added_htlc: false,
                        extra_outputs,
                        //it seems unnecessary for the recipient to reserve a
                        //place for tracking whether or not they themselves
                        //revoked a state because they will simply never
                        //broadcast an old state, so they have no use for the
                        //proof-of-revocation
                        // absolute_revocation_preimage: null,
                        // conditional_revocation_sig: null,
                        // conditional_revocation_vout: null,
                    }
                    state.channel_states.push( ch_state );
                    return true;
                },
                prepareHtlcPartOne: async ( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, relative_timelock, absolute_timelock ) => {
                    //the minimum htlc amount is 330, because that is the
                    //dust limit for taproot addresses, but in our case
                    //it is even lower: 330 + hedgehog.anchor_value -- because we use anchor
                    //outputs and thus we always need at least 570 sats as
                    //a minimum for each htlc
                    if ( amnt < 570 ) return console.log( "error: htlc limit too low" );

                    //get requisite data from the recipient
                    if ( !recipients_revhashes ) recipients_revhashes = prompt( 'enter two revhashes created by the recipient' );
                    var data_for_doing_part_three = await hedgehog.prepareHtlcPartTwo( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, relative_timelock, absolute_timelock );
                    return data_for_doing_part_three;
                },
                prepareHtlcPartTwo: async ( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, relative_timelock, absolute_timelock = 0, index_of_pending_htlc = 2, senders_tx1_override, recipients_tx1_override ) => {
                    //prepare the variables you need to send money via an HTLC
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    // console.log( 'i am alice, right?', am_alice );
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var pmt_preimage = null;
                    if ( !pmthash ) pmt_preimage = hedgehog.getPrivkey();
                    if ( pmt_preimage ) pmthash = await hedgehog.sha256( hedgehog.hexToBytes( pmt_preimage ) );
                    //TODO: ensure the following hashes are valid
                    var r_midstate_revhash = recipients_revhashes[ 0 ];
                    var r_reveal_p2_revhash = recipients_revhashes[ 1 ];

                    //get the two versions of the initial HTLC
                    var sender_is_funder = true;
                    var senders_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, pmthash, relative_timelock );
                    var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_initial_htlc_scripts, 1 );
                    sender_is_funder = false;
                    var recipients_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, !am_sender, pmthash, relative_timelock );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_initial_htlc_scripts, 1 );
                    // console.log( 'senders_initial_htlc_addy:', senders_initial_htlc_addy );
                    // console.log( 'recipients_initial_htlc_addy:', recipients_initial_htlc_addy );

                    var sender_is_revoker = true;
                    var recovery_htlc_scripts = hedgehog.getRevocableScripts( chan_id, sender_is_revoker, am_sender, s_recovery_p2_revhash );
                    var [ recovery_htlc_addy ] = hedgehog.getAddressData( recovery_htlc_scripts, 0 );
                    // console.log( 'recovery_htlc_scripts:', recovery_htlc_scripts );
                    // console.log( 'recovery_htlc_addy:', recovery_htlc_addy );

                    //he also creates a "reveal-part-two htlc"
                    var sender_is_revoker = false;
                    var reveal_htlc_scripts = hedgehog.getRevocableScripts( chan_id, sender_is_revoker, !am_sender, r_reveal_p2_revhash );
                    var [ reveal_htlc_addy ] = hedgehog.getAddressData( reveal_htlc_scripts, 0 );
                    // console.log( 'reveal_htlc_addy:', reveal_htlc_addy );

                    //the sender is about to create a recovery-part-one tx, but first he needs to know the txid of the tx that funds the initial htlc
                    if ( am_sender ) var creating_counterparties_version = false;
                    else var creating_counterparties_version = true;
                    sender_is_funder = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ senders_initial_htlc_addy, amnt, sender_is_funder, s_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    if ( am_sender ) var am_sender_for_senders_version = false;
                    else var am_sender_for_senders_version = true;
                    var senders_version_of_tx1 = hedgehog.getTx1( chan_id, am_sender_for_senders_version, htlc_addy_and_amnt, null, extra_outputs );
                    if ( senders_tx1_override ) senders_version_of_tx1 = senders_tx1_override;
                    if ( am_sender ) var creating_counterparties_version = true;
                    else var creating_counterparties_version = false;
                    sender_is_funder = false;
                    htlc_addy_and_amnt = [ recipients_initial_htlc_addy, amnt, sender_is_funder, r_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    if ( am_sender ) var am_sender_for_recipients_version = true;
                    else var am_sender_for_recipients_version = false;
                    var recipients_version_of_tx1 = hedgehog.getTx1( chan_id, am_sender_for_recipients_version, htlc_addy_and_amnt, null, extra_outputs );
                    if ( recipients_tx1_override ) recipients_version_of_tx1 = recipients_tx1_override;
                    var sender = am_sender === am_alice ? "alice" : "bob";
                    var use_custom_midstate_revhash = true;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, htlc_addy_and_amnt, use_custom_midstate_revhash, null, extra_outputs, do_not_delete );
                    var [ _, _, _, _, _, _, _, _, _, _, recipients_tx2 ] = txs;
                    var senders_version_of_tx1_txid = tapscript.Tx.util.getTxid( senders_version_of_tx1 );
                    var recipients_version_of_tx1_txid = tapscript.Tx.util.getTxid( recipients_version_of_tx1 );
                    // console.log( 'senders_version_of_tx1_txid:', senders_version_of_tx1_txid );
                    // console.log( 'recipients_version_of_tx1_txid:', recipients_version_of_tx1_txid );
                    // console.log( 'senders_version_of_tx1:', JSON.stringify( senders_version_of_tx1 ) );
                    // console.log( 'recipients_version_of_tx1:', JSON.stringify( recipients_version_of_tx1 ) );

                    //the sender creates the recovery-part-one txs which use the recovery path to send the money from the initial htlc to the recovery-part-two htlc
                    var senders_recovery_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( senders_version_of_tx1_txid, index_of_pending_htlc, amnt, senders_version_of_tx1.vout[ index_of_pending_htlc ].scriptPubKey ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - hedgehog.anchor_value, recovery_htlc_addy ),
                            hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                        ],
                    });
                    var recipients_recovery_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( recipients_version_of_tx1_txid, index_of_pending_htlc, amnt, recipients_version_of_tx1.vout[ index_of_pending_htlc ].scriptPubKey ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - hedgehog.anchor_value, recovery_htlc_addy ),
                            hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                        ],
                    });
                    var senders_recovery_part_one_txid = tapscript.Tx.util.getTxid( senders_recovery_part_one_tx );
                    var recipients_recovery_part_one_txid = tapscript.Tx.util.getTxid( recipients_recovery_part_one_tx );
                    // console.log( 'recipients_recovery_part_one_txid:', senders_recovery_part_one_txid );
                    // console.log( 'recipients_recovery_part_one_txid:', recipients_recovery_part_one_txid );

                    //the sender creates the recovery-part-three txs which take his money back out of the recovery-part-two htlc after a relative timelock of 2 weeks expires
                    if ( am_sender ) var senders_address = am_alice ? tapscript.Address.fromScriptPubKey( [ 1, state.alices_pub ] ) : tapscript.Address.fromScriptPubKey( [ 1, state.bobs_pub ] );
                    else var senders_address = am_alice ? tapscript.Address.fromScriptPubKey( [ 1, state.bobs_pub ] ) : tapscript.Address.fromScriptPubKey( [ 1, state.alices_pub ] );
                    var senders_recovery_part_one_txid = tapscript.Tx.util.getTxid( senders_recovery_part_one_tx );
                    var recipients_recovery_part_one_txid = tapscript.Tx.util.getTxid( recipients_recovery_part_one_tx );
                    var senders_recovery_part_three_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            //TODO: change the relative timelock from 3 to 2016
                            hedgehog.getVin( senders_recovery_part_one_txid, 0, amnt - hedgehog.anchor_value, recovery_htlc_addy, 3 ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - hedgehog.anchor_value, senders_address ),
                            hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                        ],
                    });
                    var recipients_recovery_part_three_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            //TODO: change the relative timelock from 3 to 2016
                            hedgehog.getVin( recipients_recovery_part_one_txid, 0, amnt - hedgehog.anchor_value, recovery_htlc_addy, 3 ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - hedgehog.anchor_value, senders_address ),
                            hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                        ],
                    });
                    var senders_recovery_part_three_txid = tapscript.Tx.util.getTxid( senders_recovery_part_three_tx );
                    var recipients_recovery_part_three_txid = tapscript.Tx.util.getTxid( recipients_recovery_part_three_tx );
                    // console.log( 'senders_recovery_part_three_txid:', senders_recovery_part_three_txid );
                    // console.log( 'recipients_recovery_part_three_txid:', recipients_recovery_part_three_txid );

                    //the sender also creates the reveal-part-one txs which use the reveal path to send the money from the initial htlc to the reveal-part-two htlc
                    var senders_reveal_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( senders_version_of_tx1_txid, index_of_pending_htlc, amnt, senders_initial_htlc_addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - hedgehog.anchor_value, reveal_htlc_addy ),
                            hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                        ],
                        locktime: absolute_timelock,
                    });
                    var recipients_reveal_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( recipients_version_of_tx1_txid, index_of_pending_htlc, amnt, recipients_initial_htlc_addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - hedgehog.anchor_value, reveal_htlc_addy ),
                            hedgehog.getVout( hedgehog.anchor_value, "51024e73" ),
                        ],
                        locktime: absolute_timelock,
                    });
                    var senders_reveal_part_one_txid = tapscript.Tx.util.getTxid( senders_reveal_part_one_tx );
                    var recipients_reveal_part_one_txid = tapscript.Tx.util.getTxid( recipients_reveal_part_one_tx );
                    // console.log( 'senders_reveal_part_one_txid:', senders_reveal_part_one_txid );
                    // console.log( 'recipients_reveal_part_one_txid:', recipients_reveal_part_one_txid );

                    return {
                        pmt_preimage,
                        pmthash,
                        r_midstate_revhash,
                        r_reveal_p2_revhash,
                        s_recovery_p2_revhash,
                        senders_version_of_tx1,
                        recipients_version_of_tx1,
                        senders_recovery_part_one_tx,
                        recipients_recovery_part_one_tx,
                        senders_recovery_part_three_tx,
                        recipients_recovery_part_three_tx,
                        senders_reveal_part_one_tx,
                        recipients_reveal_part_one_tx,
                        recipients_tx2,
                        htlc_addy: recipients_initial_htlc_addy,
                    }
                },
                sendHtlc: async ( chan_id, amnt, relative_timelock, absolute_timelock = 0, pmthash, block_when_i_must_force_close ) => {
                    //the minimum htlc amount is 330, because that is the
                    //dust limit for taproot addresses, but in our case
                    //it is even lower: 330 + hedgehog.anchor_value -- because we use anchor
                    //outputs and thus we always need at least 570 sats as
                    //a minimum for each htlc
                    if ( amnt < 570 ) return console.log( "error: htlc limit too low" );

                    //prepare variables for sending htlc
                    var state = hedgehog.state[ chan_id ];
                    if ( !state ) return console.log( 'error, there is no channel with this chan_id:', chan_id, 'available channels:', Object.keys( hedgehog.state ) );
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var pmt_preimage = null;
                    if ( !pmthash ) pmt_preimage = hedgehog.getPrivkey();
                    if ( pmt_preimage ) pmthash = await hedgehog.sha256( hedgehog.hexToBytes( pmt_preimage ) );
                    var s_midstate_rev_preimage = hedgehog.getPrivkey();
                    var s_midstate_revhash = await hedgehog.sha256( hedgehog.hexToBytes( s_midstate_rev_preimage ) );
                    var s_recovery_p2_rev_preimage = hedgehog.getPrivkey();
                    var s_recovery_p2_revhash = await hedgehog.sha256( hedgehog.hexToBytes( s_recovery_p2_rev_preimage ) );
                    var am_sender = true;
                    var sender_is_funder = true;
                    var sender_is_revoker = true;
                    var data_for_recipient = { chan_id, pmthash, s_midstate_revhash, more_message_info: "initial_send_htlc_message" };
                    var debug = true;
                    var recipients_revhashes = await hedgehog.intercom( data_for_recipient, debug );
                    // var recipients_revhashes = await hedgehog.receiveHtlcPartOne( data_for_recipient );
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    //note that the pending htlc's index is calculated by starting with 2, to account for the fact that the first two outputs in each tx1 are always the midstate and an anchor, and then we add the length of the existing extra outputs array, to account for the fact that they will appear first
                    var index_of_pending_htlc = 2 + extra_outputs.length;
                    var data_for_doing_part_three = await hedgehog.prepareHtlcPartTwo( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, relative_timelock, absolute_timelock, index_of_pending_htlc );

                    //save the data you need for doing part three
                    state.data_for_preparing_htlcs[ pmthash ] = [ "sender_part_two", data_for_doing_part_three ];

                    var {
                        pmthash,
                        r_midstate_revhash,
                        r_reveal_p2_revhash,
                        senders_version_of_tx1,
                        recipients_version_of_tx1,
                        senders_recovery_part_one_tx,
                        recipients_recovery_part_one_tx,
                        senders_recovery_part_three_tx,
                        recipients_recovery_part_three_tx,
                        senders_reveal_part_one_tx,
                        recipients_reveal_part_one_tx,
                    } = data_for_doing_part_three;

                    //prepare a data object to send to the counterparty
                    var data_for_counterparty = {
                        chan_id,
                        amnt,
                        relative_timelock,
                        absolute_timelock,
                        pmthash,
                        s_recovery_p2_revhash,
                    }

                    //get htlc signatures for each extra output, skipping the ones where the current user is not the sender
                    var htlc_sigs = [];
                    var i; for ( i=0; i<extra_outputs.length; i++ ) {
                        var extra_output = extra_outputs[ i ];
                        var index_of_pending_htlc = 2 + i;
                        if ( ( am_alice && extra_output.sender === "alice" ) || ( !am_alice && extra_output.sender === "bob" ) ) {
                            //if you are the sender of this htlc, you sign the reveal txs
                            var { senders_reveal_part_one_tx: senders_reveal_p1_tx, recipients_reveal_part_one_tx: recipients_reveal_p1_tx } = await hedgehog.prepareHtlcPartTwo( chan_id, extra_output.amnt, extra_output.pmthash, am_sender, extra_output.recipients_revhashes, extra_output.s_recovery_p2_revhash, extra_output.s_midstate_revhash, extra_output.relative_timelock, extra_output.absolute_timelock, index_of_pending_htlc, senders_version_of_tx1, recipients_version_of_tx1 );
                            var { sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx, senders_initial_htlc_addy, senders_initial_htlc_tree, recipients_initial_htlc_addy, recipients_initial_htlc_tree } = hedgehog.getHtlcSigs( chan_id, sender_is_funder, am_sender, extra_output.pmthash, extra_output.relative_timelock, privkey, senders_reveal_p1_tx, recipients_reveal_p1_tx );
                            htlc_sigs.push({
                                sig_on_recipients_reveal_p1_tx,
                                sig_on_senders_reveal_p1_tx,
                            });
                        } else {
                            //if you are not the sender of this htlc, you sign the recovery txs
                            var { senders_recovery_part_one_tx: senders_recovery_p1_tx, recipients_recovery_part_one_tx: recipients_recovery_p1_tx } = await hedgehog.prepareHtlcPartTwo( chan_id, extra_output.amnt, extra_output.pmthash, !am_sender, extra_output.recipients_revhashes, extra_output.s_recovery_p2_revhash, extra_output.s_midstate_revhash, extra_output.relative_timelock, extra_output.absolute_timelock, index_of_pending_htlc, senders_version_of_tx1, recipients_version_of_tx1 );
                            var senders_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, extra_output.pmthash, extra_output.relative_timelock );
                            var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_initial_htlc_scripts, 1 );
                            var recipients_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, !sender_is_funder, !am_sender, extra_output.pmthash, extra_output.relative_timelock );
                            var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_initial_htlc_scripts, 1 );
                            var sig_on_senders_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, senders_recovery_p1_tx, 0, {extension: senders_initial_htlc_tree[ 1 ]} ).hex;
                            var sig_on_recipients_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, recipients_recovery_p1_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ]} ).hex;
                            htlc_sigs.push({
                                sig_on_senders_recovery_p1_tx,
                                sig_on_recipients_recovery_p1_tx,
                            });
                        }
                    }

                    //sign the latest two transactions needed by the counterparty
                    var { sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx, senders_initial_htlc_addy, senders_initial_htlc_tree, recipients_initial_htlc_addy, recipients_initial_htlc_tree } = hedgehog.getHtlcSigs( chan_id, sender_is_funder, am_sender, pmthash, relative_timelock, privkey, senders_reveal_part_one_tx, recipients_reveal_part_one_tx );

                    //add the signatures to the data object
                    data_for_counterparty[ "sig_on_recipients_reveal_p1_tx" ] = sig_on_recipients_reveal_p1_tx;
                    data_for_counterparty[ "sig_on_senders_reveal_p1_tx" ] = sig_on_senders_reveal_p1_tx;
                    data_for_counterparty[ "htlc_sigs" ] = htlc_sigs;

                    //send the data object to your counterparty
                    var reply_from_counterparty = await hedgehog.intercom( data_for_counterparty );
                    // var reply_from_counterparty = await hedgehog.receiveHtlcPartTwo( data_for_counterparty );

                    //TODO: force close if the following error is thrown
                    if ( !reply_from_counterparty ) return console.log( 'error, your counterparty rejected your htlc' );

                    //prepare variables for validating the counterparty's signatures
                    var { sig_on_senders_recovery_p1_tx, sig_on_recipients_recovery_p1_tx, sig_on_senders_deposit_tx, htlc_sigs: counterpartys_htlc_sigs, sig_on_senders_tx2 } = reply_from_counterparty;
                    var recipients_pub = am_alice ? state.bobs_pub : state.alices_pub;

                    //validate the counterparty's recovery signatures
                    var senders_recovery_part_one_sighash = tapscript.Signer.taproot.hash( senders_recovery_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 1 ] }).hex;
                    var sig_on_senders_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_recovery_p1_tx, senders_recovery_part_one_sighash, recipients_pub );
                    var recipients_recovery_part_one_sighash = tapscript.Signer.taproot.hash( recipients_recovery_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ] }).hex;
                    var sig_on_recipients_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_recovery_p1_tx, recipients_recovery_part_one_sighash, recipients_pub );

                    //validate the counterparty's sigs on existing htlcs
                    if ( extra_outputs.length ) {
                        if ( !counterpartys_htlc_sigs || typeof counterpartys_htlc_sigs !== "object" || counterpartys_htlc_sigs.length !== extra_outputs.length ) return console.log( `error, counterparty tried to cheat you by not sending all required signatures` );
                        var i; for ( i=0; i<counterpartys_htlc_sigs.length; i++ ) {
                            var extra_output = extra_outputs[ i ];
                            var index_of_pending_htlc = 2 + i;
                            var { senders_reveal_part_one_tx: senders_reveal_p1_tx, recipients_reveal_part_one_tx: recipients_reveal_p1_tx } = await hedgehog.prepareHtlcPartTwo( chan_id, extra_output.amnt, extra_output.pmthash, am_sender, extra_output.recipients_revhashes, extra_output.s_recovery_p2_revhash, extra_output.s_midstate_revhash, extra_output.relative_timelock, extra_output.absolute_timelock, index_of_pending_htlc, senders_version_of_tx1, recipients_version_of_tx1 );
                            var { senders_recovery_part_one_tx: senders_recovery_p1_tx, recipients_recovery_part_one_tx: recipients_recovery_p1_tx } = await hedgehog.prepareHtlcPartTwo( chan_id, extra_output.amnt, extra_output.pmthash, am_sender, extra_output.recipients_revhashes, extra_output.s_recovery_p2_revhash, extra_output.s_midstate_revhash, extra_output.relative_timelock, extra_output.absolute_timelock, index_of_pending_htlc, senders_version_of_tx1, recipients_version_of_tx1 );
                            var { sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx, sig_on_senders_recovery_p1_tx, sig_on_recipients_recovery_p1_tx } = counterpartys_htlc_sigs[ i ];
                            if ( ( am_alice && extra_output.sender === "alice" ) || ( !am_alice && extra_output.sender === "bob" ) ) {
                                //check the recovery tx sigs
                                var senders_recovery_p1_sighash = tapscript.Signer.taproot.hash( senders_recovery_p1_tx, 0, {extension: senders_initial_htlc_tree[ 1 ]} ).hex;
                                var recipients_recovery_p1_sighash = tapscript.Signer.taproot.hash( recipients_recovery_p1_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ]} ).hex;
                                if ( !sig_on_recipients_recovery_p1_tx || !sig_on_senders_recovery_p1_tx ) return console.log( `error, counterparty tried to cheat you by not sending all required signatures` );
                                var sig_on_recipients_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_recovery_p1_tx, recipients_recovery_p1_sighash, recipients_pub );
                                var sig_on_senders_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_recovery_p1_tx, senders_recovery_p1_sighash, recipients_pub );
                                if ( !sig_on_recipients_recovery_p1_tx_is_valid || !sig_on_senders_recovery_p1_tx_is_valid ) return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );
                            } else {
                                //check the reveal tx sigs
                                var senders_reveal_p1_sighash = tapscript.Signer.taproot.hash( senders_reveal_p1_tx, 0, {extension: senders_initial_htlc_tree[ 0 ] }).hex;
                                var recipients_reveal_p1_sighash = tapscript.Signer.taproot.hash( recipients_reveal_p1_tx, 0, {extension: recipients_initial_htlc_tree[ 0 ] }).hex;
                                if ( !sig_on_recipients_reveal_p1_tx || !sig_on_senders_reveal_p1_tx ) return console.log( `error, counterparty tried to cheat you by not sending all required signatures` );
                                var sig_on_recipients_reveal_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_reveal_p1_tx, recipients_reveal_p1_sighash, recipients_pub );
                                var sig_on_senders_reveal_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_reveal_p1_tx, senders_reveal_p1_sighash, recipients_pub );
                                if ( !sig_on_recipients_reveal_p1_tx_is_valid || !sig_on_senders_reveal_p1_tx_is_valid ) return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );
                            }
                        }
                    }

                    //validate the counterparty's sigs on tx1 and tx2
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ _, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var deposit_sighash = tapscript.Signer.taproot.hash( senders_version_of_tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var sig_on_deposit_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_deposit_tx, deposit_sighash, recipients_pub );
                    var creating_counterparties_version = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ senders_initial_htlc_addy, amnt, sender_is_funder, s_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    var sender_for_tx1 = am_alice ? "bob" : "alice";
                    var am_alice_for_tx1 = am_alice ? false : true;
                    var use_custom_midstate_revhash = true;
                    var am_sender_for_script_override = false;
                    var uses_htlc_for_script_override = true;
                    var sender_is_funder_for_script_override = true;
                    var creating_counterparties_version_for_script_override = false;
                    var midstate_scripts_override = hedgehog.getMidstateScripts( chan_id, am_sender_for_script_override, s_midstate_revhash, uses_htlc_for_script_override, sender_is_funder_for_script_override, creating_counterparties_version_for_script_override );
                    var midstate_tree_override = hedgehog.getAddressData( midstate_scripts_override, 0 )[ 1 ];
                    var use_custom_midstate_revhash = null;
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice_for_tx1, am_sender, amnt, sender_for_tx1, htlc_addy_and_amnt, use_custom_midstate_revhash, midstate_scripts_override, extra_outputs, do_not_delete );
                    var [ _, _, _, _, _, _, _, _, _, senders_tx1, senders_tx2 ] = txs;
                    if ( tapscript.Tx.util.getTxid( senders_tx1 ) !== tapscript.Tx.util.getTxid( senders_version_of_tx1 ) ) return console.log( 'error, something rough happened to tx1' );
                    var senders_pub = state.alices_pub;
                    if ( !am_alice ) var senders_pub = state.bobs_pub;
                    if ( senders_tx2.vout.length < 3 ) {
                        senders_tx2.vout[ 1 ].scriptPubKey = [ 1, senders_pub ];
                    } else {
                        senders_tx2.vout[ 1 ].scriptPubKey = [ 1, state.alices_pub ];
                        senders_tx2.vout[ 2 ].scriptPubKey = [ 1, state.bobs_pub ];
                    }
                    var senders_tx2_sighash = tapscript.Signer.taproot.hash( senders_tx2, 0, {extension: midstate_tree_override[ 0 ] }).hex;
                    var sig_on_senders_tx2_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_tx2, senders_tx2_sighash, recipients_pub );

                    //TODO: force close if the following error is thrown
                    if ( !sig_on_senders_recovery_p1_tx_is_valid || !sig_on_recipients_recovery_p1_tx_is_valid || !sig_on_deposit_is_valid || !sig_on_senders_tx2_is_valid ) return console.log( 'error, your counterparty sent you invalid signatures' );

                    //save the data provided by the counterparty
                    state.data_for_preparing_htlcs[ pmthash ] = [ "sender_part_three", {
                        ...data_for_doing_part_three,
                        sig_on_senders_recovery_p1_tx,
                        sig_on_recipients_recovery_p1_tx,
                    }];

                    //prepare the recipients version of tx2
                    var recipients_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, !sender_is_funder, !am_sender, pmthash, relative_timelock );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_initial_htlc_scripts, 1 );
                    var creating_counterparties_version = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ recipients_initial_htlc_addy, amnt, !sender_is_funder, r_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    var sender = "bob";
                    var use_custom_midstate_revhash = true;
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, htlc_addy_and_amnt, use_custom_midstate_revhash, null, extra_outputs, do_not_delete );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_scripts, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    //getTxData always returns 11 items. It also returns two additional items if a conditional revocation was needed on a prior state, so in that circumstance we also grab those two additional items so that we can sign them
                    if ( txs.length > 11 ) {
                        var conditional_revocation_tx = txs[ 11 ];
                        var prev_tx1 = txs[ 12 ];
                    }

                    //ensure tx1 is the same now as it was before
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    var prev_tx1_txid = tapscript.Tx.util.getTxid( recipients_version_of_tx1 );
                    if ( tx1_txid !== prev_tx1_txid ) return console.log( 'error, somehow tx1 changed unexpectedly' );
                    // console.log( 'tx1_txid:', tx1_txid );
                    // console.log( 'prev_tx1_txid:', prev_tx1_txid );

                    //sign everything
                    var to_midstate_sig = tapscript.Signer.taproot.sign( privkey, tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var finalizer_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, {extension: midstate_tree[ 0 ] }).hex;

                    //update your state
                    var sender = am_alice ? "alice" : "bob";
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    var extra_outputs = [];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    extra_outputs.forEach( ( _, index ) => extra_outputs[ index ].htlc_sigs = counterpartys_htlc_sigs[ index ] );
                    extra_outputs.push({
                        htlc_address: recipients_initial_htlc_addy,
                        pmt_preimage,
                        pmthash,
                        s_midstate_rev_preimage,
                        s_midstate_revhash,
                        s_recovery_p2_rev_preimage,
                        s_recovery_p2_revhash,
                        recipients_rev_preimages: null,
                        recipients_revhashes,
                        relative_timelock,
                        absolute_timelock,
                        amnt,
                        sender: am_alice ? "alice" : "bob",
                        txid_to_check: tapscript.Tx.util.getTxid( recipients_version_of_tx1 ),
                        htlc_sigs: {
                            sig_on_senders_recovery_p1_tx,
                            sig_on_recipients_recovery_p1_tx,
                        },
                    });
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: 0,
                        tx1: tapscript.Tx.encode( tx1 ).hex,
                        tx2: JSON.stringify( tx2 ),
                        midstate_scripts,
                        absolute_revocation_hash,
                        absolute_revocation_preimage: null,
                        conditional_revocation_sig: null,
                        conditional_revocation_vout: null,
                        added_htlc: true,
                        extra_outputs,
                    }
                    state.channel_states.push( ch_state );

                    //generate the hash you want your counterparty to use when they next send you money
                    var revocation_preimage = hedgehog.getPrivkey();
                    var revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_preimage ) );
                    if ( am_alice ) {
                        state.alices_revocation_preimages.push( revocation_preimage );
                        state.alices_revocation_hashes.push( revocation_hash );
                    } else {
                        state.bobs_revocation_preimages.push( revocation_preimage );
                        state.bobs_revocation_hashes.push( revocation_hash );
                    }

                    //send your counterparty the data they need to validate the new state
                    var my_revocation_preimages = state[ "alices_revocation_preimages" ];
                    if ( !am_alice ) my_revocation_preimages = state[ "bobs_revocation_preimages" ];
                    var obj = {
                        to_midstate_sig,
                        finalizer_sig,
                        chan_id,
                        revocation_hash,
                        pmthash,
                        revocation_of_previous_state: my_revocation_preimages[ my_revocation_preimages.length - 2 ],
                    }

                    //send the data to your counterparty and get their revocation preimage
                    //TODO: force close if the recipient does not reply in a timely manner
                    var data_from_recipient = await hedgehog.intercom( obj );
                    // var data_from_recipient = await hedgehog.receiveHtlcPartThree( obj );

                    //validate and store it
                    var counterpartys_revhashes = state.alices_revocation_hashes;
                    var counterpartys_rev_preimages = state.alices_revocation_preimages;
                    if ( am_alice ) {
                        counterpartys_revhashes = state.bobs_revocation_hashes;
                        counterpartys_rev_preimages = state.bobs_revocation_preimages;
                    }
                    //TODO: force close if the following errors are thrown
                    if ( counterpartys_revhashes.length > 1 && !data_from_recipient.hasOwnProperty( "revocation_of_previous_state" ) ) return console.log( 'your counterparty tried to cheat you by not sending requisite data' );
                    if ( counterpartys_revhashes.length > 1 ) {
                        var revocation_of_previous_state = data_from_recipient.revocation_of_previous_state;
                        //if your counterparty was the last person to send money, and he did so in a state update that did *not* include an htlc, then he will have a revocation hash that he should *not* revoke here; you will use it next time you send him money, and if he revokes it here, he won't be able to safely receive that money; this may also apply in other circumstances
                        var num_of_hashes_behind = 2;
                        var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                        if ( ( ( latest_state.from === "bob" && am_alice ) || ( latest_state.from === "alice" && !am_alice ) ) && !latest_state.uses_htlc ) num_of_hashes_behind = 2;
                        var expected_revhash = counterpartys_revhashes[ counterpartys_revhashes.length - num_of_hashes_behind ];
                        if ( typeof revocation_of_previous_state !== "string" ) return console.log( 'error, your counterparty tried to cheat you by sending invalid data' );
                        var actual_revhash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_of_previous_state ) );
                        if ( actual_revhash !== expected_revhash ) return console.log( `error, your counterparty tried to cheat you by refusing to revoke the previous state; the rev_preimage they sent you: ${revocation_of_previous_state} | its actual hash: ${actual_revhash} | the revhash you wanted: ${expected_revhash} | all your counterpartys revhashes: ${counterpartys_revhashes}` );

                        //add your counterparty's revocation preimage to your state unless you already
                        //have it
                        if ( !counterpartys_rev_preimages.includes( revocation_of_previous_state ) ) counterpartys_rev_preimages.push( revocation_of_previous_state );
                    }
                    return pmthash;
                },
                receiveHtlcPartOne: async data_from_sender => {
                    //prepare revocation hashes for use in the upcoming state update
                    var { chan_id, pmthash, s_midstate_revhash } = data_from_sender;
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    var midstate_rev_preimage = hedgehog.getPrivkey();
                    var midstate_revhash = await hedgehog.sha256( hedgehog.hexToBytes( midstate_rev_preimage ) );
                    var reveal_p2_rev_preimage = hedgehog.getPrivkey();
                    var reveal_p2_revhash = await hedgehog.sha256( hedgehog.hexToBytes( reveal_p2_rev_preimage ) );
                    var recipients_preimages = [ midstate_rev_preimage, reveal_p2_rev_preimage ];
                    var recipients_revhashes = [ midstate_revhash, reveal_p2_revhash ];
                    hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ] = [ "recipient_part_one", recipients_revhashes, recipients_preimages, s_midstate_revhash ];
                    return recipients_revhashes;
                },
                receiveHtlcPartTwo: async data_from_sender => {
                    //process the data from the sender
                    var { chan_id, amnt, htlc_sigs, pmthash, s_recovery_p2_revhash, relative_timelock, absolute_timelock } = data_from_sender;
                    if ( !absolute_timelock && absolute_timelock !== 0 ) return console.log( 'error, bad absolute timelock' );
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    //TODO: force close if the following errors are thrown
                    if ( !hedgehog.state.hasOwnProperty( chan_id ) ) return console.log( 'error, counterparty tried to cheat you by providing wrong chan id' );
                    if ( hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 0 ] !== "recipient_part_one" ) return console.log( 'error, counterparty tried to cheat you by providing wrong data for the current part of an htlc transfer' );

                    //prepare the variables needed for this state update
                    var state = hedgehog.state[ chan_id ];
                    var am_sender = false;
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var senders_pub = am_alice ? state.bobs_pub : state.alices_pub;
                    var sender_is_funder = true;
                    var sender_is_revoker = true;

                    //prepare the htlc
                    var recipients_revhashes = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 1 ];
                    var recipients_rev_preimages = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 2 ];
                    var s_midstate_revhash = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 3 ];
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    var index_of_pending_htlc = 2 + extra_outputs.length;
                    var data_for_doing_part_three = await hedgehog.prepareHtlcPartTwo( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, relative_timelock, absolute_timelock, index_of_pending_htlc );
                    var { recipients_version_of_tx1, recipients_reveal_part_one_tx, senders_version_of_tx1, senders_recovery_part_one_tx, senders_recovery_part_three_tx, senders_reveal_part_one_tx, recipients_recovery_part_one_tx, htlc_addy } = data_for_doing_part_three;

                    //validate the htlc sigs, if any, and create corresponding ones
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    if ( extra_outputs.length ) {
                        if ( !htlc_sigs || typeof htlc_sigs !== "object" || htlc_sigs.length !== extra_outputs.length ) return console.log( `error, counterparty tried to cheat you by not sending all required signatures` );
                        var my_htlc_sigs = [];
                        var i; for ( i=0; i<extra_outputs.length; i++ ) {
                            var extra_output = extra_outputs[ i ];
                            var index_of_pending_htlc = 2 + i;
                            var { senders_reveal_part_one_tx: senders_reveal_p1_tx, recipients_reveal_part_one_tx: recipients_reveal_p1_tx, senders_version_of_tx1, recipients_version_of_tx1 } = await hedgehog.prepareHtlcPartTwo( chan_id, extra_output.amnt, extra_output.pmthash, am_sender, extra_output.recipients_revhashes, extra_output.s_recovery_p2_revhash, extra_output.s_midstate_revhash, extra_output.relative_timelock, extra_output.absolute_timelock, index_of_pending_htlc, senders_version_of_tx1, recipients_version_of_tx1 );
                            var { senders_recovery_part_one_tx: senders_recovery_p1_tx, recipients_recovery_part_one_tx: recipients_recovery_p1_tx } = await hedgehog.prepareHtlcPartTwo( chan_id, extra_output.amnt, extra_output.pmthash, am_sender, extra_output.recipients_revhashes, extra_output.s_recovery_p2_revhash, extra_output.s_midstate_revhash, extra_output.relative_timelock, extra_output.absolute_timelock, index_of_pending_htlc, senders_version_of_tx1, recipients_version_of_tx1 );
                            var { sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx, sig_on_senders_recovery_p1_tx, sig_on_recipients_recovery_p1_tx } = htlc_sigs[ i ];
                            if ( ( am_alice && extra_output.sender === "alice" ) || ( !am_alice && extra_output.sender === "bob" ) ) {
                                //if you are the sender of this htlc, you check the recovery tx sigs
                                var { senders_initial_htlc_tree, recipients_initial_htlc_tree } = hedgehog.getHtlcSigs( chan_id, sender_is_funder, am_sender, extra_output.pmthash, extra_output.relative_timelock, privkey, senders_reveal_p1_tx, recipients_reveal_p1_tx );
                                var senders_recovery_p1_sighash = tapscript.Signer.taproot.hash( senders_recovery_p1_tx, 0, {extension: senders_initial_htlc_tree[ 1 ]} ).hex;
                                var recipients_recovery_p1_sighash = tapscript.Signer.taproot.hash( recipients_recovery_p1_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ]} ).hex;
                                if ( !sig_on_recipients_recovery_p1_tx || !sig_on_senders_recovery_p1_tx ) return console.log( `error, counterparty tried to cheat you by not sending all required signatures` );
                                var sig_on_recipients_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_recovery_p1_tx, recipients_recovery_p1_sighash, senders_pub );
                                var sig_on_senders_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_recovery_p1_tx, senders_recovery_p1_sighash, senders_pub );
                                if ( !sig_on_recipients_recovery_p1_tx_is_valid || !sig_on_senders_recovery_p1_tx_is_valid ) return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );

                                //if you are the sender of this htlc, you sign the reveal txs
                                var { sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx, senders_initial_htlc_addy, senders_initial_htlc_tree, recipients_initial_htlc_addy, recipients_initial_htlc_tree } = hedgehog.getHtlcSigs( chan_id, sender_is_funder, !am_sender, extra_output.pmthash, extra_output.relative_timelock, privkey, senders_reveal_p1_tx, recipients_reveal_p1_tx );
                                my_htlc_sigs.push({
                                    sig_on_recipients_reveal_p1_tx,
                                    sig_on_senders_reveal_p1_tx,
                                });
                            } else {
                                //if you are not the sender of this htlc, you check the reveal tx sigs
                                var { senders_initial_htlc_tree, recipients_initial_htlc_tree } = hedgehog.getHtlcSigs( chan_id, !sender_is_funder, !am_sender, extra_output.pmthash, extra_output.relative_timelock, privkey, senders_reveal_p1_tx, recipients_reveal_p1_tx );
                                var senders_reveal_p1_sighash = tapscript.Signer.taproot.hash( senders_reveal_p1_tx, 0, {extension: senders_initial_htlc_tree[ 0 ] }).hex;
                                var recipients_reveal_p1_sighash = tapscript.Signer.taproot.hash( recipients_reveal_p1_tx, 0, {extension: recipients_initial_htlc_tree[ 0 ] }).hex;
                                if ( !sig_on_recipients_reveal_p1_tx || !sig_on_senders_reveal_p1_tx ) return console.log( `error, counterparty tried to cheat you by not sending all required signatures` );
                                var sig_on_recipients_reveal_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_reveal_p1_tx, recipients_reveal_p1_sighash, senders_pub );
                                var sig_on_senders_reveal_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_reveal_p1_tx, senders_reveal_p1_sighash, senders_pub );
                                if ( !sig_on_recipients_reveal_p1_tx_is_valid || !sig_on_senders_reveal_p1_tx_is_valid ) return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );

                                //if you are not the sender of this htlc, you sign the recovery txs
                                var recipients_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, !sender_is_funder, am_sender, extra_output.pmthash, extra_output.relative_timelock );
                                var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_initial_htlc_scripts, 1 );
                                var senders_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, extra_output.pmthash, extra_output.relative_timelock );
                                var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_initial_htlc_scripts, 1 );
                                var sig_on_senders_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, senders_recovery_p1_tx, 0, {extension: senders_initial_htlc_tree[ 1 ]} ).hex;
                                var sig_on_recipients_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, recipients_recovery_p1_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ]} ).hex;
                                my_htlc_sigs.push({
                                    sig_on_senders_recovery_p1_tx,
                                    sig_on_recipients_recovery_p1_tx,
                                });
                            }
                        }
                    }

                    //ensure you can move the money from the initial htlc if you learn the preimage
                    var recipients_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, pmthash, relative_timelock );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_initial_htlc_scripts, 1 );
                    var { sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx } = data_from_sender;
                    var recipients_reveal_part_one_sighash = tapscript.Signer.taproot.hash( recipients_reveal_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 0 ] }).hex;
                    var sig_on_recipients_reveal_p1_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_reveal_p1_tx, recipients_reveal_part_one_sighash, senders_pub );

                    //ensure the same is true even if the sender is the one who puts the money into the inital htlc
                    var senders_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, pmthash, relative_timelock );
                    var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_initial_htlc_scripts, 1 );
                    var senders_reveal_part_one_sighash = tapscript.Signer.taproot.hash( senders_reveal_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 0 ] }).hex;
                    var sig_on_senders_reveal_p1_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_reveal_p1_tx, senders_reveal_part_one_sighash, senders_pub );

                    //TODO: force close if the following error is thrown
                    if ( !sig_on_recipients_reveal_p1_is_valid || !sig_on_senders_reveal_p1_is_valid ) return console.log( 'error, counterparty tried to cheat you by providing invalid signatures:', sig_on_recipients_reveal_p1_is_valid, sig_on_senders_reveal_p1_is_valid );

                    //sign the transactions that let the sender recover his money if you never learn the preimage
                    var sig_on_senders_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, senders_recovery_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 1 ]} ).hex;
                    var sig_on_recipients_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, recipients_recovery_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ]} ).hex;
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ channel, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var sig_on_senders_deposit_tx = tapscript.Signer.taproot.sign( privkey, senders_version_of_tx1, 0, {extension: channel_tree[ 0 ]} ).hex;

                    //sign the sender's version of tx2 as well
                    var creating_counterparties_version = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ senders_initial_htlc_addy, amnt, sender_is_funder, s_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    var sender = am_alice ? "alice" : "bob";
                    var am_sender_for_tx1 = true;
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender_for_tx1, amnt, sender, htlc_addy_and_amnt, null, null, extra_outputs, do_not_delete );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_scripts, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    tx2.vin[ 0 ].prevout.scriptPubKey = tx1.vout[ 0 ].scriptPubKey;
                    var senders_tx2_sighash = tapscript.Signer.taproot.hash( tx2, 0, {extension: midstate_tree[ 0 ] }).hex;
                    var sig_on_senders_tx2 = tapscript.Signer.taproot.sign( privkey, tx2, 0, {extension: midstate_tree[ 0 ]} ).hex;

                    hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ] = [ "recipient_part_two", {recipients_rev_preimages, recipients_revhashes, s_midstate_revhash, data_for_doing_part_three, part_twos_data_from_sender: data_from_sender, recipients_initial_htlc_scripts, recipients_new_balance, htlc_addy, absolute_timelock, htlc_sigs, htlc_sigs_for_new_htlc: {sig_on_senders_reveal_p1_tx, sig_on_recipients_reveal_p1_tx}} ];

                    //return the signatures so you can provide them to the sender
                    return {
                        sig_on_senders_recovery_p1_tx,
                        sig_on_recipients_recovery_p1_tx,
                        htlc_sigs: my_htlc_sigs,
                        sig_on_senders_deposit_tx,
                        sig_on_senders_tx2,
                    }
                },
                receiveHtlcPartThree: async data_from_sender => {
                    //process the data from the sender
                    var { to_midstate_sig, finalizer_sig, chan_id, revocation_hash, pmthash, revocation_of_previous_state } = data_from_sender;
                    var absolute_revocation_hash = revocation_hash;
                    var chan_id = data_from_sender.chan_id;
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    var counterpartys_revhashes = state.alices_revocation_hashes;
                    var counterpartys_rev_preimages = state.alices_revocation_preimages;
                    if ( am_alice ) {
                        counterpartys_revhashes = state.bobs_revocation_hashes;
                        counterpartys_rev_preimages = state.bobs_revocation_preimages;
                    }
                    var expected_revhash = counterpartys_revhashes[ counterpartys_revhashes.length - 1 ];
                    //TODO: force close if the following errors are thrown
                    if ( typeof revocation_of_previous_state !== "string" ) return console.log( 'error, your counterparty tried to cheat you by sending invalid data' );
                    var actual_revhash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_of_previous_state ) );
                    if ( actual_revhash !== expected_revhash ) return console.log( 'error, your counterparty tried to cheat you by refusing to revoke the previous state' );
                    if ( !hedgehog.state.hasOwnProperty( chan_id ) ) return console.log( 'error, counterparty tried to cheat you by providing wrong chan id' );
                    if ( hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 0 ] !== "recipient_part_two" ) return console.log( 'error, counterparty tried to cheat you by providing wrong data for the current part of an htlc transfer' );
                    var absolute_timelock = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 1 ][ "absolute_timelock" ];
                    var htlc_sigs = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 1 ][ "htlc_sigs" ];
                    var htlc_sigs_for_new_htlc = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 1 ][ "htlc_sigs_for_new_htlc" ];

                    //add your counterparty's revocation preimage to your state unless you already
                    //have it
                    if ( !counterpartys_rev_preimages.includes( revocation_of_previous_state ) ) counterpartys_rev_preimages.push( revocation_of_previous_state );

                    //do not allow the sender to reuse a revocation hash
                    var revocation_hash = data_from_sender.revocation_hash;
                    if ( counterpartys_revhashes.includes( revocation_hash ) ) return;

                    //prepare the variables necessary for validating the new state
                    var am_sender = false;
                    var sender = am_alice ? "bob" : "alice";
                    var senders_pub = am_alice ? state.bobs_pub : state.alices_pub;
                    var pmthash = data_from_sender.pmthash;

                    //get data from previous part of process
                    var data_from_part_two = state.data_for_preparing_htlcs[ pmthash ];
                    var htlc_addy = data_from_part_two[ 1 ].htlc_addy;
                    var amnt = data_from_part_two[ 1 ].part_twos_data_from_sender.amnt;
                    var relative_timelock = data_from_part_two[ 1 ].part_twos_data_from_sender.relative_timelock;
                    var recipients_new_balance = data_from_part_two[ 1 ].recipients_new_balance;
                    var recipients_initial_htlc_scripts = data_from_part_two[ 1 ].recipients_initial_htlc_scripts;
                    var recipients_rev_preimages = data_from_part_two[ 1 ].recipients_rev_preimages;
                    var recipients_revhashes = data_from_part_two[ 1 ].recipients_revhashes;
                    var s_midstate_revhash = data_from_part_two[ 1 ].s_midstate_revhash;
                    var data_for_doing_part_three = data_from_part_two[ 1 ].data_for_doing_part_three;
                    var { recipients_version_of_tx1, recipients_reveal_part_one_tx, senders_version_of_tx1, senders_recovery_part_one_tx, senders_recovery_part_three_tx, senders_reveal_part_one_tx, recipients_recovery_part_one_tx, r_midstate_revhash, recipients_tx2, s_recovery_p2_revhash } = data_for_doing_part_three;

                    //ensure you can broadcast tx1
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ channel, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var deposit_sighash = tapscript.Signer.taproot.hash( recipients_version_of_tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var sig_on_deposit_is_valid = await nobleSecp256k1.schnorr.verify( to_midstate_sig, deposit_sighash, senders_pub );
                    //TODO: force close if the following error is thrown
                    if ( !sig_on_deposit_is_valid ) return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );

                    //ensure you can broadcast tx2
                    var uses_htlc = true;
                    var sender_is_funding_htlc = false;
                    var recipients_midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, r_midstate_revhash, uses_htlc, sender_is_funding_htlc );
                    var recipients_midstate_tree = hedgehog.getAddressData( recipients_midstate_scripts, 0 )[ 1 ];
                    var tx2_sighash = tapscript.Signer.taproot.hash( recipients_tx2, 0, {extension: recipients_midstate_tree[ 0 ] }).hex;
                    var sig_on_tx2_is_valid = await nobleSecp256k1.schnorr.verify( finalizer_sig, tx2_sighash, senders_pub );
                    //TODO: force close if the following error is thrown
                    if ( !sig_on_deposit_is_valid ) return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );

                    //store the revocation data given by your counterparty for future use
                    if ( am_alice ) state.bobs_revocation_hashes.push( revocation_hash );
                    else state.alices_revocation_hashes.push( revocation_hash );

                    //update your state
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    var extra_outputs = [];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    extra_outputs.forEach( ( _, index ) => extra_outputs[ index ].htlc_sigs = htlc_sigs[ index ] );
                    extra_outputs.push({
                        htlc_address: htlc_addy,
                        pmt_preimage: null,
                        pmthash,
                        s_midstate_rev_preimage: null,
                        s_midstate_revhash,
                        s_recovery_p2_rev_preimage: null,
                        s_recovery_p2_revhash,
                        recipients_rev_preimages,
                        recipients_revhashes,
                        relative_timelock,
                        absolute_timelock,
                        amnt,
                        sender: am_alice ? "bob" : "alice",
                        txid_to_check: tapscript.Tx.util.getTxid( senders_version_of_tx1 ),
                        htlc_sigs: htlc_sigs_for_new_htlc,
                    });
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: 0,
                        to_midstate_sig,
                        finalizer_sig,
                        tx1: tapscript.Tx.encode( recipients_version_of_tx1 ).hex,
                        tx2: JSON.stringify( recipients_tx2 ),
                        midstate_scripts: recipients_midstate_scripts,
                        absolute_revocation_hash: s_midstate_revhash,
                        added_htlc: true,
                        extra_outputs,
                    }
                    state.channel_states.push( ch_state );

                    //revoke all old states
                    var my_revocation_preimages = state.alices_revocation_preimages;
                    var my_revocation_hashes = state.alices_revocation_hashes;
                    if ( !am_alice ) {
                        my_revocation_preimages = state.bobs_revocation_preimages;
                        my_revocation_hashes = state.bobs_revocation_hashes;
                    }
                    var data_for_sender = {}
                    if ( my_revocation_preimages.length > 1 ) data_for_sender[ "revocation_of_previous_state" ] = my_revocation_preimages[ my_revocation_preimages.length - 2 ];
                    return data_for_sender;
                },
                findPreimage: async ( chan_id, pmthash ) => {
                    return new Promise( resolve => {
                        var channel_states = hedgehog.state[ chan_id ].channel_states;
                        channel_states.every( state => {
                            if ( state.extra_outputs ) {
                                state.extra_outputs.every( htlc => {
                                    if ( htlc.pmthash === pmthash && htlc.pmt_preimage ) resolve( htlc.pmt_preimage );
                                    return true;
                                });
                            }
                            return true;
                        });
                    });
                },
                forceClose: async ( chan_id, txid, txdata, try_to_cheat ) => {
                    //prepare variables needed for force closing the channel
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var pubkey = hedgehog.getPubkey( privkey );
                    var reversed = JSON.parse( JSON.stringify( state.channel_states ) );
                    reversed = reversed.reverse();

                    //if you detected that your counterparty force closed and broadcasted
                    //tx1, check if you have a later state or the ability to broadcast a
                    //justice transaction or a disappearance transaction, and if you can
                    //do so, do it
                    if ( txid ) {
                        var senders_pub = am_alice ? state.bobs_pub : state.alices_pub;

                        //look for a revoked state state with that txid
                        var revoked_state = null;
                        var tx1 = null;
                        var revhash = null;
                        reversed.every( ( item, index ) => {
                            var txid_to_check = tapscript.Tx.util.getTxid( item.tx1 );
                            if ( txid_to_check === txid ) {
                                var this_state_is_revoked = item.absolute_revocation_preimage || item.conditional_revocation_sig;
                                if ( this_state_is_revoked ) revoked_state = item;
                                else {
                                    tx1 = item.tx1;
                                    revhash = item.absolute_revocation_hash;
                                }
                                return;
                            }
                            return true;
                        });

                        //if you could not find a revoked state with that txid, that means your counterparty
                        //is trying to broadcast the latest state, which is good. But if they disappear
                        //you should be ready to broadcast the disappearance tx, so prepare to do that
                        if ( !revoked_state ) {
                            //prepare a tx that sweeps the funds if your counterparty disappeared
                            var txfee = 500;
                            var disappearance_tx = tapscript.Tx.create({
                                version: 2,
                                vin: [{
                                    txid,
                                    vout: 0,
                                    prevout: tapscript.Tx.decode( tx1 ).vout[ 0 ],
                                    //TODO: change the 6 to 2026
                                    sequence: 6,
                                }],
                                vout: [{
                                    value: Number( tapscript.Tx.decode( tx1 ).vout[ 0 ].value ) - txfee,
                                    scriptPubKey: [ 1, pubkey ],
                                }],
                            });

                            //sign the disappearance tx
                            var am_sender = true;
                            var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, revhash );
                            var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 1 );
                            var mysig = tapscript.Signer.taproot.sign( privkey, disappearance_tx, 0, {extension: midstate_tree[ 1 ]} ).hex;
                            disappearance_tx.vin[ 0 ].witness = [ mysig, midstate_scripts[ 1 ], midstate_cblock ];

                            //broadcast the disappearance tx
                            return { disappearance_tx }
                        }

                        //if you found a revoked state and it was *fully* revoked, broadcast a justice transaction
                        var am_sender = true;
                        var revhash = revoked_state.absolute_revocation_hash;
                        var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, revhash );
                        var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 0 );
                        if ( revoked_state.absolute_revocation_preimage ) {
                            //prepare variables needed in the justice tx
                            var preimage = revoked_state.absolute_revocation_preimage;
                            var txfee = 500;

                            //prepare the justice tx
                            var justice_tx = tapscript.Tx.create({
                                version: 2,
                                vin: [{
                                    txid: tapscript.Tx.util.getTxid( revoked_state[ "tx1" ] ),
                                    vout: 0,
                                    prevout: tapscript.Tx.decode( revoked_state[ "tx1" ] ).vout[ 0 ],
                                }],
                                vout: [{
                                    value: tapscript.Tx.decode( revoked_state[ "tx1" ] ).vout[ 0 ].value - txfee,
                                    scriptPubKey: [ 1, pubkey ],
                                }],
                            });

                            //sign the justice tx
                            var midstate_cblock = hedgehog.getAddressData( midstate_scripts, 2 );
                            var mysig = tapscript.Signer.taproot.sign( privkey, justice_tx, 0, {extension: midstate_tree[ 2 ]} ).hex;
                            justice_tx.vin[ 0 ].witness = [ mysig, preimage, midstate_scripts[ 2 ], midstate_cblock ];

                            //broadcast the justice tx
                            console.log( 'broadcast this justice transaction:' );
                            console.log( tapscript.Tx.encode( justice_tx ).hex );
                            return { justice_tx }
                        }

                        //if you have a revoked transaction that was *not* absolutely revoked but only conditionally revoked, prepare a transaction updating the state to the latest state
                        var alt_tx2 = tapscript.Tx.create({
                            version: 3,
                            vin: [{
                                txid: tapscript.Tx.util.getTxid( revoked_state[ "tx1" ] ),
                                vout: 0,
                                prevout: tapscript.Tx.decode( revoked_state[ "tx1" ] ).vout[ 0 ],
                            }],
                            vout: revoked_state[ "conditional_revocation_vout" ],
                        });

                        //get all sigs required to broadcast it
                        var revsig = revoked_state[ "conditional_revocation_sig" ];
                        var mysig = tapscript.Signer.taproot.sign( privkey, alt_tx2, 0, {extension: midstate_tree[ 0 ]} ).hex;
                        alt_tx2.vin[ 0 ].witness = [ mysig, revsig, midstate_scripts[ 0 ], midstate_cblock ];
                        if ( am_alice ) alt_tx2.vin[ 0 ].witness = [ revsig, mysig, midstate_scripts[ 0 ], midstate_cblock ];

                        //get utxos to cover the fees
                        var addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], hedgehog.network );
                        if ( !txdata ) {
                            console.log( 'send 500 sats into this address:' );
                            console.log( addy );
                            var txid2 = prompt( `send 500 sats into the address in your console and enter the txid` );
                            if ( !txid2 ) return;
                            var vout2 = Number( prompt( `and the vout` ) );
                            var amnt2 = Number( prompt( `and the amount` ) );
                        } else {
                            var [ txid2, vout2, amnt2 ] = txdata;
                        }

                        //prepare a fee-paying tx
                        var tx2_txid = tapscript.Tx.util.getTxid( alt_tx2 );
                        var tx2_fee = tapscript.Tx.create({
                            version: 3,
                            vin: [
                                hedgehog.getVin( tx2_txid, 0, hedgehog.anchor_value, "51024e73" ),
                                hedgehog.getVin( txid2, vout2, amnt2, addy ),
                            ],
                            vout: [{
                                value: 0,
                                scriptPubKey: [ "OP_RETURN" ],
                            }],
                        });
                        var fee2_sig = tapscript.Signer.taproot.sign( privkey, tx2_fee, 1 ).hex;
                        tx2_fee.vin[ 1 ].witness = [ fee2_sig ];

                        //broadcast the transactions
                        //TODO: if there were extra outputs, prepare to broadcast their sweep txs as their timeouts approach
                        return { alt_tx2, tx2_fee }
                    }

                    //all the code after this point is for preparing and broadcasting the latest state
                    //m_r_s = most recent state where I received money
                    var m_r_s = null;
                    var counterparty = am_alice ? "bob" : "alice";
                    reversed.every( ( item, index ) => {
                        if ( item.from === counterparty ) {
                            m_r_s = item;
                            return;
                        }
                        return true;
                    });

                    //if try_to_cheat is enabled, then instead of broadcasting
                    //the latest state, we broadcast the one where we first received
                    //money
                    if ( try_to_cheat ) {
                        state.channel_states.every( ( item, index ) => {
                            if ( item.from === counterparty ) {
                                m_r_s = item;
                                return;
                            }
                            return true;
                        });
                    }

                    //prepare tx1
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ channel, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var total_in_channel = hedgehog.getBalances( chan_id ).reduce( ( accumulator, currentValue ) => accumulator + currentValue, 0 );
                    var tx1 = tapscript.Tx.decode( m_r_s.tx1 );
                    //in order to save space in the database, I don't store the prevout of tx1, so here I add it back in
                    tx1.vin[ 0 ].prevout = {
                        value: total_in_channel,
                        scriptPubKey: tapscript.Address.toScriptPubKey( channel ),
                    }

                    //sign tx1
                    var recipients_to_midstate_sig = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: channel_tree[ 0 ] }).hex;
                    var senders_to_midstate_sig = m_r_s.to_midstate_sig;
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ senders_to_midstate_sig, recipients_to_midstate_sig, channel_scripts[ 0 ], channel_cblock ];
                    else tx1.vin[ 0 ].witness = [ recipients_to_midstate_sig, senders_to_midstate_sig, channel_scripts[ 0 ], channel_cblock ];

                    //prepare tx2
                    var am_sender = false;
                    var tx1_txid = tapscript.Tx.util.getTxid( m_r_s.tx1 );
                    var revhash = m_r_s.absolute_revocation_hash;
                    var midstate_scripts = m_r_s.midstate_scripts;
                    var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 0 );
                    var amnt = m_r_s.amnt;
                    var sum_of_alices_htlcs = 0;
                    var sum_of_bobs_htlcs = 0;
                    var extra_outputs = m_r_s.extra_outputs;
                    extra_outputs.forEach( htlc => {
                        if ( htlc.sender === "alice" ) sum_of_alices_htlcs = sum_of_alices_htlcs + htlc.amnt;
                        else sum_of_bobs_htlcs = sum_of_bobs_htlcs + htlc.amnt;
                    });
                    var amnt_in_output_0 = Number( tx1.vout[ 0 ].value );
                    //I'm not the person who created tx2 when I received money in it, so if I *am* Alice, I pretend to be Bob while creating it here, and if I am *not* Alice, I pretend to *be* Alice
                    var am_alice_for_tx2 = am_alice;
                    var tx2 = hedgehog.getTx2( chan_id, am_sender, tx1_txid, midstate, amnt, sum_of_alices_htlcs, sum_of_bobs_htlcs, am_alice_for_tx2, amnt_in_output_0 );
                    var expected_version_of_tx2 = m_r_s.tx2;

                    //sign tx2
                    var recipients_finalizer_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: midstate_tree[ 0 ] }).hex;
                    var senders_finalizer_sig = m_r_s.finalizer_sig;
                    var finalizer_sighash = tapscript.Signer.taproot.hash( tx2, 0, { extension: midstate_tree[ 0 ] }).hex;
                    var senders_pub = am_alice ? state.bobs_pub : state.alices_pub;
                    var senders_finalizer_sig_is_valid = await nobleSecp256k1.schnorr.verify( senders_finalizer_sig, finalizer_sighash, senders_pub );
                    console.log( 'senders_finalizer_sig_is_valid, right?', senders_finalizer_sig_is_valid );
                    if ( am_alice ) tx2.vin[ 0 ].witness = [ senders_finalizer_sig, recipients_finalizer_sig, midstate_scripts[ 0 ], midstate_cblock ];
                    else tx2.vin[ 0 ].witness = [ recipients_finalizer_sig, senders_finalizer_sig, midstate_scripts[ 0 ], midstate_cblock ];

                    //prepare a tx that pays the fee for tx1
                    var addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], hedgehog.network );
                    if ( !txdata ) {
                        console.log( 'send 1000 sats into this address:' );
                        console.log( addy );
                        var txid2 = prompt( `send 1000 sats into the address in your console and enter the txid` );
                        if ( !txid2 ) return;
                        var vout2 = Number( prompt( `and the vout` ) );
                        var amnt2 = Number( prompt( `and the amount` ) );
                    } else {
                        var [ txid2, vout2, amnt2 ] = txdata;
                    }
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    var tx1_fee = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( tx1_txid, 1, hedgehog.anchor_value, "51024e73" ),
                            hedgehog.getVin( txid2, vout2, amnt2, addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt2 - 500, addy ),
                        ],
                    });
                    var fee_sig = tapscript.Signer.taproot.sign( privkey, tx1_fee, 1 ).hex;
                    tx1_fee.vin[ 1 ].witness = [ fee_sig ];

                    //prepare a tx that pays the fee for tx2
                    var tx1_fee_txid = tapscript.Tx.util.getTxid( tx1_fee );
                    var tx2_txid = tapscript.Tx.util.getTxid( tx2 );
                    var tx2_fee = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( tx2_txid, 0, hedgehog.anchor_value, "51024e73" ),
                            hedgehog.getVin( tx1_fee_txid, 0, amnt2 - 500, addy ),
                        ],
                        vout: [{
                            value: 0,
                            scriptPubKey: [ "OP_RETURN" ],
                        }],
                    });
                    var fee2_sig = tapscript.Signer.taproot.sign( privkey, tx2_fee, 1 ).hex;
                    tx2_fee.vin[ 1 ].witness = [ fee2_sig ];

                    //broadcast everything
                    //TODO: if there were extra outputs, prepare to broadcast their sweep txs as their timeouts approach
                    return { tx1, tx1_fee, tx2, tx2_fee }
                },
                getHtlcSigs: ( chan_id, sender_is_funder, am_sender, pmthash, relative_timelock, privkey, senders_reveal_part_one_tx, recipients_reveal_part_one_tx ) => {
                    var recipients_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, !sender_is_funder, !am_sender, pmthash, relative_timelock );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_initial_htlc_scripts, 1 );
                    var senders_initial_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, pmthash, relative_timelock );
                    var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_initial_htlc_scripts, 1 );
                    var sig_on_recipients_reveal_p1_tx = tapscript.Signer.taproot.sign( privkey, recipients_reveal_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 0 ]} ).hex;
                    var sig_on_senders_reveal_p1_tx = tapscript.Signer.taproot.sign( privkey, senders_reveal_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 0 ]} ).hex;
                    return { sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx, senders_initial_htlc_addy, senders_initial_htlc_tree, recipients_initial_htlc_addy, recipients_initial_htlc_tree };
                },
                runBasicTests: async ( test_on_regtest, b_force, disappearance, a_force, justice ) => {
                    //prepare a keypair
                    var privkey = hedgehog.getPrivkey();
                    var pubkey = hedgehog.getPubkey( privkey );
                    var preimage = hedgehog.getPrivkey();
                    var hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    hedgehog.keypairs[ pubkey ] = {privkey, preimage}

                    //test opening a channel
                    console.log( 'testing opening a channel...' );
                    var bobs_pubkey = Object.keys( hedgehog.keypairs )[ 0 ];
                    var bobs_hash = await hedgehog.sha256( hedgehog.hexToBytes( hedgehog.keypairs[ bobs_pubkey ].preimage ) );
                    var bobs_pubkey_and_hash = [ bobs_pubkey, bobs_hash ];
                    var txdata = null;
                    var txdata2 = null;
                    //txdata2 is used later when testing force closures later. You can test them on regtest or testnet by commenting out the two lines below. If you do, then the openChannel command will prompt you to manually enter a txid, vout, and amount for your funding transaction, and the forceClose command will promt you to manually enter similar data for a transaction that pays the fee for your force closures.
                    if ( !test_on_regtest ) {
                        txdata = [ "a".repeat( 64 ), 0, 10_000 ];
                        txdata2 = [ "a".repeat( 64 ), 0, 1_000 ];
                    }
                    var show_logs = !txdata2;
                    var data_for_bob = await hedgehog.openChannel( bobs_pubkey_and_hash, txdata );
                    var channel_is_valid = await hedgehog.openChannel( null, null, data_for_bob );
                    console.log( 'channel_is_valid, right?', channel_is_valid );
                    console.log( `alice's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 1 ]}` );
                    var test0 = "failed";
                    if ( channel_is_valid ) test0 = "passed";

                    //test sending from bob to alice
                    console.log( 'testing a payment of 8000 sats from bob to alice...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 8_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `bob's payment to alice worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test1 = "failed";
                    if ( they_agree ) test1 = "passed";

                    //test sending from alice to bob
                    console.log( 'testing a payment of 2000 sats from alice to bob...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's payment to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test2 = "failed";
                    if ( they_agree ) test2 = "passed";

                    //test a second consecutive payment from alice to bob
                    console.log( 'testing a second payment from alice to bob of 3_000 sats...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 3_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's second payment to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test3 = "failed";
                    if ( they_agree ) test3 = "passed";

                    //test two payments from bob to alice, where alice does not notice the first
                    console.log( 'testing two payments from bob to alice of 2_000 sats apiece...' );
                    console.log( 'note that alice will not notice the first one...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    // await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `bob's two payments to alice worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test4 = "failed";
                    if ( they_agree ) test4 = "passed";

                    //test two payments from alice to bob, where bob does not notice the first
                    console.log( 'testing two payments from alice to bob of 2_000 sats apiece...' );
                    console.log( 'note that bob will not notice the first one...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    // await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's two payments to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test5 = "failed";
                    if ( they_agree ) test5 = "passed";

                    //test two payments from bob to alice, where alice notices both
                    console.log( 'testing two payments from bob to alice of 2_000 sats apiece...' );
                    console.log( 'note that alice will notice both...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `bob's two payments to alice worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test6 = "failed";
                    if ( they_agree ) test6 = "passed";

                    //test three payments from alice to bob, where bob notices all of them
                    console.log( 'testing three payments from alice to bob of 2_000 sats apiece...' );
                    console.log( 'note that bob will notice all of them...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's three payments to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test7 = "failed";
                    if ( they_agree ) test7 = "passed";

                    //test a force closure by bob when he has the latest state
                    console.log( 'testing a force closure by bob when he has the latest state...' );
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    //the txid variable is used for checking if your counterparty broadcasted the latest state.
                    //if you detect that your counterparty broadcasted tx1 of the force closure transactions,
                    //you can get its txid and pass it to the forceClose command, and if your counterparty did
                    //*not* broadcast the latest state, it will do one of two things: if they broadcasted a
                    //state that they *fully* revoked, it will return a justice transaction that takes their
                    //money; if they broadcasted a state that they *conditionally* revoked, it will return a
                    //transaction that updates the state to the latest one
                    var txid = null;
                    var test8;
                    console.log( 0 );
                    if ( b_force || disappearance ) {
                        console.log( 1 );
                        if ( test_on_regtest && ( b_force || disappearance ) ) alert( `we are about to test a force closure by bob, so you will be prompted to send additional money in so that he may cover the fees associated with his force closure` );
                        var force_closure_txs = await hedgehog.forceClose( b_chan_id, txid, txdata2 );
                        var { tx1, tx1_fee, tx2, tx2_fee } = force_closure_txs;
                        if ( b_force && show_logs ) {
                            console.log( 'broadcast this to create the midstate:' );
                            console.log( tapscript.Tx.encode( tx1 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx1_fee ).hex );
                            console.log( 'then wait 2 weeks' );
                            console.log( 'then broadcast this to finalize your state:' );
                            console.log( tapscript.Tx.encode( tx2 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx2_fee ).hex );
                        }
                        console.log( `alice got the amount she should, right?`, tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( a_chan_id )[ 0 ] );
                        console.log( `bob got the amount he should, right?`, tx2.vout[ 2 ][ "value" ] === hedgehog.getBalances( a_chan_id )[ 1 ] - ( hedgehog.anchor_value + hedgehog.anchor_value ) );
                        test8 = "failed";
                        if ( tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( a_chan_id )[ 0 ] && hedgehog.getBalances( a_chan_id )[ 1 ] - ( hedgehog.anchor_value + hedgehog.anchor_value ) ) test8 = "passed";
                    }
                    if ( b_force ) return { test0, test1, test2, test3, test4, test5, test6, test7, test8 };

                    //test that alice can recover the money bob abandoned if bob disappears before broadcasting tx2
                    var test9;
                    if ( disappearance ) {
                        console.log( 'testing that alice can recover the money bob abandoned if bob disappears before broadcasting tx2...' );
                        var a_chan_id = data_for_bob.chan_id;
                        var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                        var { disappearance_tx } = await hedgehog.forceClose( a_chan_id, tx1_txid );
                        var total_in_channel = hedgehog.getBalances( a_chan_id ).reduce( ( accumulator, currentValue ) => accumulator + currentValue, 0 );
                        if ( show_logs ) {
                            console.log( 'broadcast this to create the midstate:' );
                            console.log( tapscript.Tx.encode( tx1 ).hex );
                            console.log( 'wait 2026 blocks' );
                            console.log( 'broadcast this disappearance_tx transaction because Bob never broadcasted tx2:' );
                            console.log( tapscript.Tx.encode( disappearance_tx ).hex );
                        }
                        console.log( 'alice can sweep everything after 2026 blocks, right?', disappearance_tx.vout[ 0 ].value === total_in_channel - hedgehog.anchor_value - 500 );
                        test9 = "failed";
                        if ( disappearance_tx.vout[ 0 ].value === total_in_channel - hedgehog.anchor_value - 500 ) test9 = "passed";
                        if ( disappearance ) return { test0, test1, test2, test3, test4, test5, test6, test7, test8, test9 };
                    }

                    //test a force closure by alice when she does *not* have the latest state
                    console.log( 'testing a force closure by alice when she does *not* have the latest state...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var txid = null;
                    if ( test_on_regtest ) alert( `we are about to test a force closure by alice in a situation where she does not have the latest state. Consequently, you will be prompted to send additional money in so that she may cover the fees associated with her force closure` );
                    var alices_force_closure_txs = await hedgehog.forceClose( a_chan_id, txid, txdata2 );
                    var { tx1, tx1_fee } = alices_force_closure_txs;
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    if ( test_on_regtest && a_force ) alert( `since Alice did not have the latest state, she broadcasted the previous state, and bob will have to finalize it in the latest state so that he does not lose any money; consequently, bob will need to broadcast a transaction, and therefore you will be prompted *again* to send in *even more* additional money in so that he may cover the fees required to finalize the state` );
                    var test10;
                    if ( a_force ) {
                        var bobs_force_closure_txs = await hedgehog.forceClose( b_chan_id, tx1_txid, txdata2 );
                        var { alt_tx2: tx2, tx2_fee } = bobs_force_closure_txs;
                        if ( show_logs ) {
                            console.log( 'broadcast this to create the midstate:' );
                            console.log( tapscript.Tx.encode( tx1 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx1_fee ).hex );
                            console.log( 'broadcast this to finalize in the latest state:' );
                            console.log( tapscript.Tx.encode( tx2 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx2_fee ).hex );
                        }
                        console.log( `alice got the amount she should, right?`, tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( b_chan_id )[ 0 ], tx2.vout[ 1 ][ "value" ], hedgehog.getBalances( b_chan_id )[ 0 ] );
                        console.log( `bob got the amount he should, right?`, tx2.vout[ 2 ][ "value" ] === hedgehog.getBalances( b_chan_id )[ 1 ] - ( hedgehog.anchor_value + hedgehog.anchor_value ), tx2.vout[ 2 ][ "value" ], hedgehog.getBalances( b_chan_id )[ 1 ] );
                        test10 = "failed";
                        if ( tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( b_chan_id )[ 0 ] && hedgehog.getBalances( b_chan_id )[ 1 ] - ( hedgehog.anchor_value + hedgehog.anchor_value ) ) test10 = "passed";
                        return { test0, test1, test2, test3, test4, test5, test6, test7, test8, test9, test10 }
                    }

                    //test a force closure by bob when she does *not* have the latest state
                    console.log( 'testing a force closure by alice when she does *not* have the latest state...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var txid = null;
                },
                runHTLCTests: async test_on_regtest => {
                    //prepare a keypair
                    var privkey = hedgehog.getPrivkey();
                    var pubkey = hedgehog.getPubkey( privkey );
                    var preimage = hedgehog.getPrivkey();
                    var hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    hedgehog.keypairs[ pubkey ] = {privkey, preimage}

                    //test opening a channel
                    console.log( 'testing opening a channel...' );
                    var bobs_pubkey = Object.keys( hedgehog.keypairs )[ 0 ];
                    var bobs_hash = await hedgehog.sha256( hedgehog.hexToBytes( hedgehog.keypairs[ bobs_pubkey ].preimage ) );
                    var bobs_pubkey_and_hash = [ bobs_pubkey, bobs_hash ];
                    var txdata = null;
                    var txdata2 = null;
                    //txdata2 is used later when testing force closures later. You can test them on regtest or testnet by commenting out the two lines below. If you do, then the openChannel command will prompt you to manually enter a txid, vout, and amount for your funding transaction, and the forceClose command will promt you to manually enter similar data for a transaction that pays the fee for your force closures.
                    if ( !test_on_regtest ) {
                        txdata = [ "a".repeat( 64 ), 0, 10_000 ];
                        txdata2 = [ "a".repeat( 64 ), 0, 1_000 ];
                    }
                    var show_logs = !txdata2;
                    var data_for_bob = await hedgehog.openChannel( bobs_pubkey_and_hash, txdata );
                    var channel_is_valid = await hedgehog.openChannel( null, null, data_for_bob );
                    console.log( 'channel_is_valid, right?', channel_is_valid );
                    console.log( `alice's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 1 ]}` );
                    var test0 = "failed";
                    if ( channel_is_valid ) test0 = "passed";

                    //test sending an HTLC from bob to alice
                    console.log( 'testing an HTLC payment of 8000 sats from bob to alice...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var chan_id = b_chan_id;
                    var amnt = 8_000;
                    var relative_timelock = 20;
                    var pmthash = await hedgehog.sendHtlc( chan_id, amnt, relative_timelock );
                    var preimage = await hedgehog.findPreimage( chan_id, pmthash );
                    //TODO: write some sort of function for resolving an htlc and call it here
                },
                runAllTests: async () => {
                    var test_on_regtest = confirm( `click ok if you want to test on regtest, which requires manually entering transaction data. Otherwise click cancel and we will just assume the signatures generated by these tests are valid` );
                    var b_force = await hedgehog.runBasicTests( test_on_regtest, true );
                    var disappearance = await hedgehog.runBasicTests( test_on_regtest, false, true );
                    var a_force = await hedgehog.runBasicTests( test_on_regtest, false, false, true );
                    console.log( 'in these tests, Bob force closes the channel in the latest state:' );
                    console.log( b_force );
                    console.log( 'in these tests, Bob initiates a force closure but then disappears before finalizing, so Alice sweeps the funds:' );
                    console.log( disappearance );
                    console.log( 'in these tests, Alice force closes the channel in the previous state, and Bob corrects it:' );
                    console.log( a_force );
                    console.log( 'note that in the above example, it is okay for test8 and test9 to be undefined because we did not run test8 or test9, which are only relevant when Bob initiates a force closure' );
                },
                intercom: async data_for_user => {
                    throw( 'batteries not included -- you are supposed to overwrite this function with something that *actually* communicates with the user' );
                },
            }
        </script>
        <script>
            var hedgehog_client = {
                network: "testnet4/",
                network_string: null,
                explorer: "mempool.space",
                server: null,
                relays: null,
                backup_privkey: null,
                backup_relays: [ 'wss://relay.nuts.cash/' ],
                nostr_privkey: null,
                two_way_comms: {},
                funded_checks: {},
                unfunded_checks: {},
                num_of_checks: 0,
                ln_support: "unknown",
                use_rest: "unknown",
                rest_endpoint: null,
                subscriptions: {},
                server_id: null,
                showPage: page => {
                    $( '.welcome_page' ).classList.add( "hidden" );
                    $( '.wallet_page' ).classList.add( "hidden" );
                    $( '.loading_page' ).classList.add( "hidden" );
                    $( '.checks_page' ).classList.add( "hidden" );
                    $( '.check_page' ).classList.add( "hidden" );
                    $( `.${page}` ).classList.remove( "hidden" );
                },
                onboard: async ( server_id, check_hex ) => {
                    if ( !server_id && !url_params.hasOwnProperty( "server_id" ) ) {
                        var server_id = prompt( `enter a server id. Don't know one? Ask bitcoiners to recommend you a good hedgehog server and get its server id from them.` );
                        var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#server_id=${server_id}#onboard=true`;
                        window.location.href = url;
                        window.location.reload();
                        return;
                    } else if ( url_params.hasOwnProperty( "server_id" ) ) {
                        var server_id = url_params.server_id;
                    }
                    hedgehog_client.server_id = server_id;
                    url_params.server_id = server_id;
                    var server_info = JSON.parse( hedgehog_client.hexToText( server_id ) );
                    var { connection_string, connection_type, ln_support } = server_info;
                    hedgehog_client.ln_support = ln_support;
                    if ( connection_type === "nostr" ) {
                        var [ server, relays ] = hedgehog_client.convertNEvent( connection_string );
                        hedgehog_client.server = server;
                        hedgehog_client.relays = relays;
                    }
                    //Do not ask the user to backup their privkey if they already did
                    if ( hedgehog_client.backup_privkey ) {
                        var backup_privkey = hedgehog_client.backup_privkey;
                        var backup_string = hedgehog_client.convertPubkeyAndRelaysToNprofile( "nbackup", backup_privkey, hedgehog_client.backup_relays );
                        await hedgehog_client.login( backup_string, check_hex );
                        return;
                    }
                    //TODO: ensure the backup string includes nostr relays where you will store your data, so that you load that data from them when you log in later
                    var backup_privkey = super_nostr.getPrivkey();
                    var backup_string = hedgehog_client.convertPubkeyAndRelaysToNprofile( "nbackup", backup_privkey, hedgehog_client.backup_relays );
                    var content = `
                        <p>Here is your backup string</p>
                        <p class="show_backup_string">${backup_string}</p>
                        <p>Store it safely.</p>
                        <p><button class="done_storing_backup_string">Done</button></p>
                    `;
                    var loop = async () => {
                        if ( $( '.modal' ) ) return;
                        await hedgehog_client.waitSomeTime( 100 );
                        loop();
                    }
                    await loop();
                    showModal( content );
                    $( '.done_storing_backup_string' ).onclick = () => {
                        var content = `
                            <p>Are you sure? A lot of people just click done without actually storing it. Don't be like them! You'll lose your money!</p>
                            <p class="show_backup_string">${backup_string}</p>
                            <p><button class="really_done_storing_backup_string">Yes, I am really done</button></p>
                        `;
                        showModal( content );
                        $( '.really_done_storing_backup_string' ).onclick = () => {
                            if ( window.location.href.includes( "onboard=true" ) ) {
                                url_params.backup_string = backup_string;
                                var str_to_add = '';
                                Object.keys( url_params ).forEach( item => {
                                    if ( item === "onboard" ) return;
                                    str_to_add = str_to_add + `#${item}=${url_params[ item ]}`;
                                });
                                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + str_to_add;
                                window.location.href = url;
                                window.location.reload();
                                return;
                            } else {
                                if ( check_hex ) hedgehog_client.login( backup_string, check_hex );
                                else hedgehog_client.login( backup_string );
                                modalVanish();
                            }
                        }
                    }
                },
                login: async ( backup_string, check_hex ) => {
                    hedgehog_client.pingServer();
                    hedgehog_client.manageChecks();
                    hedgehog_client.manageSubscriptions();
                    var [ backup_privkey, backup_relays ] = hedgehog_client.convertNEvent( backup_string );
                    hedgehog_client.backup_privkey = backup_privkey;
                    hedgehog_client.backup_relays = backup_relays;
                    hedgehog_client.showPage( 'loading_page' );
                    await hedgehog_client.downloadState();
                    hedgehog_client.showPage( 'wallet_page' );
                    hedgehog_client.nostr_privkey = super_nostr.getPrivkey();
                    //TODO: allow people to use more than one hedgehog server
                    if ( url_params.server_id && !hedgehog_client.server ) {
                        var server_id = url_params.server_id;
                        hedgehog_client.server_id = server_id;
                        var server_info = JSON.parse( hedgehog_client.hexToText( server_id ) );
                        var { connection_string, connection_type, ln_support, use_rest, rest_endpoint } = server_info;
                        hedgehog_client.ln_support = ln_support;
                        hedgehog_client.use_rest = use_rest;
                        if ( use_rest ) hedgehog_client.rest_endpoint = rest_endpoint;
                        if ( connection_type === "nostr" ) {
                            var [ server, relays ] = hedgehog_client.convertNEvent( connection_string );
                            hedgehog_client.server = server;
                            hedgehog_client.relays = relays;
                        }
                    }
                    //TODO: load data from the nostr relays in your backup string so that you know what relays the server uses, which should be stored there
                    await hedgehog_client.listenForComms();
                    if ( check_hex ) {
                        url_params.check_hex = check_hex;
                        var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                        var fee_payment = {encrypted_channel_fee_data: check_data.encrypted_channel_fee_data, encryption_pubkey: check_data.check_encryption_pubkey, encrypted_chan_id: check_data.check_encrypted_chan_id};
                        var skip_channel_payment = true;
                        //note that we request 40k sats and the server will double it to 80k
                        hedgehog_client.makeJITChannelPartOne( 40_000, fee_payment, skip_channel_payment );
                        return;
                    }
                },
                downloadState: async () => {
                    var backup_privkey = hedgehog_client.backup_privkey;
                    var backup_pubkey = super_nostr.getPubkey( backup_privkey );
                    var relay = hedgehog_client.backup_relays[ 0 ];
                    var ids = null;
                    var authors = [ backup_pubkey ];
                    var kinds = [ 16108 ];
                    var until = null;
                    var since = null;
                    var limit = 1;
                    var alt_event = localStorage.hedgehog_client_state ? localStorage.hedgehog_client_state : "";
                    if ( alt_event ) alt_event = JSON.parse( alt_event );
                    //var events = await super_nostr.getEvents( relay, ids, authors, kinds, until, since, limit );
                    var events = [];
                    if ( !events.length && !alt_event ) {
                        console.log( 'no state' );
                        hedgehog_client.uploadStateLoop();
                        hedgehog_client.balanceLoop();
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    var state_event = events[ 0 ];
                    var real_event = state_event;
                    if ( !real_event ) real_event = alt_event;
                    if ( alt_event && alt_event.length > JSON.stringify( real_event ).length ) real_event = JSON.parse( alt_event );
                    try {
                        real_event.content = await super_nostr.alt_decrypt( backup_privkey, backup_pubkey, real_event.content );                        
                    } catch ( e ) {
                        console.log( 'no state' );
                        hedgehog_client.uploadStateLoop();
                        hedgehog_client.balanceLoop();
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    var {
                        network,
                        explorer,
                        server,
                        relays,
                        checks,
                        state,
                    } = JSON.parse( real_event.content );
                    hedgehog.state = state;
                    hedgehog_client.network = network;
                    hedgehog_client.explorer = explorer;
                    hedgehog_client.server = server;
                    hedgehog_client.relays = relays;
                    hedgehog_client.funded_checks = checks;
                    hedgehog_client.uploadStateLoop();
                    hedgehog_client.balanceLoop();
                    hedgehog_client.handleChecksLoop();
                },
                uploadStateLoop: async () => {
                    await hedgehog_client.waitSomeTime( 3000 );
                    var backup_privkey = hedgehog_client.backup_privkey;
                    var backup_pubkey = super_nostr.getPubkey( backup_privkey );
                    var { network, explorer, server, relays, checks } = hedgehog_client;
                    var state = hedgehog.state;
                    if ( !Object.keys( state ).length ) $( '.open_channel' ).classList.remove( "hidden" );
                    var plaintext = JSON.stringify({ network, explorer, server, relays, checks, state });
                    var encrypted = await super_nostr.alt_encrypt( backup_privkey, backup_pubkey, plaintext );
                    var event = await super_nostr.prepEvent( backup_privkey, encrypted, 16108 );
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    if ( !socket_id ) {
                        hedgehog_client.uploadStateLoop();
                        return;
                    }
                    //TODO: uncomment the line below to upload your state to nostr
                    // super_nostr.sendEvent( event, hedgehog_client.backup_relays[ 0 ] );
                    localStorage.hedgehog_client_state = JSON.stringify( event );
                    hedgehog_client.uploadStateLoop();
                },
                getBalance: chan_id => {
                    if ( !chan_id ) return [ 0, 0 ];
                    var income = 0;
                    var expenses = 0;
                    hedgehog.state[ chan_id ].channel_states.forEach( ( item, index ) => {
                        if ( item.from === "bob" && !item.added_htlc ) income = income + item.amnt_sent;
                        if ( index && item.from === "alice" && !item.added_htlc ) expenses = expenses + item.amnt_sent;
                    });
                    var in_checks = 0;
                    Object.keys( hedgehog_client.funded_checks ).forEach( check_id => {
                        var check = hedgehog_client.funded_checks[ check_id ];
                        in_checks = in_checks + check.check_amount + check.channel_fee;
                    });
                    return [ income - expenses, in_checks ];
                },
                balanceLoop: async () => {
                    //TODO: allow more than one channel
                    var chan_id = hedgehog_client.getChanId();
                    if ( !chan_id ) {
                        await hedgehog_client.waitSomeTime( 1000 );
                        hedgehog_client.balanceLoop();
                    }
                    if ( Object.keys( hedgehog_client.funded_checks ).length ) {
                        $( '.checks_amnt_p' ).classList.remove( "hidden" );
                    } else {
                        $( '.checks_amnt_p' ).classList.add( "hidden" );
                    }
                    var [ balance_not_in_checks, balance_in_checks ] = hedgehog_client.getBalance( chan_id );
                    $( '.balance' ).innerText = balance_not_in_checks - balance_in_checks;
                    $( '.balance_in_checks' ).innerText = balance_in_checks;
                    await hedgehog_client.waitSomeTime( 100 );
                    hedgehog_client.balanceLoop();
                },
                openChannel: async () => {
                    //note that we request 40k sats and the server will double it to 80k
                    hedgehog_client.makeJITChannelPartOne( 40_000 );
                },
                receive: async check => {
                    var chan_id = hedgehog_client.getChanId();
                    if ( !chan_id && !check ) return alert( 'open a channel first' );
                    if ( check ) var amnt_or_check = check;
                    else var amnt_or_check = prompt( `enter the amount of sats you want to receive, or enter a check` );
                    if ( !amnt_or_check ) return;
                    //if the string received is interpretable as a number, then do the following:
                    if ( !isNaN( amnt_or_check ) ) {
                        //convert it to a number
                        amnt_or_check = Number( amnt_or_check );
                        if ( hedgehog_client.ln_support ) {
                            //pass it into prepToReceiveLNPartOne
                            var use_ln = confirm( `click ok to receive via LN or cancel to receive via L1` );
                            if ( use_ln ) {
                                hedgehog_client.prepToReceiveLNPartOne( chan_id, amnt_or_check );
                                return;
                            }
                        }
                        hedgehog_client.prepToReceiveL1PartOne( chan_id, amnt_or_check );
                        return;
                    }
                    //otherwise, treat it as a check and store it
                    url_params.check = amnt_or_check.substring( amnt_or_check.indexOf( "#check=" ) + 7 );
                    var skip_show = true;
                    //display the check page
                    hedgehog_client.checkPage( skip_show );
                },
                makeJITChannelPartOne: async ( amount, fee_payment, skip_channel_payment ) => {
                    var msg_for_server = JSON.stringify({
                        msg_type: "channel_request",
                        msg_value: {
                            amount,
                            fee_payment,
                        }
                    });
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.makeJITChannelPartTwo( privkey, amount, skip_channel_payment );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                makeJITChannelPartTwo: async ( privkey, amount, skip_channel_payment ) => {
                    //prepare the necessary variables
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    showModal( 'waiting for server...' );

                    //get the message from the server
                    var message_identifier = "channel_request_reply";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the data from the server
                    var json = JSON.parse( event.content );
                    if ( json.msg_type !== "channel_request_reply" ) return showModal( 'aborting -- server tried to cheat you by sending you bad data' );

                    try {
                        //add subscription, if any
                        if ( json.msg_value.hasOwnProperty( "subscription_required" ) && json.msg_value.subscription_required ) {
                            var server_id = hedgehog_client.server_id;
                            var server_info = JSON.parse( hedgehog_client.hexToText( server_id ) );
                            console.log( json.msg_value, server_info );
                            console.log( server_info.subscription_info );
                            var conf = confirm( `the server wants to you to subscribe to their L2 in such a manner that you will pay ${server_info.subscription_info.cost} sats every ${server_info.subscription_info.interval} seconds or your channel will stop being serviced and you may have to force close. Click ok if you want to subscribe, otherwise click cancel` );
                            if ( !conf ) return showModal( `aborting because you did not want to pay the requisite subscription` );
                            var subscription_start_time = json.msg_value.subscription_start_time;
                            var subscription_interval = server_info.subscription_info.interval;
                            //if the server asks for a subscription start time that is out of sync with the expected time by more than 30 seconds, throw an error
                            if ( Math.abs( subscription_start_time - ( Math.floor( Date.now() / 1000 ) + subscription_interval ) ) > 30 ) throw( 'bad subscription' );

                            //store the subscription info
                            var subscription_id = "s_" + hedgehog.getPrivkey().substring( 0, 16 );

                            hedgehog_client.subscriptions[ subscription_id ] = {...server_info.subscription_info, subscription_start_time, funded_check_ids: [], unfunded_check_ids: []}
                        }
                    } catch ( e ) {
                        return showModal( 'aborting -- server tried to cheat you by sending you bad subscription info' );
                    }

                    //validate the utxo data
                    if ( typeof json.msg_value.utxos === "string" ) return showModal( 'aborting -- server did not have enough money to fund this channel' );
                    var network_string = json.msg_value.network_string;
                    hedgehog_client.network_string = network_string;
                    var cost_of_channel = json.msg_value.cost_of_channel;
                    var all_is_well = true;
                    try {
                        var sum_of_utxos = 0;
                        var i; for ( i=0; i<json.msg_value.utxos.length; i++ ) {
                            var utxo = json.msg_value.utxos[ i ];
                            sum_of_utxos = sum_of_utxos + utxo.amnt;
                            var addy_is_segwit = utxo.addy.startsWith( "tb1" ) || utxo.addy.startsWith( "bc1" );
                            if ( !addy_is_segwit ) {
                                all_is_well = false;
                                break;
                            }
                            var utxo_exists = await hedgehog_client.utxoExists( utxo, network_string );
                            if ( !utxo_exists ) {
                                all_is_well = false;
                                break;
                            }
                        }
                        if ( sum_of_utxos < amount ) all_is_well = false;
                        if ( !all_is_well ) return showModal( 'aborting --- server tried to cheat you by sending you invalid utxo data' );
                    } catch ( e ) {each_utxo_is_valid = false;}

                    try {
                        //validate the fee_address, if any
                        var fee_address = null;
                        if ( json.msg_value.hasOwnProperty( "fee_address" ) ) {
                            fee_address = json.msg_value.fee_address;
                            //TODO: uncomment the line below
                            // if ( !fee_invoice.startsWith( "ln" ) ) return showModal( 'aborting -- server refused to fund your channel' );
                        }

                        var bobs_pubkey_and_hash = [ json.msg_value.channel_pubkey_and_hash.pubkey, json.msg_value.channel_pubkey_and_hash.hash ];
                        var channel_capacity = json.msg_value.channel_capacity;
                        //TODO: ensure the channel_capacity makes sense with what you're being charged via the fee_invoice, if any
                        //TODO: ensure these values don't result in an invalid tx e.g. due to
                        //paying too low of a fee or having a negative vout value
                        var txfee = json.msg_value.fee;
                        var change_address = json.msg_value.change_address;
                        var chan_id = await hedgehog.prepChannel( bobs_pubkey_and_hash );
                        var channel_scripts = hedgehog.getChannelScripts( chan_id );
                        var channel = hedgehog.getAddressData( channel_scripts, 0 )[ 0 ];

                        var funding_vin = [];
                        json.msg_value.utxos.forEach( utxo => funding_vin.push( hedgehog.getVin( utxo.txid, utxo.vout, utxo.amnt, utxo.addy ) ) );
                        var funding_tx = tapscript.Tx.create({
                            version: 2,
                            vin: funding_vin,
                            vout: [
                                hedgehog.getVout( channel_capacity, channel ),
                            ],
                        });
                        if ( sum_of_utxos - channel_capacity - txfee > 330 ) funding_tx.vout.push( hedgehog.getVout( sum_of_utxos - channel_capacity - txfee, change_address ) );
                        var funding_txid = tapscript.Tx.util.getTxid( funding_tx );
                        var txdata = [ funding_txid, 0, channel_capacity ];
                        var data_for_bob = await hedgehog.openChannel( bobs_pubkey_and_hash, txdata, null, chan_id );

                        //send channel data to server
                        var msg_for_server = JSON.stringify({
                            msg_type: "channel_init",
                            msg_value: data_for_bob,
                        });
                        var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                        var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                        hedgehog_client.makeJITChannelPartThree( privkey, chan_id, fee_address, cost_of_channel, network_string, skip_channel_payment );
                        hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                        //cash check, if any
                        if ( !json.msg_value.need_fee_invoice ) modalVanish();
                        if ( url_params.hasOwnProperty( "check_hex" ) ) {
                            showModal( `<p>cashing check...</p>` );
                            var check_hex = url_params.check_hex;
                            var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                            var { check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey } = check_data;
                            hedgehog_client.cashCheck( chan_id, check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey );
                        }
                    } catch ( e ) {
                        showModal( `aborting -- unknown error, ${e}` );
                    }
                },
                makeJITChannelPartThree: async ( privkey, chan_id, fee_address, cost_of_channel, network_string, skip_channel_payment ) => {
                    if ( fee_address ) {
                        //prepare the necessary variables
                        var pubkey = super_nostr.getPubkey( privkey );
                        var server = hedgehog_client.server;
                        if ( !skip_channel_payment ) {
                            setTimeout( () => {
                                showModal( `<p>Paying ${cost_of_channel} sats to this address will buy you a channel with 80k sats of inbound capacity</p><p>${fee_address}</p>` );
                            }, 100 );
                            console.log( `you can send money to the address like this:` );
                            console.log( `var my_network = "${network_string}".split( "," );chain_client.commander( my_network, "send", {destino: "${fee_address}", amnt: 330, feerate: 1} )` );
                        }

                        //get the message from the server
                        var message_identifier = "channel_init_reply";
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        var loop = async () => {
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var event = await loop();
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        //inform the user what's up
                        if ( !skip_channel_payment ) {
                            var message_to_show_user = `<p>Payment detected. Do not use it until your channel funding tx confirms (${hedgehog.state[ chan_id ].funding_txinfo[ 0 ]}) unless you trust the server</p>`;
                        } else {
                            var message_to_show_user = `<p>Your check included a bit extra to cover the cost of a new channel. This channel is now being created. Do not use it until your channel funding tx confirms (${hedgehog.state[ chan_id ].funding_txinfo[ 0 ]}) unless you trust the server</p>`;
                        }
                        showModal( message_to_show_user );
                    }
                    $( '.open_channel' ).classList.add( "hidden" );
                },
                prepToReceiveL1PartOne: async ( chan_id, amount ) => {
                    //in Part One we create a preimage, share its hash with the server, and get back a submarine swap address; our sender pays that, and we know the server cannot sweep the money from it without our preimage; then we prepare a new state for hedgehog using its receiveHtlcPartOne method, and then we run prepToReceiveLNPartTwo.

                    //prepare the needed variables
                    var privkey = hedgehog_client.nostr_privkey;
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var preimage = super_nostr.getPrivkey();
                    var hash = await super_nostr.sha256( super_nostr.hexToBytes( preimage ) );

                    //show the user a pending window
                    showModal( `<p>Please wait...</p>` );

                    //request the server to help you bridge L1 to hedgehog
                    var msg_for_server = JSON.stringify({
                        msg_type: "request_l1_pmt_to_user",
                        msg_value: {
                            chan_id,
                            amount,
                            hash,
                        }
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    // hedgehog_client.makeJITChannelPartTwo( privkey, amount );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    //get the message from the server
                    var message_identifier = "swap_address_for_user";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the data from the server
                    var json = JSON.parse( event.content );

                    //validate the invoice
                    var swap_address = json.msg_value.swap_address;
                    //TODO: validate that the swap address has the payment hash you expect

                    //present the invoice to the user
                    showModal( `<p>Pay this swap address</p><p>${swap_address}</p>` );

                    //get the message from the server
                    var message_identifier = "swap_address_funded";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //tell the user what's up
                    showModal( `<p>Payment detected -- bridging from L1 to hedgehog, please wait</p>` );

                    //get the next message from the server
                    var message_identifier = "initial_send_htlc_message";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        console.log( 0 );
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    console.log( 1 );

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    var data_for_htlc_p1 = json.msg_value;
                    delete data_for_htlc_p1[ "message_identifier" ];
                    var my_revhashes = await hedgehog.receiveHtlcPartOne( data_for_htlc_p1 );
                    console.log( 2 );

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "two_way_comms",
                        msg_value: {message_identifier, data_for_server: my_revhashes},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    console.log( 3 );
                    hedgehog_client.prepToReceiveLNPartTwo( privkey, chan_id, preimage, event );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                prepToReceiveLNPartOne: async ( chan_id, amount, skip_to_resolution ) => {
                    //in Part One we create a preimage, get an invoice from the server matching our invoice, and have the sender pay it, knowing the server cannot settle it without our preimage; then we prepare a new state for hedgehog using its receiveHtlcPartOne method, and then we run prepToReceiveLNPartTwo. We also have a parameter called "skip_to_resolution" and if it is *not* set, we run makeJITChannelPartTwo -- it seems to be set only when a check is being redeemed, so when a check is *not* being redeemed, i.e. it's just an ordinary LN payment, we seem to always run makeJITChannelPartTwo -- which seems strange; shouldn't we only do that if we don't have enough money in inbound capacity?

                    //prepare the needed variables
                    var privkey = hedgehog_client.nostr_privkey;
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var preimage = super_nostr.getPrivkey();
                    var hash = await super_nostr.sha256( super_nostr.hexToBytes( preimage ) );

                    if ( skip_to_resolution ) {
                        preimage = skip_to_resolution;
                        hash = await super_nostr.sha256( super_nostr.hexToBytes( preimage ) );
                    }

                    if ( !skip_to_resolution ) {
                        //request the server to help you bridge LN to hedgehog
                        var msg_for_server = JSON.stringify({
                            msg_type: "request_ln_pmt_to_user",
                            msg_value: {
                                chan_id,
                                amount,
                                hash,
                            }
                        });
                        var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                        var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                        hedgehog_client.makeJITChannelPartTwo( privkey, amount );
                        hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                        //get the message from the server
                        var message_identifier = "ln_invoice_for_user";
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        var loop = async () => {
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var event = await loop();
                        delete hedgehog_client.two_way_comms[ message_identifier ];

                        //parse the data from the server
                        var json = JSON.parse( event.content );

                        //validate the invoice
                        var ln_invoice = json.msg_value.ln_invoice;
                        //TODO: validate that the ln invoice has the payment hash you expect and the value you expect
                        //TODO: uncomment the line below
                        // if ( !ln_invoice.startsWith( "ln" ) ) return showModal( 'aborting -- server refused to fund your channel' );

                        //present the invoice to the user
                        showModal( `<p>Pay this invoice</p><p>${ln_invoice}</p>` );

                        //get the message from the server
                        var message_identifier = "ln_invoice_paid";
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        var loop = async () => {
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var event = await loop();
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                    }

                    //get the next message from the server
                    var message_identifier = "two_way_comms";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //tell the user what's up
                    if ( !skip_to_resolution ) showModal( `<p>Payment detected -- bridging from LN to hedgehog, please wait</p>` );

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    var data_for_htlc_p1 = json.msg_value;
                    delete data_for_htlc_p1[ "message_identifier" ];
                    var my_revhashes = await hedgehog.receiveHtlcPartOne( data_for_htlc_p1 );

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "two_way_comms",
                        msg_value: {message_identifier, data_for_server: my_revhashes},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.prepToReceiveLNPartTwo( privkey, chan_id, preimage );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                prepToReceiveLNPartTwo: async ( privkey, chan_id, preimage, event ) => {
                    console.log( 4 );
                    //in Part Two we prompt the server to fund our hedgehog htlc off-chain, such that we can only settle it if we reveal our preimage, and the server gets their money back otherwise; then we run prepToReceiveLNPartThree

                    //prepare the necessary variables
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;

                    //get the next message from the server
                    var message_identifier = "two_way_comms";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var limit = 50;
                    var loop = async () => {
                        console.log( limit );
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) {
                            if ( event && limit < 1 ) {
                                console.log( 'resending event' );
                                hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                            }
                            limit = limit - 1;
                            if ( limit < 1 ) limit = 50;
                            return loop();
                        }
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    var data_for_htlc_p2 = json.msg_value;
                    delete data_for_htlc_p2[ "message_identifier" ];
                    var data_for_server = await hedgehog.receiveHtlcPartTwo( data_for_htlc_p2 );

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "two_way_comms",
                        msg_value: {message_identifier, data_for_server},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.prepToReceiveLNPartThree( privkey, chan_id, preimage );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                prepToReceiveLNPartThree: async ( privkey, chan_id, preimage ) => {
                    //in Part Three we check if our hedgehog htlc is properly funded in off-chain manner; if so, we know we can settle it if we reveal our preimage, and we run prepToReceiveLNPartFour

                    //prepare the necessary variables
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;

                    //get the next message from the server
                    var message_identifier = "two_way_comms";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    var data_for_htlc_p3 = json.msg_value;
                    delete data_for_htlc_p3[ "message_identifier" ];
                    var data_for_server = await hedgehog.receiveHtlcPartThree( data_for_htlc_p3 );

                    //store the preimage to the now-pending htlc
                    var extra_outputs = hedgehog.state[ chan_id ].channel_states[ hedgehog.state[ chan_id ].channel_states.length - 1 ].extra_outputs;
                    extra_outputs[ extra_outputs.length - 1 ].pmt_preimage = preimage;

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "two_way_comms",
                        msg_value: {message_identifier, data_for_server},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.prepToReceiveLNPartFour( privkey, chan_id, preimage );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                prepToReceiveLNPartFour: async ( privkey, chan_id, preimage ) => {
                    //in Part Four we reveal our preimage to the server, hoping he responds with off-chain resolution data; if we get it, we resolve the htlc and show the user a success message

                    //prepare the necessary variables
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    showModal( `<p>resolving htlc</p>` );

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_user_part_one",
                        msg_value: {preimage, chan_id},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    //TODO: if the server does not reply in a few seconds, force close
                    //get the next message from the server
                    var message_identifier = "resolve_htlc_to_user_part_two";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    delete json.msg_value[ "message_identifier" ];
                    var new_state_info = json.msg_value;

                    //find the to-be-resolved htlc
                    var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    var index_of_pending_htlc = -1;
                    var amnt_of_pending_htlc = null;
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    extra_outputs = latest_state.extra_outputs;
                    extra_outputs.every( ( htlc, index ) => {
                        if ( htlc.pmthash !== pmthash ) return true;
                        if ( am_alice && htlc.sender === "alice" ) return true;
                        if ( !am_alice && htlc.sender === "bob" ) return true;
                        index_of_pending_htlc = index;
                        amnt_of_pending_htlc = htlc.amnt;
                    });

                    //create a extra_outputs array without that htlc
                    var new_extra_outputs = JSON.parse( JSON.stringify( extra_outputs ) );
                    var htlc_to_remove = JSON.parse( JSON.stringify( extra_outputs[ index_of_pending_htlc ] ) );
                    new_extra_outputs.splice( index_of_pending_htlc, 1 );

                    //create and sign a tx1 and tx2 based on that extra_outputs array, and with the value of the htlc added to your side of the channel, and add the new state to your ch_states array
                    var amnt = amnt_of_pending_htlc;
                    //TODO: force close if the error below is thrown
                    if ( new_state_info.amnt !== amnt ) return console.log( 'error, your counterparty tried to cheat you by resolving an htlc for a wrong amount' );
                    var new_state_is_valid = await hedgehog.receive( new_state_info, new_extra_outputs );
                    //TODO: force close if the error below is thrown
                    if ( !new_state_is_valid ) return console.log( 'error, your counterparty tried to cheat you by refusing to resolve an htlc' );

                    //revoke old state and tell counterparty
                    var state_update = await hedgehog.send( chan_id, 0 );
                    state_update[ "message_identifier" ] = message_identifier;
                    var msg_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_user_part_three",
                        msg_value: state_update,
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    //TODO: if the server does not reply in a few seconds, force close
                    //get counterparty's revocations
                    var message_identifier = "resolve_htlc_to_user_part_four";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from your counterparty
                    var json = JSON.parse( event.content );

                    //validate the new state
                    var s_midstate_rev_preimage = json.msg_value.s_midstate_rev_preimage;
                    var s_recovery_p2_rev_preimage = json.msg_value.s_recovery_p2_rev_preimage;
                    delete json.msg_value[ "s_midstate_rev_preimage" ];
                    delete json.msg_value[ "s_recovery_p2_rev_preimage" ];
                    if ( json.msg_value.amnt !== 0 ) return console.log( 'error, your counterparty tried to cheat by doing a non-blank state update' );
                    var new_state_is_valid = await hedgehog.receive( json.msg_value, new_extra_outputs );
                    //TODO: force close if the error below is thrown
                    if ( !new_state_is_valid ) return console.log( 'error, your counterparty tried to cheat you by refusing to resolve an htlc' );

                    //verify he revoked his recovery-path and the htlc midstate
                    var calculated_midstate_hash = await hedgehog.sha256( hedgehog.hexToBytes( s_midstate_rev_preimage ) );
                    var expected_midstate_hash = htlc_to_remove.s_midstate_revhash;
                    var calculated_recovery_hash = await hedgehog.sha256( hedgehog.hexToBytes( s_recovery_p2_rev_preimage ) );
                    var expected_recovery_hash = htlc_to_remove.s_recovery_p2_revhash;
                    //TODO: force close if the error below is thrown
                    if ( calculated_midstate_hash !== expected_midstate_hash || calculated_recovery_hash !== expected_recovery_hash ) return console.log( 'error, your counterparty tried to cheat you by sending invalid revocation data' );

                    //save the revocation data
                    hedgehog.state[ chan_id ].channel_states[ hedgehog.state[ chan_id ].channel_states.length - 4 ].extra_outputs[ index_of_pending_htlc ].s_midstate_rev_preimage = s_midstate_rev_preimage;
                    hedgehog.state[ chan_id ].channel_states[ hedgehog.state[ chan_id ].channel_states.length - 4 ].extra_outputs[ index_of_pending_htlc ].s_recovery_p2_rev_preimage = s_recovery_p2_rev_preimage;

                    //send your counterparty your reveal-path rev_preimage and your htlc midstate rev_preimage
                    var msg_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_user_part_five",
                        msg_value: {recipients_rev_preimages: htlc_to_remove.recipients_rev_preimages, message_identifier: "resolve_htlc_to_user_part_five"},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    //inform the user what's going on
                    showModal( 'received' );
                },
                listenForComms: async () => {
                    var nostr_privkey = hedgehog_client.nostr_privkey;
                    var nostr_pubkey = super_nostr.getPubkey( nostr_privkey );
                    var nostr_relays = hedgehog_client.relays;
                    var server = hedgehog_client.server;
                    var handleFunction = async message => {
                        var [ type, subId, event ] = JSON.parse( message.data );
                        if ( !event || event === true ) return;
                        try {
                            event.content = await super_nostr.alt_decrypt( nostr_privkey, event.pubkey, event.content );
                            var json = JSON.parse( event.content );
                            console.log( json );
                            if ( json[ "msg_type" ] === "resolve_htlc_to_server_part_one" ) {
                                var preimage = json[ "msg_value" ][ "preimage" ];
                                var chan_id = json[ "msg_value" ][ "chan_id" ];
                                chan_id = "a_" + chan_id.substring( 2 );
                                var privkey = hedgehog_client.nostr_privkey;
                                var pubkey = super_nostr.getPubkey( privkey );
                                var server = hedgehog_client.server;
                                var state = hedgehog.state[ chan_id ];
                                var am_alice = !!state.alices_priv;

                                //find the to-be-resolved htlc
                                var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                                var index_of_pending_htlc = -1;
                                var amnt_of_pending_htlc = null;
                                var extra_outputs = [];
                                var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                                if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                                //TODO: force close if the error below is thrown
                                if ( !extra_outputs.length ) return console.log( 'error, your counterparty sent you a preimage when you have no pending htlcs' );
                                extra_outputs.every( ( htlc, index ) => {
                                    if ( htlc.pmthash !== pmthash ) return true;
                                    if ( am_alice && htlc.sender === "bob" ) return true;
                                    if ( !am_alice && htlc.sender === "alice" ) return true;
                                    index_of_pending_htlc = index;
                                    amnt_of_pending_htlc = htlc.amnt;
                                });

                                //TODO: abort if either of the errors below are thrown
                                if ( index_of_pending_htlc < 0 ) return console.log( 'aborting because the server tried to cheat you by getting you to resolve an htlc that does not exist' );
                                if ( extra_outputs[ index_of_pending_htlc ].sender !== "alice" ) return console.log( 'aborting because the server tried to cheat you by getting you to resolve an htlc you did not create' );

                                hedgehog_client.resolveHtlcToServer( chan_id, preimage );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_value.hasOwnProperty( "more_message_info" ) && json.msg_value.more_message_info === "create_htlc_for_server_part_two" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = json.msg_value.data_for_counterparty;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_value.hasOwnProperty( "more_message_info" ) && json.msg_value.more_message_info === "create_htlc_for_server_part_four" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = json.msg_value.data_for_counterparty;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_value.hasOwnProperty( "more_message_info" ) && json.msg_value.more_message_info === "create_htlc_for_server_part_six" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = json.msg_value.data_for_counterparty;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_type === "resolve_htlc_to_server_part_three" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = event;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_value.hasOwnProperty( "more_message_info" ) && json.msg_value.more_message_info === "initial_send_htlc_message" ) {
                                hedgehog_client.two_way_comms[ "initial_send_htlc_message" ] = event;
                            }
                            hedgehog_client.two_way_comms[ json.msg_type ] = event;
                        }
                        catch ( e ) {
                            console.log( e );
                        }
                    }
                    if ( hedgehog_client.use_rest ) {
                        var loop = async () => {
                            var sig = await nobleSecp256k1.schnorr.sign( "a".repeat( 64 ), nostr_privkey );
                            if ( !hedgehog_client.rest_endpoint ) {
                                await hedgehog_client.waitSomeTime( 1_000 );
                                return loop();
                            }
                            var data = await fetch( hedgehog_client.rest_endpoint + "/read", {
                                method: "POST",
                                headers: {
                                    "Content-type": "application/json"
                                },
                                body: JSON.stringify({sig, pubkey: nostr_pubkey}),
                            });
                            var json = await data.json();
                            json.forEach( item => handleFunction({ data: JSON.stringify( [ null, null, item ] )}) );
                            await hedgehog_client.waitSomeTime( 1_000 );
                            return loop();
                        }
                        loop();
                        return;
                    }
                    var listenFunction = async socket => {
                        var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                        var filter  = {}
                        filter.authors = [ server ];
                        filter.kinds = [ 4 ];
                        filter[ "#p" ] = [ nostr_pubkey ];
                        filter.since = Math.floor( Date.now() / 1000 );
                        var subscription = [ "REQ", subId, filter ];
                        socket.send( JSON.stringify( subscription ) );
                    }
                    await super_nostr.newPermanentConnection( nostr_relays[ 0 ], listenFunction, handleFunction );
                },
                convertNEvent: nevent => {
                    var arr = bech32.bech32.fromWords( bech32.bech32.decode( nevent, 100_000 ).words );
                    var hex = super_nostr.bytesToHex( arr );
                    if ( !hex.startsWith( "0020" ) ) var event_id = hex.substring( hex.length - 64 );
                    else var event_id = hex.substring( 4, 68 );
                    if ( !hex.startsWith( "0020" ) ) hex = hex.substring( 0, hex.length - 64 );
                    else hex = hex.substring( 68 );
                    var relays = [];
                    var loop = () => {
                        if ( hex.startsWith( "01" ) ) {
                            var relay_length = parseInt( hex.substring( 2, 4 ), 16 );
                            relays.push( hedgehog_client.hexToText( hex.substring( 4, 4 + relay_length * 2 ) ) );
                            hex = hex.substring( 4 + relay_length * 2 );
                            loop();
                        }
                    }
                    loop();
                    return [ event_id, relays ];
                },
                hexToText: hex => {
                    var bytes = new Uint8Array( Math.ceil( hex.length / 2 ) );
                    var i; for ( i=0; i<hex.length; i++ ) bytes[ i ] = parseInt( hex.substr( i * 2, 2 ), 16 );
                    var text = new TextDecoder().decode( bytes );
                    return text;
                },
                utxoExists: async ( utxo, network_string ) => {
                    var my_network = network_string.split( "," );
                    var txhex = await chain_client.commander( my_network, "rawtx", utxo.txid );
                    var output = tapscript.Tx.decode( txhex ).vout[ utxo.vout ];
                    if ( Number( output.value ) !== utxo.amnt ) return;
                    if ( tapscript.Address.fromScriptPubKey( output.scriptPubKey, hedgehog.network ) !== utxo.addy ) return;
                    return true;
                    // try {
                    //     return new Promise( async resolve => {
                    //         var { txid, vout, addy, amnt } = utxo;
                    //         var url = `https://${hedgehog_client.explorer}/${hedgehog_client.network}api/tx/${txid}`;
                    //         var data = await fetch( url );
                    //         var json = await data.json();
                    //         json.vout.forEach( vout => {
                    //             if ( vout.scriptpubkey_address === addy && vout.value === amnt ) resolve( true );
                    //         });
                    //         resolve( false );
                    //     });
                    // } catch ( e ) {return false;}
                },
                sendBtn: async () => {
                    var chan_id = hedgehog_client.getChanId();
                    if ( !chan_id ) return alert( 'open a channel first' );
                    if ( hedgehog_client.ln_support ) {
                        var invoice = prompt( `enter an LN invoice` );
                        if ( !invoice ) return;
                        hedgehog_client.sendViaLN( chan_id, invoice );
                    } else {
                        hedgehog_client.sendViaL1( chan_id );
                    }
                },
                send: async ( chan_id, amnt, pmthash, absolute_timelock ) => {
                    var relative_timelock = 2026;
                    var worked = await hedgehog.sendHtlc( chan_id, amnt, relative_timelock, absolute_timelock, pmthash );
                    return !!worked;
                },
                sendViaLN: async ( chan_id, invoice ) => {
                    var pmthash = hedgehog_client.getInvoicePmthash( invoice );
                    var amnt = hedgehog_client.getInvoiceAmount( invoice );
                    var htlc_pending = await hedgehog_client.send( chan_id, amnt, pmthash );
                    if ( !htlc_pending ) return console.log( 'error, no htlc was created' );
                    hedgehog_client.askServerToPayLNInvoice( chan_id, invoice );
                },
                sendViaL1: async ( chan_id, destino, amnt ) => {
                    if ( !destino ) destino = prompt( `enter a bitcoin address you want to send money to` );
                    if ( !destino ) return;
                    if ( !hedgehog.isValidAddress( destino ) ) return alert( 'that is not a valid bitcoin address' );
                    var preimage = hedgehog.getPrivkey();
                    var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    if ( !amnt ) amnt = Number( prompt( `enter the amount you want to send there` ) );
                    if ( !amnt ) return;
                    if ( amnt < 2000 ) return alert( 'the minimum amount is 2000 sats' );
                    //TODO: get swap fee from server
                    var swap_fee = 500;
                    //TODO: get an L1 fee estimate from the mempool
                    var L1_fee = 500;
                    var conf = confirm( `click ok if you don't mind paying ${swap_fee + L1_fee} sats extra in swap fees, or click cancel if you don't want to do this anymore` );
                    if ( !conf ) return;
                    var htlc_amnt = amnt + swap_fee + L1_fee;
                    var htlc_pending = await hedgehog_client.send( chan_id, htlc_amnt, pmthash );
                    if ( !htlc_pending ) return console.log( 'error, no htlc was created' );
                    var senders_privkey = super_nostr.getPrivkey();
                    hedgehog_client.askServerToPayL1Address( chan_id, pmthash, senders_privkey );

                    //get the htlc address
                    var alice_wants_htlc = true;
                    var relative_timelock = 10;
                    var senders_pubkey = hedgehog.getPubkey( senders_privkey );
                    var counterpartys_pubkey = hedgehog_client.server;
                    var htlc_scripts = hedgehog.getStandardHTLCScripts( senders_pubkey, counterpartys_pubkey, pmthash, relative_timelock );
                    var [ htlc_addy, htlc_tree, htlc_cblock ] = hedgehog.getAddressData( htlc_scripts, 0 );

                    //check if the htlc got funded
                    var network_string = hedgehog_client.network_string;
                    var my_network = network_string.split( "," );
                    var loop = async () => {
                        console.log( `checking if htlc got funded: ${htlc_addy}` );
                        var utxos = await chain_client.commander( my_network, "utxos", htlc_addy );
                        var sum_of_utxos = 0;
                        utxos.forEach( utxo => sum_of_utxos = sum_of_utxos + utxo.value );
                        if ( sum_of_utxos >= amnt + L1_fee ) return utxos;
                        await super_nostr.waitSomeSeconds( 1 );
                        return loop();
                    }
                    //TODO: force close if the htlc is not funded in a timely manner and you don't get some sort of error message from the server
                    var htlc_addy_got_funded = await loop();

                    //ask the user if they want to wait for a confirmation
                    var wait_for_conf = confirm( `the server funded a swap address and wants you to resolve your htlc, but, unless you trust the server, it is not safe to do so til their tx confirms, otherwise the server can doublespend. Click ok to wait for a confirmation or click cancel if you trust the server enough to resolve the htlc now` );
                    if ( wait_for_conf ) {
                        //TODO: automate waiting for confirmations
                        var htlc_utxos = htlc_addy_got_funded;
                        var msg = `click ok when these transactions all confirm:`;
                        htlc_utxos.forEach( utxo => msg += `\n${utxo.txid}` );
                        alert( msg );
                    }

                    //prepare the sweep tx
                    var utxos_to_sweep = htlc_addy_got_funded;
                    var sum_of_utxos = 0;
                    var vin = [];
                    utxos_to_sweep.forEach( utxo => {
                        sum_of_utxos = sum_of_utxos + utxo.value;
                        vin.push({
                            txid: utxo.txid,
                            vout: utxo.vout,
                            prevout: {
                                value: utxo.value,
                                scriptPubKey: tapscript.Address.toScriptPubKey( htlc_addy ),
                            },
                        });
                    });
                    var sweep_tx = tapscript.Tx.create({
                        vin,
                        vout: [{
                            value: sum_of_utxos - L1_fee,
                            scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                        }],
                    });

                    //sign the sweep tx
                    vin.forEach( ( _, index ) => {
                        var sig = tapscript.Signer.taproot.sign( senders_privkey, sweep_tx, index, {extension: htlc_tree[ 0 ] }).hex;
                        sweep_tx.vin[ index ].witness = [ sig, preimage, htlc_scripts[ 0 ], htlc_cblock ];
                    });

                    //broadcast the sweep tx
                    var txhex = tapscript.Tx.encode( sweep_tx ).hex;
                    console.log( 'broadcast this:', txhex );
                    console.log( `you can broadcast the tx like this:` );
                    console.log( `var my_network = "${network_string}".split( "," );chain_client.commander( my_network, "broadcast", "${txhex}" )` );
                },
                askServerToPayLNInvoice: async ( chan_id, invoice ) => {
                    var privkey = super_nostr.getPrivkey();
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;

                    //encrypt the channel id
                    var encryption_privkey = super_nostr.getPrivkey();
                    var encryption_pubkey = super_nostr.getPubkey( encryption_privkey );
                    var encrypted_chan_id = await super_nostr.alt_encrypt( encryption_privkey, server, chan_id );

                    //ask server to pay LN invoice
                    var message_for_counterparty = JSON.stringify({
                        msg_type: "pay_ln_invoice_for_user",
                        msg_value: {encrypted_chan_id, invoice, encryption_pubkey},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_counterparty );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                askServerToPayL1Address: async ( chan_id, pmthash, privkey ) => {
                    var senders_pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;

                    //encrypt the channel id
                    var encryption_privkey = super_nostr.getPrivkey();
                    var encryption_pubkey = super_nostr.getPubkey( encryption_privkey );
                    var encrypted_chan_id = await super_nostr.alt_encrypt( encryption_privkey, server, chan_id );

                    //ask server to pay L1 address
                    var message_for_counterparty = JSON.stringify({
                        msg_type: "pay_l1_address_for_user",
                        msg_value: {encrypted_chan_id, pmthash, encryption_pubkey, senders_pubkey},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_counterparty );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                resolveHtlcToServer: async ( chan_id, preimage ) => {
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //find the relevant htlc
                    var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    var index_of_pending_htlc = -1;
                    var amnt_of_pending_htlc = null;
                    var extra_outputs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                    extra_outputs.every( ( htlc, index ) => {
                        if ( htlc.pmthash !== pmthash ) return true;
                        if ( am_alice && htlc.sender === "bob" ) return true;
                        if ( !am_alice && htlc.sender === "alice" ) return true;
                        index_of_pending_htlc = index;
                        amnt_of_pending_htlc = htlc.amnt;
                    });

                    //create a extra_outputs array without that htlc
                    var new_extra_outputs = JSON.parse( JSON.stringify( extra_outputs ) );
                    var htlc_to_remove = JSON.parse( JSON.stringify( extra_outputs[ index_of_pending_htlc ] ) );
                    new_extra_outputs.splice( index_of_pending_htlc, 1 );

                    //create and sign a tx1 and tx2 based on that extra_outputs array, and with the value of the htlc added to your counterparty's side of the channel, and add the new state to your ch_states array
                    var amnt = amnt_of_pending_htlc;
                    console.log( 'my revocation preimages:', state.alices_revocation_preimages, 'my revocation hashes:', state.alices_revocation_hashes );
                    var object_for_counterparty = await hedgehog.send( chan_id, amnt, new_extra_outputs );
                    object_for_counterparty[ "pmt_preimage" ] = preimage;

                    //get your counterparty to sign the new state
                    var message_identifier = super_nostr.getPrivkey();
                    var message_for_counterparty = JSON.stringify({
                        msg_type: "resolve_htlc_to_server_part_two",
                        msg_value: {...object_for_counterparty, message_identifier},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_counterparty );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    //TODO: if your counterparty does not reply in a few seconds, force close
                    //get the next message from your counterparty
                    hedgehog_client.two_way_comms[ message_identifier ] = "waiting_for_info";
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) || ( hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) && hedgehog_client.two_way_comms[ message_identifier ] === "waiting_for_info" ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from your counterparty
                    var json = JSON.parse( event.content );
                    delete json.msg_value[ "message_identifier" ];

                    //validate the new state
                    if ( json.msg_value.amnt !== 0 ) return console.log( 'error, your counterparty tried to cheat by doing a non-blank state update' );
                    var new_state_is_valid = await hedgehog.receive( json.msg_value, new_extra_outputs );
                    //TODO: force close if the error below is thrown
                    if ( !new_state_is_valid ) return console.log( 'error, your counterparty tried to cheat you by refusing to resolve an htlc' );

                    //revoke all prior states
                    //send your counterparty the following items: your recovery-path rev_preimage, your htlc midstate rev_preimage, and a new blank state update
                    var state_update = await hedgehog.send( chan_id, 0 );
                    state_update[ "message_identifier" ] = "resolve_htlc_to_server_part_four";
                    var message_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_server_part_four",
                        msg_value: {...state_update, s_midstate_rev_preimage: htlc_to_remove.s_midstate_rev_preimage, s_recovery_p2_rev_preimage: htlc_to_remove.s_recovery_p2_rev_preimage},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    //TODO: if your counterparty does not reply in a few seconds, force close
                    //ensure your counterparty sent you their reveal-path revocation preimage, their htlc midstate rev_preimage
                    var message_identifier = "resolve_htlc_to_server_part_five";
                    hedgehog_client.two_way_comms[ message_identifier ] = "waiting_for_info";
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) || ( hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) && hedgehog_client.two_way_comms[ message_identifier ] === "waiting_for_info" ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from your counterparty
                    var json = JSON.parse( event.content );
                    delete json.msg_value[ "message_identifier" ];

                    //verify he revoked his recovery-path and the htlc midstate
                    var recipients_rev_preimages = json.msg_value.recipients_rev_preimages;
                    var calculated_midstate_hash = await hedgehog.sha256( hedgehog.hexToBytes( recipients_rev_preimages[ 0 ] ) );
                    var expected_midstate_hash = htlc_to_remove.recipients_revhashes[ 0 ];
                    var calculated_reveal_hash = await hedgehog.sha256( hedgehog.hexToBytes( recipients_rev_preimages[ 1 ] ) );
                    var expected_reveal_hash = htlc_to_remove.recipients_revhashes[ 1 ];
                    //TODO: force close if the error below is thrown
                    if ( calculated_midstate_hash !== expected_midstate_hash || calculated_reveal_hash !== expected_reveal_hash ) return console.log( 'error, your counterparty tried to cheat you by sending invalid revocation data' );

                    //save the revocation data
                    state.channel_states[ state.channel_states.length - 4 ].extra_outputs[ index_of_pending_htlc ].recipients_rev_preimages = recipients_rev_preimages;

                    console.log( 'htlc resolved' );
                    return;
                },
                setUpComms: async () => {
                    hedgehog.intercom = async data_for_counterparty => {
                        var chan_id = data_for_counterparty.chan_id;
                        var message_identifier = hedgehog.getPrivkey();
                        if ( data_for_counterparty.hasOwnProperty( "pmthash" ) && data_for_counterparty.hasOwnProperty( "s_midstate_revhash" ) ) {
                            var more_message_info = "create_htlc_for_server_part_one";
                            data_for_counterparty[ "message_identifier" ] = message_identifier;
                            data_for_counterparty[ "more_message_info" ] = more_message_info;
                            var msg_for_counterparty = JSON.stringify({
                                msg_type: "two_way_comms",
                                msg_value: data_for_counterparty,
                            });
                        }
                        if ( data_for_counterparty.hasOwnProperty( "amnt" ) && data_for_counterparty.hasOwnProperty( "relative_timelock" ) && data_for_counterparty.hasOwnProperty( "sig_on_recipients_reveal_p1_tx" ) && data_for_counterparty.hasOwnProperty( "sig_on_senders_reveal_p1_tx" ) && data_for_counterparty.hasOwnProperty( "pmthash" ) && data_for_counterparty.hasOwnProperty( "s_recovery_p2_revhash" ) ) {
                            var more_message_info = "create_htlc_for_server_part_three";
                            data_for_counterparty[ "message_identifier" ] = message_identifier;
                            data_for_counterparty[ "more_message_info" ] = more_message_info;
                            var msg_for_counterparty = JSON.stringify({
                                msg_type: "two_way_comms",
                                msg_value: data_for_counterparty,
                            });
                        }
                        if ( data_for_counterparty.hasOwnProperty( "to_midstate_sig" ) && data_for_counterparty.hasOwnProperty( "finalizer_sig" ) && data_for_counterparty.hasOwnProperty( "revocation_hash" ) && data_for_counterparty.hasOwnProperty( "pmthash" ) && data_for_counterparty.hasOwnProperty( "revocation_of_previous_state" ) ) {
                            var more_message_info = "create_htlc_for_server_part_five";
                            data_for_counterparty[ "message_identifier" ] = message_identifier;
                            data_for_counterparty[ "more_message_info" ] = more_message_info;
                            var msg_for_counterparty = JSON.stringify({
                                msg_type: "two_way_comms",
                                msg_value: data_for_counterparty,
                            });
                        }
                        var privkey = hedgehog_client.nostr_privkey;
                        var pubkey = super_nostr.getPubkey( privkey );
                        var counterpartys_pubkey = hedgehog_client.server;
                        var emsg = await super_nostr.alt_encrypt( privkey, counterpartys_pubkey, msg_for_counterparty );
                        var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", counterpartys_pubkey ] ] );
                        hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                        var loop = async () => {
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var reply = await loop();
                        return reply;
                    }
                },
                waitSomeTime: num => new Promise( resolve => setTimeout( resolve, num ) ),
                getInvoicePmthash: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var i; for ( i=0; i<decoded[ "tags" ].length; i++ ) {
                        if ( decoded[ "tags" ][ i ][ "tagName" ] === "payment_hash" ) return decoded[ "tags" ][ i ][ "data" ].toString();
                    }
                },
                getInvoiceAmount: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var amount = Math.floor( decoded[ "millisatoshis" ] / 1000 ).toString();
                    return Number( amount );
                },
                convertPubkeyAndRelaysToNprofile: ( prefix, pubkey, relays ) => {
                    var relays_str = "";
                    relays.forEach( relay => {
                        var relay_str = hedgehog_client.textToHex( relay );
                        var len = ( relay_str.length / 2 ).toString( 16 );
                        if ( len.length % 2 ) len = "0" + len;
                        relays_str = relays_str + "01" + len + relay_str;
                    });
                    var hex = relays_str + "0020" + pubkey;
                    var bytes = super_nostr.hexToBytes( hex );
                    var nevent = bech32.bech32.encode( prefix, bech32.bech32.toWords( bytes ), 100_000 );
                    return nevent;
                },
                textToHex: text => {
                    var encoded = new TextEncoder().encode( text );
                    return Array.from( encoded )
                        .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                        .join( "" );
                },
                showChecks: () => hedgehog_client.showPage( "checks_page" ),
                newCheck: () => {
                    var new_check_html = `
                        <p style="font-weight: bold;">New cheque</p>
                        <p>Enter a label</p>
                        <p><input class="new_check_label" placeholder="Money for rent"></p>
                        <p>Enter an amount in sats</p>
                        <p><input class="new_check_amount" type="number" min="2000" step="1" placeholder="2000"></p>
                        <p>Enter a date and time when you want this check to be cashable</p>
                        <p><input class="new_check_timelock" type="datetime-local"></p>
                        <p class="channel_fee_info"><input type="checkbox" class="include_channel_fee" id="include_channel_fee"> <label for="include_channel_fee">Include channel fee</label>
                        <p>If a channel fee is included, an extra payment of 1000 sats will be added to your cheque to pay for a new channel for your recipient, if necessary. The channel fee has to be a separate payment to reduce trust in the server: the channel fee goes to the server, not the recipient, so the server can steal it. But he promises not to, and in fact he promises to refund the unused portion of the channel fee. (If it sounds contradictory to say "[we] reduce trust in the server" AND "the server can steal it," the reason is, with this setup the server can only steal a small fee payment, whereas if the cheque amount *included* the server fee, the server could steal the whole cheque amount.)</p>
                        <p><button class="submit_new_check">Submit</button></p>
                    `;
                    showModal( new_check_html );
                    var now = new Date();
                    now.setMinutes( now.getMinutes() - now.getTimezoneOffset() );
                    var current_time = now.toISOString().slice( 0, 16 );
                    $( '.new_check_timelock' ).value = current_time;
                    $( '.submit_new_check' ).onclick = async () => {
                        var chan_id = hedgehog_client.getChanId();
                        if ( !chan_id ) return alert( 'open a channel first' );
                        var check_label = $( '.new_check_label' ).value;
                        var check_amount = Number( $( '.new_check_amount' ).value );
                        if ( !check_label ) return alert( 'check must be labeled, try again' );
                        if ( String( check_amount ).includes( "," ) || String( check_amount ).includes( "." ) ) return alert( 'check amount must be a number with no commas or periods, try again' );
                        if ( check_amount < 2000 ) return alert( 'check amount must be 2000 or greater' );
                        var balance = hedgehog_client.getBalance( chan_id )[ 0 ] - hedgehog_client.getBalance( chan_id )[ 1 ];
                        var sum_needed = check_amount;
                        //TODO: instead of hard coding a channel fee of 1000 sats, use mempool data to estimate it and add a 10% buffer
                        var channel_fee = 1000;
                        var include_channel_fee = $( '.include_channel_fee' ).checked;
                        if ( include_channel_fee ) sum_needed = sum_needed + channel_fee;
                        if ( sum_needed > balance ) return alert( `your balance is not high enough for this check, you need an extra ${balance - sum_needed} sats` );
                        var check_absolute_timelock = Math.floor( new Date( $( '.new_check_timelock' ).value ).getTime() / 1000 );
                        showModal( '<p>Preparing check...</p>' );
                        var check_privkey = super_nostr.getPrivkey();
                        var check_pubkey = super_nostr.getPubkey( check_privkey );
                        var check_relays = hedgehog_client.relays;
                        var check_id = hedgehog_client.convertPubkeyAndRelaysToNprofile( "hh_check_", check_privkey, check_relays );
                        var check_preimage = super_nostr.getPrivkey();
                        var check_encryption_privkey = super_nostr.getPrivkey();
                        var server = hedgehog_client.server;
                        var check_encrypted_chan_id = await super_nostr.alt_encrypt( check_encryption_privkey, server, chan_id );
                        var check_encryption_pubkey = super_nostr.getPubkey( check_encryption_privkey );
                        var check_server_id = hedgehog_client.textToHex( JSON.stringify({
                            connection_type: "nostr",
                            connection_string: hedgehog_client.convertPubkeyAndRelaysToNprofile( "nprofile", server, hedgehog_client.relays ),
                            network_string: hedgehog_client.network_string,
                            ln_support: hedgehog_client.ln_support,
                            use_rest: hedgehog_client.use_rest,
                            rest_endpoint: hedgehog_client.use_rest ? hedgehog_client.rest_endpoint : undefined,
                            subscription_info: JSON.parse( hedgehog_client.hexToText( hedgehog_client.server_id ) ).subscription_info ? JSON.parse( hedgehog_client.hexToText( hedgehog_client.server_id ) ).subscription_info : undefined,
                        }) );
                        var channel_fee_data = {}
                        var encrypted_channel_fee_data = null;
                        if ( include_channel_fee ) {
                            channel_fee_data.fee_amount = channel_fee;
                            channel_fee_data.fee_preimage = super_nostr.getPrivkey();
                            channel_fee_data.fee_absolute_timelock = 0;
                            encrypted_channel_fee_data = await super_nostr.alt_encrypt( check_encryption_privkey, server, JSON.stringify( channel_fee_data ) );
                        }
                        //create an encrypted kind 16109 message on nostr with the following content: the htlc preimage, the amount, the blockheight of an absolute timelock (can be 0), the server_id, an encrypted channel id, and similar info a second time for a “channel fee” payment (optional)
                        var data_to_put_on_nostr = JSON.stringify({
                            check_amount,
                            check_preimage,
                            check_absolute_timelock,
                            check_server_id,
                            check_encrypted_chan_id,
                            check_encryption_pubkey,
                            encrypted_channel_fee_data,
                        });
                        var encrypted_data = await super_nostr.alt_encrypt( check_privkey, check_pubkey, data_to_put_on_nostr );
                        var event = await super_nostr.prepEvent( check_privkey, encrypted_data, 16109 );
                        // var worked = await super_nostr.alt_sendEvent( event, hedgehog_client.relays[ 0 ] );
                        super_nostr.sendEvent( event, hedgehog_client.relays[ 0 ] );
                        var check_data = {
                            data_to_put_on_nostr: JSON.parse( data_to_put_on_nostr ),
                            check_amount,
                            check_label,
                            check_status: "ready to cash",
                            channel_fee: include_channel_fee ? channel_fee : 0,
                            fee_preimage: include_channel_fee ? channel_fee_data.fee_preimage : null,
                        }
                        //use the check_preimage and, if necessary, the fee_preimage to create one or two pending htlcs
                        var check_pmthash = await hedgehog.sha256( hedgehog.hexToBytes( check_preimage ) );
                        await hedgehog_client.send( chan_id, check_amount, check_pmthash, check_absolute_timelock );
                        if ( include_channel_fee ) {
                            var fee_pmthash = await hedgehog.sha256( hedgehog.hexToBytes( channel_fee_data.fee_preimage ) );
                            await hedgehog_client.send( chan_id, channel_fee_data.fee_amount, fee_pmthash );
                        }
                        hedgehog_client.funded_checks[ check_id ] = check_data;
                        modalVanish();
                    }
                },
                handleChecksLoop: async () => {
                    var chan_id = hedgehog_client.getChanId();
                    if ( !chan_id ) {
                        await hedgehog_client.waitSomeTime( 100 );
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    var state = hedgehog.state[ chan_id ];
                    var num_of_checks = hedgehog_client.num_of_checks;
                    var checks = Object.keys( hedgehog_client.funded_checks );
                    if ( !checks.length ) {
                        $( '.pending_checks' ).innerHTML = `[None]`;
                        await hedgehog_client.waitSomeTime( 100 );
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    hedgehog_client.num_of_checks = checks.length;
                    var all_html = document.createElement( "div" );
                    var state_changed = false;
                    var i; for ( i=0; i<checks.length; i++ ) {
                        var check_id = checks[ i ];
                        var check = hedgehog_client.funded_checks[ check_id ];
                        var url = `${window.location.protocol}//${window.location.hostname}/${window.location.pathname}#check=${check_id}`;
                        var check_amount = check.channel_fee ? String( check.check_amount ) + "&nbsp;+&nbsp;" + String( check.channel_fee ) : check.check_amount;
                        if ( check.channel_fee ) {
                            //check if the fee htlc is still pending; if not, remove it from the interface
                            var fee_preimage = check.fee_preimage;
                            var fee_pmthash = await hedgehog.sha256( hedgehog.hexToBytes( fee_preimage ) );
                            var extra_outputs = [];
                            var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                            if ( latest_state && latest_state.hasOwnProperty( "extra_outputs" ) ) extra_outputs = latest_state.extra_outputs;
                            var fee_htlc_still_exists = false;
                            extra_outputs.every( output => {
                                if ( output.pmthash !== fee_pmthash ) return true;
                                fee_htlc_still_exists = true;
                            });
                            if ( !fee_htlc_still_exists ) check_amount = check.check_amount;
                        }
                        var check_state = JSON.stringify({
                            label: check.check_label,
                            amount: check_amount,
                            status: check.check_status,
                            url,
                        });
                        var prev_state = $( `.${check_id}` ) ? $( `.${check_id}` ).getAttribute( "data-check_state" ) : null;
                        if ( check_state !== prev_state ) state_changed = true;
                        var check_timelock = new Date( check.data_to_put_on_nostr.check_absolute_timelock * 1000 );
                        check_timelock.setMinutes( check_timelock.getMinutes() - check_timelock.getTimezoneOffset() );
                        var check_tl_date = check_timelock.toLocaleDateString( "en-ca" );
                        var check_tl_time = check_timelock.toLocaleTimeString();
                        var now = Math.floor( Date.now() / 1000 );
                        if ( now < check.data_to_put_on_nostr.check_absolute_timelock ) check_status = "waiting for timelock";
                        else check_status = check.check_status;
                        var check_html = `
                            <div>Label: <span class="check_label">${check.check_label}</span></div>
                            <div>Amount: <span class="check_amount">${check_amount}</span></div>
                            <div>Timelock date: <span class="check_tl_date">${check_tl_date}</span></div>
                            <div>Timelock time: <span class="check_tl_time">${check_tl_time}</span></div>
                            <div>Status: <span class="check_status">${check_status}</span></div>
                            <div><button class="check_btn void_this_check">Void this check</button></div>
                            <div><button class="check_btn view_check_qr">View qr code</button></div>
                            <div><button class="check_btn view_payment_string">View payment string</button></div>
                            <div class="check_qr_code hidden"></div>
                            <div class="check_payment_string hidden">${url}</div>
                        `;
                        var div = document.createElement( "div" );
                        div.classList.add( "check" );
                        div.classList.add( check_id );
                        div.setAttribute( "data-check_state", check_state );
                        div.innerHTML = check_html;
                        div.getElementsByClassName( "void_this_check" )[ 0 ].onclick = () => {
                            showModal( `This button doesn't do anything yet` );
                        }
                        div.getElementsByClassName( "view_check_qr" )[ 0 ].onclick = () => {
                            var url = $( `.${check_id} .check_payment_string` ).innerText;
                            var qr = hedgehog_client.createQR( url.toUpperCase() );
                            var item = $( `.${check_id} .check_qr_code` );
                            item.append( qr );
                            if ( item.classList.contains( "hidden" ) ) item.classList.remove( "hidden" );
                            else item.classList.add( "hidden" );
                        }
                        div.getElementsByClassName( "view_payment_string" )[ 0 ].onclick = () => {
                            var item = $( `.${check_id} .check_payment_string` );
                            if ( item.classList.contains( "hidden" ) ) item.classList.remove( "hidden" );
                            else item.classList.add( "hidden" );
                        }
                        all_html.append( div );
                    }
                    if ( state_changed ) {
                        $( '.pending_checks' ).innerHTML = ``;
                        $( '.pending_checks' ).append( all_html );
                    }
                    await hedgehog_client.waitSomeTime( 100 );
                    hedgehog_client.handleChecksLoop();
                },
                getChanId: () => Object.keys( hedgehog.state )[ 0 ],
                createQR: content => {
                    var dataUriPngImage = document.createElement( "img" ),
                    s = QRCode.generatePNG( content, {
                        ecclevel: "M",
                        format: "html",
                        fillcolor: "#FFFFFF",
                        textcolor: "#000000",
                        margin: 4,
                        modulesize: 8,
                    });
                    dataUriPngImage.src = s;
                    dataUriPngImage.className = "qr_code";
                    dataUriPngImage.style.width = "100%";
                    return dataUriPngImage;
                },
                checkPage: async skip_show => {
                    //show check page
                    $( '.check_info' ).innerHTML = 'loading cheque info...';
                    hedgehog_client.showPage( "check_page" );

                    //prepare requisite variables
                    var check_id = url_params.check;
                    var [ check_privkey, check_relays ] = hedgehog_client.convertNEvent( check_id );
                    var privkey = check_privkey;
                    var check_pubkey = super_nostr.getPubkey( check_privkey );
                    var check_relay = check_relays[ 0 ];
                    var ids = null;
                    var authors = [ check_pubkey ];
                    var kinds = [ 16109 ];
                    var until = null;
                    var since = null;
                    var limit = 1;
                    var events = await super_nostr.getEvents( check_relay, ids, authors, kinds, until, since, limit );
                    if ( !events.length ) $( '.check_info' ).innerHTML = `Sorry, someone sent you an uncashable check.`;
                    var check = events[ 0 ];
                    check.content = await super_nostr.alt_decrypt( check_privkey, check_pubkey, check.content );
                    var json = JSON.parse( check.content );
                    url_params.server_id = json.check_server_id;
                    hedgehog_client.server_id = json.check_server_id;
                    var { check_amount: check_amnt, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id: encrypted_chan_id, check_encryption_pubkey: encryption_pubkey, encrypted_channel_fee_data } = json;
                    var check_pmthash = await hedgehog.sha256( hedgehog.hexToBytes( check_preimage ) );

                    //listen on nostr
                    var nostr_privkey = check_privkey;
                    var nostr_pubkey = check_pubkey;
                    var check_server_id = json.check_server_id;
                    var server_info = JSON.parse( hedgehog_client.hexToText( check_server_id ) );
                    var { connection_string, connection_type, ln_support, use_rest, rest_endpoint } = server_info;
                    if ( hedgehog_client.ln_support === "unknown" ) hedgehog_client.ln_support = ln_support;
                    if ( hedgehog_client.use_rest === "unknown" ) hedgehog_client.use_rest = use_rest;
                    if ( use_rest ) hedgehog_client.rest_endpoint = rest_endpoint;
                    if ( connection_type === "nostr" ) var [ server, servers_relays ] = hedgehog_client.convertNEvent( connection_string );
                    var handleFunction = async message => {
                        var [ type, subId, event ] = JSON.parse( message.data );
                        if ( !event || event === true ) return;
                        try {
                            event.content = await super_nostr.alt_decrypt( nostr_privkey, event.pubkey, event.content );
                            var json = JSON.parse( event.content );
                            if ( json[ "msg_type" ] === "get_check_status_reply" ) {
                                if ( json.msg_value === "irredeemable" ) $( '.check_info' ).innerHTML = `Sorry, someone sent you an uncashable check.`;
                                if ( json.msg_value.startsWith( "irredeemable until" ) ) {
                                    var unlock_timestamp = Number( json.msg_value.substring( 19 ) );
                                    var check_timelock = new Date( unlock_timestamp * 1000 );
                                    check_timelock.setMinutes( check_timelock.getMinutes() - check_timelock.getTimezoneOffset() );
                                    var check_tl_date = check_timelock.toLocaleDateString( "en-ca" );
                                    var check_tl_time = check_timelock.toLocaleTimeString();
                                    $( '.check_info' ).innerHTML = `This check is uncashable until ${check_tl_date} at ${check_tl_time}.`;
                                }
                                if ( json.msg_value === "redeemable" ) {
                                    if ( !skip_show ) {
                                        var div = document.createElement( "div" );
                                        div.innerHTML = `<p>The check is worth ${check_amnt} sats. How do you want to cash it?</p>`;
                                        var ol = document.createElement( "ol" );
                                        ol.innerHTML = `
                                            <li><span class="new_hedgehog_channel bluelink">Click here</a> to set up a new hedgehog channel and receive it into there</li>
                                            <li><span class="have_hedgehog_channel bluelink">Click here</a> if you already have a hedgehog channel and want to receive it into there</li>
                                            <li><span class="check_to_l1 bluelink">Click here</a> to receive the money into an L1 bitcoin address</li>
                                        `;
                                        if ( hedgehog_client.ln_support ) {
                                            ol.innerHTML = ol.innerHTML + `
                                                <li><span class="check_to_ln bluelink">Click here</a> to receive the money into a compatible lightning wallet</li>
                                            `;
                                        }
                                        div.append( ol );
                                        $( '.check_info' ).innerHTML = ``;
                                        $( '.check_info' ).append( div );
                                        $( '.new_hedgehog_channel' ).onclick = () => {
                                            var check_hex = hedgehog_client.textToHex( check.content );
                                            hedgehog_client.onboard( check_server_id, check_hex );
                                        }
                                        $( '.have_hedgehog_channel' ).onclick = () => {
                                            var chan_id = hedgehog_client.getChanId();
                                            var check_hex = hedgehog_client.textToHex( check.content );
                                            var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                                            var { check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey } = check_data;
                                            hedgehog_client.cashCheck( chan_id, check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey );
                                        }
                                        $( '.check_to_l1' ).onclick = async () => {
                                            destino = prompt( `enter a bitcoin address you want to send money to` );
                                            if ( !destino ) return;
                                            if ( !hedgehog.isValidAddress( destino ) ) return alert( 'that is not a valid bitcoin address' );
                                            var check_hex = hedgehog_client.textToHex( check.content );
                                            var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                                            var { check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey } = check_data;

                                            //ensure user is okay with swap fee
                                            //TODO: get swap fee from server
                                            var swap_fee = 500;
                                            //TODO: get an L1 fee estimate from the mempool
                                            var L1_fee = 500;
                                            var amnt = check_amount - swap_fee - L1_fee;
                                            var conf = confirm( `this check is worth ${check_amount} sats, but due to needing to pay ${swap_fee + L1_fee} sats in swap fees, you will only get ${check_amount - swap_fee - L1_fee} sats. Click ok if are okay with that or click cancel if you don't want to do this anymore` );
                                            if ( !conf ) return;

                                            //prepare to talk to the server
                                            var server_info = JSON.parse( hedgehog_client.hexToText( check_server_id ) );
                                            if ( server_info.connection_type === "nostr" ) {
                                                //prepare the swap
                                                var privkey = super_nostr.getPrivkey();
                                                var pubkey = super_nostr.getPubkey( privkey );
                                                var { connection_string, network_string } = server_info;
                                                var [ server, servers_relays ] = hedgehog_client.convertNEvent( connection_string );
                                                var preimage = check_preimage;
                                                var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );

                                                //ask server to pay L1 address
                                                var senders_privkey = hedgehog.getPrivkey();
                                                var senders_pubkey = hedgehog.getPubkey( senders_privkey );
                                                var message_for_counterparty = JSON.stringify({
                                                    msg_type: "pay_l1_address_for_user",
                                                    msg_value: {encrypted_chan_id: check_encrypted_chan_id, pmthash, encryption_pubkey: check_encryption_pubkey, senders_pubkey},
                                                });
                                                var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_counterparty );
                                                var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                                                hedgehog_client.sendEvent( event, servers_relays[ 0 ] );

                                                //get the htlc address
                                                var alice_wants_htlc = true;
                                                var relative_timelock = 10;
                                                var senders_pubkey = hedgehog.getPubkey( senders_privkey );
                                                var counterpartys_pubkey = server;
                                                var htlc_scripts = hedgehog.getStandardHTLCScripts( senders_pubkey, counterpartys_pubkey, pmthash, relative_timelock );
                                                var [ htlc_addy, htlc_tree, htlc_cblock ] = hedgehog.getAddressData( htlc_scripts, 0 );

                                                //check if the htlc got funded
                                                var my_network = network_string.split( "," );
                                                var loop = async () => {
                                                    console.log( `checking if htlc got funded: ${htlc_addy}` );
                                                    var utxos = await chain_client.commander( my_network, "utxos", htlc_addy );
                                                    var sum_of_utxos = 0;
                                                    utxos.forEach( utxo => sum_of_utxos = sum_of_utxos + utxo.value );
                                                    if ( sum_of_utxos >= amnt + L1_fee ) return utxos;
                                                    await super_nostr.waitSomeSeconds( 1 );
                                                    return loop();
                                                }
                                                //TODO: force close if the htlc is not funded in a timely manner and you don't get some sort of error message from the server
                                                var htlc_addy_got_funded = await loop();

                                                //ask the user if they want to wait for a confirmation
                                                var wait_for_conf = confirm( `the server funded a swap address and wants you to resolve your htlc, but, unless you trust the server, it is not safe to do so til their tx confirms, otherwise the server can doublespend. Click ok to wait for a confirmation or click cancel if you trust the server enough to resolve the htlc now` );
                                                if ( wait_for_conf ) {
                                                    //TODO: automate waiting for confirmations
                                                    var htlc_utxos = htlc_addy_got_funded;
                                                    var msg = `click ok when these transactions all confirm:`;
                                                    htlc_utxos.forEach( utxo => msg += `\n${utxo.txid}` );
                                                    alert( msg );
                                                }

                                                //prepare the sweep tx
                                                var utxos_to_sweep = htlc_addy_got_funded;
                                                var sum_of_utxos = 0;
                                                var vin = [];
                                                utxos_to_sweep.forEach( utxo => {
                                                    sum_of_utxos = sum_of_utxos + utxo.value;
                                                    vin.push({
                                                        txid: utxo.txid,
                                                        vout: utxo.vout,
                                                        prevout: {
                                                            value: utxo.value,
                                                            scriptPubKey: tapscript.Address.toScriptPubKey( htlc_addy ),
                                                        },
                                                    });
                                                });
                                                var sweep_tx = tapscript.Tx.create({
                                                    vin,
                                                    vout: [{
                                                        value: sum_of_utxos - L1_fee,
                                                        scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                                                    }],
                                                });

                                                //sign the sweep tx
                                                vin.forEach( ( _, index ) => {
                                                    var sig = tapscript.Signer.taproot.sign( senders_privkey, sweep_tx, index, {extension: htlc_tree[ 0 ] }).hex;
                                                    sweep_tx.vin[ index ].witness = [ sig, preimage, htlc_scripts[ 0 ], htlc_cblock ];
                                                });

                                                //broadcast the sweep tx
                                                var txhex = tapscript.Tx.encode( sweep_tx ).hex;
                                                console.log( 'broadcast this:', txhex );
                                                console.log( `you can broadcast the tx like this:` );
                                                console.log( `var my_network = "${network_string}".split( "," );chain_client.commander( my_network, "broadcast", "${txhex}" )` );
                                            }
                                        }
                                        if ( $( '.check_to_ln' ) ) $( '.check_to_ln' ).onclick = async () => {
                                            showModal( `This button doesn't do anything yet` );
                                        }
                                    } else {
                                        hedgehog_client.showPage( "wallet_page" );
                                        var chan_id = hedgehog_client.getChanId();
                                        if ( chan_id ) {
                                            showModal( '<p>cashing check with existing channel...</p>' );
                                            var check_hex = hedgehog_client.textToHex( check.content );
                                            var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                                            var { check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey } = check_data;
                                            hedgehog_client.cashCheck( chan_id, check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey );
                                        } else {
                                            showModal( '<p>opening a new channel...</p>' );
                                            var check_hex = hedgehog_client.textToHex( check.content );
                                            hedgehog_client.onboard( check_server_id, check_hex );
                                            var loop = async () => {
                                                if ( hedgehog_client.getChanId() ) return;
                                                await hedgehog_client.waitSomeTime( 10 );
                                                return await loop();
                                            }
                                            await loop();
                                            showModal( '<p>you have a new channel now -- about to use it to receive the money</p>' );
                                        }
                                    }
                                }
                            }
                        }
                        catch ( e ) {
                            console.log( e );
                        }
                    }
                    if ( hedgehog_client.use_rest ) {
                        var loop = async () => {
                            var sig = await nobleSecp256k1.schnorr.sign( "a".repeat( 64 ), nostr_privkey );
                            var data = await fetch( hedgehog_client.rest_endpoint + "/read", {
                                method: "POST",
                                headers: {
                                    "Content-type": "application/json"
                                },
                                body: JSON.stringify({sig, pubkey: nostr_pubkey}),
                            });
                            var json = await data.json();
                            json.forEach( item => handleFunction({ data: JSON.stringify( [ null, null, item ] )}) );
                            await hedgehog_client.waitSomeTime( 1_000 );
                            return loop();
                        }
                        loop();
                    } else {
                        var listenFunction = async socket => {
                            var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                            var filter  = {}
                            filter.authors = [ server ];
                            filter.kinds = [ 4 ];
                            filter[ "#p" ] = [ nostr_pubkey ];
                            filter.since = Math.floor( Date.now() / 1000 );
                            var subscription = [ "REQ", subId, filter ];
                            socket.send( JSON.stringify( subscription ) );
                        }
                        await super_nostr.newPermanentConnection( servers_relays[ 0 ], listenFunction, handleFunction );
                    }

                    //ensure check is redeemable
                    var counterpartys_pubkey = server;
                    var msg_for_counterparty = JSON.stringify({
                        msg_type: "get_check_status",
                        msg_value: { encrypted_chan_id, check_pmthash, check_amnt, encryption_pubkey, check_absolute_timelock },
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, counterpartys_pubkey, msg_for_counterparty );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", counterpartys_pubkey ] ] );
                    hedgehog_client.sendEvent( event, servers_relays[ 0 ] );
                },
                cashCheck: async ( chan_id, check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey ) => {
                    //prepare the needed variables
                    var state = hedgehog.state[ chan_id ];
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var check_pmthash = await super_nostr.sha256( super_nostr.hexToBytes( check_preimage ) );

                    //request the server to send you a hedgehog htlc
                    var msg_for_server = JSON.stringify({
                        msg_type: "request_hh_pmt_to_user",
                        msg_value: {
                            chan_id,
                            check_amount,
                            check_pmthash,
                            check_absolute_timelock,
                            check_server_id,
                            check_encrypted_chan_id,
                            check_encryption_pubkey,
                        }
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    hedgehog_client.prepToReceiveLNPartOne( chan_id, check_amount, check_preimage );
                },
                pingServer: async () => {
                    var loop = async () => {
                        if ( hedgehog_client.getChanId() ) return;
                        await hedgehog_client.waitSomeTime( 10 );
                        return await loop();
                    }
                    await loop();
                    var chan_id = hedgehog_client.getChanId();
                    var server = hedgehog_client.server;
                    var privkey = hedgehog_client.nostr_privkey;
                    var msg_for_server = JSON.stringify({
                        msg_type: "ping_for_liveness",
                        msg_value: {chan_id},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.sendEvent( event, hedgehog_client.relays[ 0 ] );
                    await hedgehog_client.waitSomeTime( 10_000 );
                    hedgehog_client.pingServer();
                },
                manageChecks: async () => {
                    var i; for ( i=0; i<Object.keys( hedgehog_client.funded_checks ).length; i++ ) {
                        var check_id = Object.keys( hedgehog_client.funded_checks )[ i ];
                        var preimage = hedgehog_client.funded_checks[ check_id ].data_to_put_on_nostr.check_preimage;
                        var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                        var chan_id = hedgehog_client.getChanId();
                        var state = hedgehog.state[ chan_id ];
                        var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                        var am_alice = !!state.alices_priv;
                        var htlc_still_exists = false;
                        var j; for ( j=0; j<latest_state.extra_outputs.length; j++ ) {
                            var htlc = latest_state.extra_outputs[ j ];
                            if ( htlc.pmthash !== pmthash ) continue;
                            var sender = htlc.sender;
                            if ( am_alice && sender !== "alice" ) continue;
                            if ( !am_alice && sender !== "bob" ) continue;
                            htlc_still_exists = true;
                        }
                        if ( !htlc_still_exists ) delete hedgehog_client.funded_checks[ check_id ];
                    }
                    await hedgehog_client.waitSomeTime( 100 );
                    hedgehog_client.manageChecks();
                },
                manageSubscriptions: async () => {
                    var i; for ( i=0; i<Object.keys( hedgehog_client.subscriptions ).length; i++ ) {
                        var subscription_id = Object.keys( hedgehog_client.subscriptions )[ i ];
                        console.log( 'subscription_id:', subscription_id );
                        var subscription = hedgehog_client.subscriptions[ subscription_id ];
                        var num_of_unfunded_checks = Object.keys( subscription.unfunded_check_ids ).length;
                        var twelve_unfunded_checks_exist = num_of_unfunded_checks > 11;
                        if ( !twelve_unfunded_checks_exist ) {
                            //TODO: create as many unfunded checks as are needed in order to ensure 12 are available
                            var num_needed = 12 - num_of_unfunded_checks;
                            var unfunded_check_id = "u_" + hedgehog.getPrivkey().substring( 0, 32 );
                            var unfunded_check_preimage = hedgehog.getPrivkey();
                            var unfunded_check_amount = subscription.cost;
                            //TODO: change the 10 to the value of the latest funded or unfunded check for that subscription, or use the start time if no funded or unfunded checks have been created for this subscription yet
                            //return here
                            var unfunded_check_timelock = 10 + subscription.interval;
                        }
                    }
                    await hedgehog_client.waitSomeTime( 100 );
                    hedgehog_client.manageSubscriptions();
                },
                sendEvent: async ( event, relay ) => {
                    if ( hedgehog_client.use_rest === "unknown" ) return;
                    if ( hedgehog_client.use_rest && !hedgehog_client.rest_endpoint ) return;
                    if ( !hedgehog_client.use_rest ) {
                        super_nostr.sendEvent( event, relay );
                        return;
                    }
                    fetch( hedgehog_client.rest_endpoint + "/write", {
                        method: "POST",
                        headers: {"Content-type": "application/json"},
                        body: JSON.stringify( event ),
                    });
                },
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .onboard_in_log_in {
                color: blue;
                text-decoration: underline;
                cursor: pointer;
            }
            .show_backup_string {
                padding: 1rem;
                background-color: tan;
                font-family: mono;
            }
            .check {
                background-color: lightgreen;
                padding: 1rem;
                border: 1px solid green;
            }
            .unfunded {
                background-color: lightblue;
            }
            .check_btn, .check_qr_code, .check_payment_string {
                margin-top: 1rem;
            }
            .check_qr_code {
                max-width: 15rem;
            }
            .check_payment_string {
                background-color: tan;
                padding: 1rem;
            }
            .channel_fee_info {
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .include_channel_fee {
                width: .7rem;
                margin-right: 0.5rem;
            }
            .checks_amnt_p, .checks_amnt_p * {
                font-size: .9rem;
            }
            .bluelink {
                color: blue;
                text-decoration: underline;
                cursor: pointer;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <style>
            .black-bg {
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
                background-color: black;
                opacity: .5;
                width: 100vw;
                height: 100vh;
            }
            .modal {
                position: fixed;
                box-sizing: border-box;
                top: 50%;
                left: 50%;
                transform: translate(-50%,-50%);
                width: 90%;
                max-width: 560px;
                background-color: white;
                border-radius: 1rem;
                padding: 20px;
                color: black;
                text-align: center;
                word-wrap: break-word;
            }
            .modal * {
                color: black;
            }
            .modal input, .modal textarea {
                max-width: 90%;
            }
        </style>
        <script>
            var modalVanish = () => {
                $( ".black-bg" ).classList.add( "hidden" );
                $( ".modal" ).classList.add( "hidden" );
            }
            var showModal = content => {
                $( ".modal" ).innerHTML = `<div class="x_modal" style="position: absolute;right: 1rem;top: 0.5rem;font-size: 2rem; cursor: pointer; color: black;" onclick="modalVanish()">&times;</div>`;
                $( ".modal" ).innerHTML += `<div style="overflow-y: auto; max-height: 80vh; margin-top: 1.5rem;">${content}</div>`;
                $( ".black-bg" ).classList.remove( "hidden" );
                $( ".modal" ).classList.remove( "hidden" );
            }
        </script>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = {}
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                url_params[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <div class="welcome_page">
            <h1>Welcome to hedgehog</h1>
            <p>A lightning-like layer two for bitcoin, but better</p>
            <p><button class="log_in">Log in</button></p>
            <p><button class="onboard">Onboard</button></p>
        </div>
        <div class="wallet_page hidden">
            <h1>Your wallet</h1>
            <p>Balance: <span class="balance">0</span> sats</p>
            <p class="checks_amnt_p hidden">In checks: <span class="balance_in_checks">0</span> sats</p>
            <p><button class="open_channel hidden">Open channel</button></p>
            <p><button class="receive">Receive</button></p>
            <p><button class="send">Send</button></p>
            <p><button class="checks">Cheques</button></p>
            <p><button class="exit">Exit</button></p>
        </div>
        <div class="checks_page hidden">
            <h1>Checks</h1>
            <p><button class="new_check">New cheque</button> <button class="back_btn">Back</button></p>
            <h2>Pending cheques</h2>
            <div class="pending_checks"></div>
        </div>
        <div class="check_page hidden">
            <h1>Time to redeem your cheque</h1>
            <p><button class="new_check">New cheque</button> <button class="back_btn">Back</button></p>
            <div class="check_info">loading cheque info...</div>
        </div>
        <div class="loading_page hidden">
            <p>Loading...</p>
        </div>
        <script>
            hedgehog_client.setUpComms();
            $( '.log_in' ).onclick = () => {
                var content = `
                    <p>Enter your backup string</p>
                    <p><input class="backup_string"></input></p>
                    <p><button class="submit_backup_string">Submit</button></p>
                    <p>Don't have a backup string? <span class="onboard_in_log_in">Onboard!</span></p>
                `;
                showModal( content );
                $( '.onboard_in_log_in' ).onclick = () => {hedgehog_client.onboard();}
            }
            $( '.onboard' ).onclick = () => {hedgehog_client.onboard();}
            $( '.open_channel' ).onclick = hedgehog_client.openChannel;
            $( '.receive' ).onclick = () => {
                var chan_id = hedgehog_client.getChanId();
                var check = null;
                if ( !chan_id ) check = prompt( `enter a check` );
                hedgehog_client.receive( check );
            }
            $( '.send' ).onclick = hedgehog_client.sendBtn;
            $( '.checks' ).onclick = hedgehog_client.showChecks;
            $( '.new_check' ).onclick = hedgehog_client.newCheck;
            $( '.exit' ).onclick = () => {
                showModal( `This button doesn't do anything yet` );
            }
            $$( '.back_btn' ).forEach( item => item.onclick = () => hedgehog_client.showPage( "wallet_page" ) );
            if ( url_params.onboard ) hedgehog_client.onboard();
            if ( url_params.backup_string ) hedgehog_client.login( url_params.backup_string );
            if ( url_params.check ) hedgehog_client.checkPage();
        </script>
        <div class="black-bg hidden" onclick="modalVanish();"></div>
        <div class="modal hidden"></div>
    </body>
</html> 
