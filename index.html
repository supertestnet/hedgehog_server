<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <title>Hedgehog</title>
        <script src="https://bundle.run/buffer@6.0.3"></script>
        <script>var Buffer = buffer.Buffer;</script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/qrcode.js"></script>
        <script src="https://unpkg.com/@dashincubator/ripemd160/ripemd160.js"></script>
        <script src="https://supertestnet.github.io/bolt11_browser/bolt11.js"></script>
        <script src="https://supertestnet.github.io/bankify/super_nostr.js"></script>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.5.3"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://bundle.run/base58check@2.0.0"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <script>
            var hedgehog = {
                state: {},
                keypairs: {},
                network: "regtest",
                backup_pubkey: "a".repeat( 64 ),
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                getPrivkey: () => hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ),
                getPubkey: privkey => nobleSecp256k1.getPublicKey( privkey, true ).substring( 2 ),
                getAddressData: ( scripts, index ) => {
                    var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var [ tpubkey, cblock ] = tapscript.Tap.getPubKey( hedgehog.backup_pubkey, { tree, target: tree[ index ] });
                    var address = tapscript.Address.p2tr.fromPubKey( tpubkey, hedgehog.network );
                    return [ address, tree, cblock ];
                },
                getChannelScripts: chan_id => {
                    var state = hedgehog.state[ chan_id ];
                    return [ [ state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ] ];
                },
                sha256: async s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var arr = await crypto.subtle.digest( 'SHA-256', s );
                    return hedgehog.bytesToHex( new Uint8Array( arr ) );
                },
                isValidAddress: address => {
                    try {
                        return !!tapscript.Address.decode( address ).script;
                    } catch( e ) {return;}
                    return;
                },
                getVin: ( txid, vout, amnt, addy, sequence = 0xffffffff - 2 ) => ({
                    txid,
                    vout,
                    sequence,
                    prevout: {
                        value: amnt,
                        scriptPubKey: hedgehog.isValidAddress( addy ) ? tapscript.Address.toScriptPubKey( addy ) : addy,
                    },
                }),
                getVout: ( amnt, addy ) => ({
                    value: amnt,
                    scriptPubKey: hedgehog.isValidAddress( addy ) ? tapscript.Address.toScriptPubKey( addy ) : addy,
                }),
                getMidstateScripts: ( chan_id, am_sender, revocation_hash, uses_htlc, sender_is_funding_htlc, creating_counterparties_version ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //the midstate can be revoked by the recipient, so we need to find out
                    //which user can do that and which revocation hash is required -- namely,
                    //the one for which the recipient alone knows the preimage (until they
                    //revoke it)
                    if ( am_sender && am_alice ) {
                        var senders_pub = state.alices_pub;
                        var revhash = state.bobs_revocation_hashes[ state.bobs_revocation_hashes.length - 1 ];
                    }
                    if ( am_sender && !am_alice ) {
                        var senders_pub = state.bobs_pub;
                        var revhash = state.alices_revocation_hashes[ state.alices_revocation_hashes.length - 1 ];
                    }
                    if ( !am_sender && am_alice ) {
                        var senders_pub = state.bobs_pub;
                        var revhash = state.alices_revocation_hashes[ state.alices_revocation_hashes.length - 1 ];
                    }
                    if ( !am_sender && !am_alice ) {
                        var senders_pub = state.alices_pub;
                        var revhash = state.bobs_revocation_hashes[ state.bobs_revocation_hashes.length - 1 ];
                    }

                    //in some cases, the revocation hash is not *the latest* one, but is supplied by
                    //the person spending the money, because they are spending a midstate that does
                    //not represent the latest state -- e.g. this happens in a justice transaction
                    if ( revocation_hash ) revhash = revocation_hash;

                    //prepare and return the midstate scripts
                    var midstate_scripts = [
                        //the first branch allows for both parties to finalize the state
                        //it also allows the recipient to conditionally revoke this state later
                        [ state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ],
                        //the second branch allows the sender to recover the funds if the recipient disappears after initiating a force closure -- this is called a disappearance transaction
                        //TODO: change the 6 to 2026
                        [ senders_pub, "OP_CHECKSIGVERIFY", 6, "OP_CHECKSEQUENCEVERIFY" ],
                        //the third branch allows the recipient to absolutely revoke this state
                        [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", revhash, "OP_EQUALVERIFY", senders_pub, "OP_CHECKSIG" ],
                    ];

                    //in some cases, tx1 and tx2 must be different for Alice and Bob, otherwise one
                    //can broadcast a transaction that puts the money into a state the other one has
                    //revoked. Thus we need to know who is broadcasting the tx that funds the midstate
                    //and use that to modify it so that neither party has the sigs necessary for
                    //forcing the other one's money into a state they revoked
                    if ( uses_htlc ) {
                        /*
                            When Bob sends an htlc to Alice, he creates two txs:
                            - one where he creates his own version and writes "bob_is_funding_this"
                            - one where he creates alice's version and writes "alice_is_funding_this"
                            
                            When Alice receives an htlc from Bob, she creates two txs:
                            - one where she creates her own version and writes "alice_is_funding_this"
                            - one where she creates bob's version and writes "bob_is_funding_this"

                            When Alice sends an htlc to Bob, she creates two txs:
                            - one where she creates her own version and writes "alice_is_funding_this"
                            - one where she creates bob's version and writes "bob_is_funding_this"

                            When Bob receives an htlc from Alice, he creates two txs:
                            - one where he creates his own version and writes "bob_is_funding_this"
                            - one where he creates alice's version and writes "alice_is_funding_this"
                        */
                        if ( am_alice === creating_counterparties_version ) var extra_branch = [ "OP_RETURN", "bob_is_funding_this" ];
                        else var extra_branch = [ "OP_RETURN", "alice_is_funding_this" ];
                        midstate_scripts.push( extra_branch );
                    }

                    return midstate_scripts;
                },
                getInitialHTLCScripts: ( chan_id, sender_is_funder, am_sender, pmthash, htlc_locktime ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //the initial HTLC address can be swept by whichever party did *not* fund it after a long delay, so we need to find out which user can do that
                    if ( sender_is_funder && am_sender && am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( sender_is_funder && !am_sender && am_alice ) var sweepers_pub = state.alices_pub;
                    if ( sender_is_funder && am_sender && !am_alice ) var sweepers_pub = state.alices_pub;
                    if ( sender_is_funder && !am_sender && !am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( !sender_is_funder && am_sender && am_alice ) var sweepers_pub = state.alices_pub;
                    if ( !sender_is_funder && !am_sender && am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( !sender_is_funder && am_sender && !am_alice ) var sweepers_pub = state.bobs_pub;
                    if ( !sender_is_funder && !am_sender && !am_alice ) var sweepers_pub = state.alices_pub;
                    var counterpartys_pub = state.alices_pub;
                    if ( sweepers_pub === state.alices_pub ) var counterpartys_pub = state.bobs_pub;

                    //in the initial htlc, both paths require both parties to cosign, and one path – the “reveal path,” as opposed to the “recovery path” – also requires the recipient to reveal a preimage
                    return [
                        //the first branch is the "reveal path" and it allows both parties to
                        //spend the money if they cosign and reveal a preimage
                        [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", pmthash, "OP_EQUALVERIFY", state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ],
                        //the second branch is the "recovery path" and it does not require a preimage
                        //but is otherwise the same
                        [ state.alices_pub, "OP_CHECKSIGVERIFY", state.bobs_pub, "OP_CHECKSIG" ],
                        //the third branch allows whichever party did *not* fund the address to sweep it
                        //after a long delay
                        [ sweepers_pub, "OP_CHECKSIGVERIFY", htlc_locktime, "OP_CHECKSEQUENCEVERIFY" ],
                    ];
                },
                getRevocableScripts: ( chan_id, sender_is_revoker, am_sender, revhash ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //the revocation address can be revoked by one party, so we need to find out
                    //which user can do that
                    if ( sender_is_revoker && am_sender && am_alice ) var revokers_pub = state.alices_pub;
                    if ( sender_is_revoker && !am_sender && am_alice ) var revokers_pub = state.bobs_pub;
                    if ( sender_is_revoker && am_sender && !am_alice ) var revokers_pub = state.bobs_pub;
                    if ( sender_is_revoker && !am_sender && !am_alice ) var revokers_pub = state.alices_pub;
                    if ( !sender_is_revoker && am_sender && am_alice ) var revokers_pub = state.bobs_pub;
                    if ( !sender_is_revoker && !am_sender && am_alice ) var revokers_pub = state.alices_pub;
                    if ( !sender_is_revoker && am_sender && !am_alice ) var revokers_pub = state.alices_pub;
                    if ( !sender_is_revoker && !am_sender && !am_alice ) var revokers_pub = state.bobs_pub;
                    var counterpartys_pub = state.alices_pub;
                    if ( revokers_pub === state.alices_pub ) counterpartys_pub = state.bobs_pub;

                    //in a revocable script, the soon-to-be revoker can recover the money after
                    //a delay, or their counterparty can sweep the money if they learn the
                    //revocation secret
                    return [
                        //the first branch allows the revoker to spend the money after a delay
                        //TODO: change the 6 to 2016
                        [ revokers_pub, "OP_CHECKSIGVERIFY", 6, "OP_CHECKSEQUENCEVERIFY" ],
                        //the second branch allows the counterparty to sweep the money if they
                        //learn the revocation secret
                        [ "OP_SHA256", revhash, "OP_EQUALVERIFY", counterpartys_pub, "OP_CHECKSIGVERIFY" ],
                    ];
                },
                getTx1: ( chan_id, am_sender, htlc_addy_and_amnt, midstate_scripts_override ) => {
                    //tx1 is used during a force closure
                    //it takes money from the channel and puts it in the midstate
                    //prepare variables necessary for creating tx1
                    var state = hedgehog.state[ chan_id ];
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var channel = hedgehog.getAddressData( channel_scripts, 0 )[ 0 ];
                    var uses_htlc = !!htlc_addy_and_amnt;
                    var sender_is_funding_htlc = htlc_addy_and_amnt ? htlc_addy_and_amnt[ 2 ] : null;
                    var revhash = htlc_addy_and_amnt ? htlc_addy_and_amnt[ 3 ] : null;
                    var creating_counterparties_version = false;
                    if ( htlc_addy_and_amnt && htlc_addy_and_amnt.length > 4 && htlc_addy_and_amnt[ 4 ] ) {
                        creating_counterparties_version = htlc_addy_and_amnt[ 4 ];
                    }
                    var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, revhash, uses_htlc, sender_is_funding_htlc, creating_counterparties_version );
                    if ( midstate_scripts_override ) midstate_scripts = midstate_scripts_override;
                    var midstate = hedgehog.getAddressData( midstate_scripts, 0 )[ 0 ];

                    //prepare the vouts
                    var vout = [
                        hedgehog.getVout( state.funding_txinfo[ 2 ] - 240, midstate ),
                        hedgehog.getVout( 240, "51024e73" ),
                    ];

                    //if the payment involves an htlc, modify the vouts
                    if ( htlc_addy_and_amnt ) {
                        var [ htlc_address, htlc_amnt ] = htlc_addy_and_amnt;
                        vout.push( hedgehog.getVout( htlc_amnt, htlc_address ) );
                        vout[ 0 ] = hedgehog.getVout( state.funding_txinfo[ 2 ] - 240 - htlc_amnt, midstate );
                    }

                    //prepare and return tx1
                    return tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( state.funding_txinfo[ 0 ], state.funding_txinfo[ 1 ], state.funding_txinfo[ 2 ], channel ),
                        ],
                        vout,
                    });
                },
                getTx2: ( chan_id, am_sender, tx1_txid, midstate, recipients_new_balance, sum_of_senders_htlcs = 0, am_alice_for_tx2 ) => {
                    //tx2 is used during a force closure
                    //it takes money from the midstate and creates the latest state
                    //prepare variables necessary for creating tx2
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = am_alice_for_tx2;
                    if ( am_sender && am_alice ) var recipients_pub = state.bobs_pub;
                    if ( am_sender && !am_alice ) var recipients_pub = state.alices_pub;
                    if ( !am_sender && am_alice ) var recipients_pub = state.alices_pub;
                    if ( !am_sender && !am_alice ) var recipients_pub = state.bobs_pub;
                    if ( recipients_pub === state.alices_pub ) var senders_pub = state.bobs_pub;
                    else var senders_pub = state.alices_pub;
                    var sender_is_alice = ( am_sender && am_alice ) || ( !am_sender && !am_alice );

                    //figure out what amount each user should get in this transaction
                    if ( !state.channel_states.length ) var total_in_channel = recipients_new_balance;
                    else var total_in_channel = state.channel_states[ 0 ].amnt;
                    var alices_amnt = total_in_channel - recipients_new_balance;
                    var bobs_amnt = recipients_new_balance;
                    if ( recipients_pub === state.alices_pub ) {
                        var alices_amnt = recipients_new_balance;
                        var bobs_amnt = total_in_channel - recipients_new_balance;
                    }

                    //account for the loss of 480 sats due to anchor outputs
                    //note that 240 is the dust limit for v3 "anchor outputs"
                    if ( sender_is_alice ) alices_amnt = alices_amnt - 240 - 240 - sum_of_senders_htlcs;
                    else bobs_amnt = bobs_amnt - 240 - 240 - sum_of_senders_htlcs;

                    //prepare and return tx2
                    var tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( tx1_txid, 0, state.funding_txinfo[ 2 ] - 240 - sum_of_senders_htlcs, midstate, 3 ),
                        ],
                        vout: [
                            hedgehog.getVout( 240, "51024e73" ),
                        ],
                    });
                    //note that 330 sats is the dust limit for taproot addresses other than anchor outputs
                    if ( alices_amnt > 330 ) tx.vout.push( hedgehog.getVout( alices_amnt, [ 1, state.alices_pub ] ) );
                    if ( bobs_amnt > 330 ) tx.vout.push( hedgehog.getVout( bobs_amnt, [ 1, state.bobs_pub ] ) );
                    return tx;
                },
                getConditionalRevocationTx: ( prev_tx1_txid, prev_tx1, tx2 ) => {
                    return tapscript.Tx.create({
                        version: 3,
                        vin: [{
                            txid: prev_tx1_txid,
                            vout: 0,
                            prevout: prev_tx1.vout[ 0 ],
                        }],
                        vout: tx2.vout,
                    });
                },
                getTxData: ( chan_id, am_alice, am_sender, amnt, sender, htlc_addy_and_amnt, use_custom_midstate_revhash, midstate_scripts_override, pending_htlcs = [], do_not_delete ) => {
                    //prepare variables necessary for returning the required txdata
                    var state = hedgehog.state[ chan_id ];
                    var uses_htlc = !!htlc_addy_and_amnt;
                    var sender_is_funding_htlc;
                    var midstate_revhash = null;
                    var sender_of_htlc = null;
                    if ( htlc_addy_and_amnt ) {
                        sender_is_funding_htlc = htlc_addy_and_amnt[ 2 ];
                        if ( use_custom_midstate_revhash ) midstate_revhash = htlc_addy_and_amnt[ 3 ];
                        if ( htlc_addy_and_amnt.length > 5 && htlc_addy_and_amnt[ 5 ] ) sender_of_htlc = htlc_addy_and_amnt[ 5 ];
                    }

                    //find out if the sender of *this* tx also sent the *previous* tx
                    var sender_previously_sent = false;
                    if ( state.channel_states.length ) sender_previously_sent = state.channel_states[ state.channel_states.length - 1 ].from === sender;

                    //if the sender *did* send the previous tx you must remove whatever revocation
                    //preimage and hash they created after sending that tx, because you are replacing
                    //that state with a new one that sends the recipient more money, and that new
                    //state will use a different revocation preimage and hash
                    if ( sender_previously_sent && !do_not_delete ) {
                        if ( am_sender ) {
                            if ( am_alice ) {
                                state.alices_revocation_preimages.pop();
                                state.alices_revocation_hashes.pop();
                            } else {
                                state.bobs_revocation_preimages.pop();
                                state.bobs_revocation_hashes.pop();
                            }
                        } else {
                            if ( am_alice ) {
                                state.bobs_revocation_preimages.pop();
                                state.bobs_revocation_hashes.pop();
                            } else {
                                state.alices_revocation_preimages.pop();
                                state.alices_revocation_hashes.pop();
                            }
                        }
                    }

                    //prepare tx1 and the variables needed for broadcasting it
                    var tx1 = hedgehog.getTx1( chan_id, am_sender, htlc_addy_and_amnt, midstate_scripts_override );
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ _, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );

                    //prepare the variables needed for creating and broadcasting tx2
                    var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, midstate_revhash, uses_htlc, sender_is_funding_htlc );
                    if ( midstate_scripts_override ) midstate_scripts = midstate_scripts_override;
                    var absolute_revocation_hash = midstate_scripts[ 2 ][ 4 ];
                    var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 0 );

                    //find out how much money the sender and recipient are supposed to get via tx2
                    if ( !state.channel_states.length ) var balances = [ 0, 0 ];
                    else var balances = hedgehog.getBalances( chan_id );
                    if ( am_sender ) {
                        var recipients_old_balance = am_alice ? balances[ 1 ] : balances[ 0 ];
                    } else {
                        var recipients_old_balance = am_alice ? balances[ 0 ] : balances[ 1 ];
                    }
                    var recipients_new_balance = recipients_old_balance + amnt;
                    if ( !state.channel_states.length ) recipients_new_balance = recipients_new_balance - 240 - 240;

                    //if the user was the last to send, modify recipients_new_balance so that it is
                    //the previous amount sent plus the new amount -- unless the last transaction
                    //sent money via an htlc, because then the previous amount sent was really 0
                    if ( sender_previously_sent ) {
                        var prev_state = state.channel_states[ state.channel_states.length - 1 ];
                        var prev_update_added_htlc = prev_state.added_htlc;
                        if ( !prev_update_added_htlc ) {
                            var amnt_recipient_had = prev_state.amnt + 240 + 240 - prev_state.amnt_sent;
                            var amnt_sent_previously = prev_state.amnt_sent;
                            if ( am_sender ) amnt = amnt_sent_previously + amnt;
                            var recipients_new_balance = amnt_recipient_had + amnt - 240 - 240;
                        }
                    }

                    //in an htlc is used, the recipient's balance should not change
                    if ( uses_htlc ) recipients_new_balance = recipients_old_balance;

                    //prepare tx2
                    var sum_of_senders_htlcs = 0;
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    //TODO: instead of getting *all* pending htlcs, just get the ones relevant
                    //to the current transaction -- e.g. if you are creating a justice tx for
                    //a state many states ago, some pending htlcs may have been created *after*
                    //that state and thus should be ignored when creating the justice transaction
                    //perhaps I should pass the relevant htlcs to this function as a parameter
                    pending_htlcs.forEach( htlc => {
                        if ( ( am_alice && htlc.sender === "alice" ) || ( !am_alice && htlc.sender === "bob" ) ) sum_of_senders_htlcs = sum_of_senders_htlcs + htlc.amnt;
                    });
                    if ( htlc_addy_and_amnt ) {
                        if ( ( am_alice && sender_of_htlc === "alice" ) || ( !am_alice && sender_of_htlc === "bob" ) ) sum_of_senders_htlcs = htlc_addy_and_amnt[ 1 ];
                    }
                    var tx2 = hedgehog.getTx2( chan_id, am_sender, tx1_txid, midstate, recipients_new_balance, sum_of_senders_htlcs, am_alice );

                    //if the sender received money at any point, they must revoke the most recent tx by
                    //which they received money, so we prepare that tx if necessary so they can sign it
                    var conditional_revocation_needed = hedgehog.conditionalRevocationNeeded( chan_id, am_sender );
                    if ( conditional_revocation_needed ) {
                        var prev_tx1 = tapscript.Tx.decode( conditional_revocation_needed );
                        var prev_tx1_txid = tapscript.Tx.util.getTxid( prev_tx1 );
                        var conditional_revocation_tx = hedgehog.getConditionalRevocationTx( prev_tx1_txid, prev_tx1, tx2 );
                    }

                    //return all the variables and txs needed for creating the new state
                    var txs = [ recipients_new_balance, channel_tree, channel_cblock, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ];
                    if ( conditional_revocation_needed ) txs.push( conditional_revocation_tx, prev_tx1 );
                    return txs;
                },
                getBalances: chan_id => {
                    var state = hedgehog.state[ chan_id ];
                    var total_in_channel = state.channel_states[ 0 ].amnt;
                    //find the last state that didn't send an htlc -- note that
                    //when htlcs are sent, neither party's balance should change
                    //because the payment is pending until the htlc resolves, at
                    //which point, *that* is when their balances should change
                    var findPrevState = ( possible_last_state ) => {
                        var prev_state = state.channel_states[ state.channel_states.length - possible_last_state ];
                        var htlc_was_added = prev_state.added_htlc;
                        if ( !htlc_was_added ) return prev_state;
                        possible_last_state = possible_last_state + 1;
                        return findPrevState( possible_last_state );
                    }
                    var prev_state = findPrevState( 1 );
                    var last_sender = prev_state.from;
                    var last_senders_amount = total_in_channel - prev_state.amnt;
                    var htlc_was_added = prev_state.added_htlc;
                    var balances = [ last_senders_amount, prev_state.amnt + 240 + 240 ];
                    if ( last_sender !== "alice" ) balances = [ prev_state.amnt + 240 + 240, last_senders_amount ];
                    return balances;
                },
                conditionalRevocationNeeded: ( chan_id, am_sender ) => {
                    //prepare variables necessary for finding out if a conditional revocation is necessary
                    var tx_to_be_revoked = null;
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //we start by assuming we are the sender, though we will change that assumption momentarily if needed. if we are the sender, we must revoke the last state where we received money. the creator of that state was our counterparty, who sent us money in that state. so if we are alice, we must seek the last state created by bob, i.e. where bob was the sender. if, however, we are not the sender, then we seek to ensure the sender revoked the last state where *they* received money, which is a state where *we* were the sender; so, if we are alice and we are *not* the sender of *this* transaction, we seek the last state where the sender was *alice,* i.e. ourselves, because that is the state where we last sent money, and that is the state we must ensure our counterparty revoked.
                    if ( am_alice && am_sender ) var sender = "bob";
                    if ( !am_alice && am_sender ) var sender = "alice";
                    if ( am_alice && !am_sender ) var sender = "alice";
                    if ( !am_alice && !am_sender ) var sender = "bob";

                    //return the most recent state where the recipient received money, if any
                    //I parse a strinigified version of the object to create a deep clone
                    //so that the original is unmodified by my reversing of it
                    var reversed = JSON.parse( JSON.stringify( state.channel_states ) );
                    reversed = reversed.reverse();
                    reversed.every( ( item, index ) => {
                        if ( item.from === sender ) {
                            tx_to_be_revoked = item[ "tx1" ];
                            return;
                        }
                        return true;
                    });
                    return tx_to_be_revoked;
                },
                absoluteRevocationNeeded: ( chan_id, am_sender ) => {
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    //this function is used twice: when sending and when receiving i.e. validating
                    //when sending, you revoke the state two transactions ago, because the most *recent*
                    //state is one you're *allowed to* broadcast per the hedgehog protocol, and the
                    //*current* state is also allowed. But you're not allowed to broadcast and states
                    //before then. So, every time you make a new transaction, you get the revocation preimage
                    //from two transactions ago and reveal it to your recipient so that you can no longer
                    //broadcast that old state.
                    //As the recipient, you check the validity of the revocation preimage by grabing your
                    //counterparty's revocation hash from two transactions ago and ensuring that the
                    //preimage they revealed to you hashes to that hash. Which is why this function
                    //returns the revoation hash from two transactions ago if you are the recipient.
                    if ( am_alice && am_sender ) return state.alices_revocation_preimages[ state.alices_revocation_preimages.length - 2 ];
                    if ( !am_alice && am_sender ) return state.bobs_revocation_preimages[ state.bobs_revocation_preimages.length - 2 ];
                    if ( am_alice && !am_sender ) return state.bobs_revocation_hashes[ state.bobs_revocation_hashes.length - 2 ];
                    if ( !am_alice && !am_sender ) return state.alices_revocation_hashes[ state.alices_revocation_hashes.length - 2 ];
                },
                conditionallyRevokeChannelStates: async ( chan_id, prev_tx1, sig, vout ) => {
                    var state = hedgehog.state[ chan_id ];
                    var real_txid = tapscript.Tx.util.getTxid( prev_tx1 );
                    state.channel_states.forEach( item => {
                        var expected_txid = tapscript.Tx.util.getTxid( item.tx1 );
                        if ( expected_txid !== real_txid ) return;
                        item[ "conditional_revocation_sig" ] = sig;
                        item[ "conditional_revocation_vout" ] = vout;
                    });
                },
                fullyRevokeChannelStates: async ( chan_id, preimage ) => {
                    var state = hedgehog.state[ chan_id ];
                    var real_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    state.channel_states.forEach( item => {
                        var expected_hash = item.absolute_revocation_hash;
                        if ( expected_hash !== real_hash ) return;
                        item[ "absolute_revocation_preimage" ] = preimage;
                    });
                },
                prepChannel: bobs_pubkey_and_hash => {
                    //make a channel id
                    var chan_id = "a_" + hedgehog.getPrivkey().substring( 0, 32 );

                    //initialize the channel state
                    hedgehog.state[ chan_id ] = {
                        alices_priv: null,
                        bobs_priv: null,
                        alices_pub: null,
                        bobs_pub: null,
                        alices_revocation_preimages: [],
                        alices_revocation_hashes: [],
                        bobs_revocation_preimages: [],
                        bobs_revocation_hashes: [],
                        funding_txinfo: [],
                        channel_states: [],
                        data_for_preparing_htlcs: {},
                    }
                    var state = hedgehog.state[ chan_id ];

                    //prepare alice's privkey and pubkey
                    if ( !state.alices_priv ) state.alices_priv = hedgehog.getPrivkey();
                    state.alices_pub = hedgehog.getPubkey( state.alices_priv );

                    //store bob's pubkey and hash
                    state.bobs_pub = bobs_pubkey_and_hash[ 0 ];
                    state.bobs_revocation_hashes.push( bobs_pubkey_and_hash[ 1 ] );
                    return chan_id;
                },
                openChannel: async ( bobs_pubkey_and_hash, txdata, data_from_alice, chan_id ) => {
                    //if we pass in an existing chan_id then we skip the first few steps
                    //because only alice does that and she only does it if she already
                    //did the first few steps using the prepChannel() method
                    if ( !chan_id ) {
                        //alice always opens a channel to bob and pushes all funds to his side
                        //bob always opens a channel by receiving data from alice and validating it
                        //consequently the first thing bob must do is change the chan_id to a version
                        //he can use, distinguished by having the first character be a_ if the channel
                        //data is stored by alice and b_ if the channel data is stored by bob
                        //and therefore the first thing we do is detect whether we are alice or bob
                        //by checking if the object data_from_alice exists -- if so, we must be bob
                        //so we change the chan_id so that it doesn't start with a_ but b_
                        if ( data_from_alice ) var chan_id = "b_" + data_from_alice.chan_id.substring( 2 );
                        else var chan_id = "a_" + hedgehog.getPrivkey().substring( 0, 32 );

                        //initialize the channel state
                        hedgehog.state[ chan_id ] = {
                            alices_priv: null,
                            bobs_priv: null,
                            alices_pub: null,
                            bobs_pub: null,
                            alices_revocation_preimages: [],
                            alices_revocation_hashes: [],
                            bobs_revocation_preimages: [],
                            bobs_revocation_hashes: [],
                            funding_txinfo: [],
                            channel_states: [],
                            data_for_preparing_htlcs: {},
                        }
                        var state = hedgehog.state[ chan_id ];
                    } else {
                        var state = hedgehog.state[ chan_id ];
                        if ( !bobs_pubkey_and_hash ) bobs_pubkey_and_hash = [ state.bobs_pub, state.bobs_revocation_hashes[ 0 ] ];
                        state.bobs_revocation_hashes.pop();
                    }

                    //if we are alice, the array bobs_pubkey_and_hash will exist, because alice
                    //needs that info in order to open a channel to bob
                    if ( bobs_pubkey_and_hash ) {
                        //prepare alice's privkey and pubkey
                        if ( !state.alices_priv ) state.alices_priv = hedgehog.getPrivkey();
                        state.alices_pub = hedgehog.getPubkey( state.alices_priv );

                        //store bob's pubkey and hash
                        state.bobs_pub = bobs_pubkey_and_hash[ 0 ];
                        state.bobs_revocation_hashes.push( bobs_pubkey_and_hash[ 1 ] );

                        //prepare the channel address
                        var channel_scripts = hedgehog.getChannelScripts( chan_id );
                        var channel = hedgehog.getAddressData( channel_scripts, 0 )[ 0 ];

                        //fund the channel
                        console.log( 'send money to this address:' );
                        console.log( channel );
                        if ( txdata ) var [ txid, vout, amnt ] = txdata;
                        else {
                            var txid = prompt( `send money into the address in your console and enter the txid` );
                            var vout = Number( prompt( `and the vout` ) );
                            var amnt = Number( prompt( `and the amount` ) );
                        }
                        state.funding_txinfo = [ txid, vout, amnt ];

                        //send bob the data he needs to validate this channel
                        var data_for_bob = await hedgehog.send( chan_id, amnt );
                        data_for_bob[ "funding_txinfo" ] = state.funding_txinfo;
                        data_for_bob[ "alices_pub" ] = state.alices_pub;
                        data_for_bob[ "bobs_pub" ] = state.bobs_pub;
                        return data_for_bob;
                    }

                    //if we are bob, the data_from_alice object will exist
                    if ( data_from_alice ) {
                        //bob's private key was generated previously and stored in an object called keypairs
                        //so we get the private key and Bob's preimage from there and store them in state,
                        //ready for future use
                        var my_pub = data_from_alice.bobs_pub;
                        state.bobs_priv = hedgehog.keypairs[ my_pub ][ "privkey" ];
                        state.bobs_pub = my_pub;
                        state.bobs_revocation_preimages.push( hedgehog.keypairs[ my_pub ][ "preimage" ] );
                        var hash = await hedgehog.sha256( hedgehog.hexToBytes( state.bobs_revocation_preimages[ 0 ] ) );
                        state.bobs_revocation_hashes.push( hash );
                        delete hedgehog.keypairs[ my_pub ];

                        //we also store alice's pubkey and the funding info
                        state.alices_pub = data_from_alice.alices_pub;
                        state.funding_txinfo = data_from_alice.funding_txinfo;

                        //validate the channel opening data
                        var initial_state_is_valid = await hedgehog.receive( data_from_alice );
                        return initial_state_is_valid;
                    }
                },
                send: async ( chan_id, amnt, overwrite_pending_htlcs ) => {
                    //prepare the variables you need to send money
                    var state = hedgehog.state[ chan_id ];
                    var am_sender = true;
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var sender = am_alice ? "alice" : "bob";

                    //get the transaction data
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    if ( overwrite_pending_htlcs ) pending_htlcs = overwrite_pending_htlcs;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, null, null, null, pending_htlcs );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    //getTxData always returns 10 items. It also returns two additional items if a conditional revocation was needed on a prior state, so in that cirucmstance we also grab those two additional items so that we can sign them
                    if ( txs.length > 10 ) {
                        var conditional_revocation_tx = txs[ 10 ];
                        var prev_tx1 = txs[ 11 ];
                    }

                    //sign everything and, if necessary, prepare to revoke previous states
                    var to_midstate_sig = tapscript.Signer.taproot.sign( privkey, tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var finalizer_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, {extension: midstate_tree[ 0 ] }).hex;
                    if ( conditional_revocation_needed ) var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, conditional_revocation_tx, 0, {extension: channel_tree[ 0 ] }).hex;
                    var absolute_revocation_needed = hedgehog.absoluteRevocationNeeded( chan_id, am_sender );

                    //update your state
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: amnt,
                        tx1: tapscript.Tx.encode( tx1 ).hex,
                        absolute_revocation_hash,
                        added_htlc: false,
                        pending_htlcs,
                        absolute_revocation_preimage: null,
                        conditional_revocation_sig: null,
                        conditional_revocation_vout: null,
                    }
                    state.channel_states.push( ch_state );

                    //generate the hash you want your counterparty to use when they next send you money
                    var revocation_preimage = hedgehog.getPrivkey();
                    var revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_preimage ) );
                    if ( am_alice ) {
                        state.alices_revocation_preimages.push( revocation_preimage );
                        state.alices_revocation_hashes.push( revocation_hash );
                    } else {
                        state.bobs_revocation_preimages.push( revocation_preimage );
                        state.bobs_revocation_hashes.push( revocation_hash );
                    }
                    // console.log( 'tx1:' );
                    // console.log( tx1 );
                    // console.log( tapscript.Tx.util.getTxid( tx1 ) );
                    // console.log( 'tx2:' );
                    // console.log( tx2 );
                    // console.log( tapscript.Tx.util.getTxid( tx2 ) );

                    //send your counterparty the data they need to validate the new state
                    var obj = {
                        to_midstate_sig,
                        finalizer_sig,
                        amnt,
                        chan_id,
                        revocation_hash,
                    }
                    if ( conditional_revocation_needed ) obj[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( absolute_revocation_needed ) obj[ "absolute_revocation_preimage" ] = absolute_revocation_needed;
                    return obj;
                },
                receive: async ( data_from_sender, overwrite_pending_htlcs ) => {
                    //prepare the variables necessary for validating the new state
                    var chan_id = data_from_sender.chan_id;
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    var am_sender = false;
                    var sender = am_alice ? "bob" : "alice";
                    var amnt = data_from_sender.amnt;

                    //do not allow the sender to reuse a revocation hash
                    var revocation_hash = data_from_sender.revocation_hash;
                    var counterpartys_revhashes = state.alices_revocation_hashes;
                    if ( am_alice ) counterpartys_revhashes = state.bobs_revocation_hashes;
                    if ( counterpartys_revhashes.includes( revocation_hash ) ) return;

                    //get the transaction data
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    if ( overwrite_pending_htlcs ) pending_htlcs = overwrite_pending_htlcs;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, null, null, null, pending_htlcs );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    //getTxData always returns 10 items. It also returns two additional items if a conditional revocation was needed on a prior state, so in that cirucmstance we also grab those two additional items so that we can validate the signatures involving them
                    if ( txs.length > 10 ) {
                        var conditional_revocation_tx = txs[ 10 ];
                        var prev_tx1 = txs[ 11 ];
                    }

                    //validate the signatures
                    var to_midstate_sig = data_from_sender.to_midstate_sig;
                    var to_midstate_sighash = tapscript.Signer.taproot.hash( tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    if ( am_alice ) var senders_pub = state.bobs_pub;
                    else var senders_pub = state.alices_pub;
                    var to_midstate_sig_is_valid = await nobleSecp256k1.schnorr.verify( to_midstate_sig, to_midstate_sighash, senders_pub );
                    var finalizer_sig = data_from_sender.finalizer_sig;
                    var finalizer_sighash = tapscript.Signer.taproot.hash( tx2, 0, {extension: midstate_tree[ 0 ] }).hex;
                    var finalizer_sig_is_valid = await nobleSecp256k1.schnorr.verify( finalizer_sig, finalizer_sighash, senders_pub );

                    //if necessary, validate the revocation data for prior states
                    if ( conditional_revocation_needed ) {
                        var conditional_revocation_sig = data_from_sender.conditional_revocation_sig;
                        var conditional_revocation_sighash = tapscript.Signer.taproot.hash( conditional_revocation_tx, 0, {extension: channel_tree[ 0 ] }).hex;
                        var conditional_revocation_sig_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_revocation_sighash, senders_pub );
                    }
                    var absolute_revocation_needed = hedgehog.absoluteRevocationNeeded( chan_id, am_sender );
                    if ( absolute_revocation_needed ) {
                        var absolute_revocation_preimage = data_from_sender.absolute_revocation_preimage;
                        var hash = await hedgehog.sha256( hedgehog.hexToBytes( absolute_revocation_preimage ) );
                        if ( hash !== absolute_revocation_needed ) return;
                    }
                    // console.log( 'tx1:' );
                    // console.log( tx1 );
                    // console.log( tapscript.Tx.util.getTxid( tx1 ) );
                    // console.log( 'tx2:' );
                    // console.log( tx2 );
                    // console.log( tapscript.Tx.util.getTxid( tx2 ) );
                    // console.log( 'to_midstate_sig_is_valid, right?', to_midstate_sig_is_valid );
                    // console.log( 'finalizer_sig_is_valid, right?', finalizer_sig_is_valid );
                    if ( !to_midstate_sig_is_valid || !finalizer_sig_is_valid ) return;
                    if ( conditional_revocation_needed && !conditional_revocation_sig_is_valid ) return;

                    //store the revocation data given by your counterparty for future use
                    if ( am_alice ) state.bobs_revocation_hashes.push( revocation_hash );
                    else state.alices_revocation_hashes.push( revocation_hash );
                    if ( conditional_revocation_needed ) await hedgehog.conditionallyRevokeChannelStates( chan_id, prev_tx1, conditional_revocation_sig, conditional_revocation_tx.vout );
                    if ( absolute_revocation_needed ) await hedgehog.fullyRevokeChannelStates( chan_id, absolute_revocation_preimage );

                    //update your state
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: amnt,
                        to_midstate_sig,
                        finalizer_sig,
                        tx1: tapscript.Tx.encode( tx1 ).hex,
                        absolute_revocation_hash,
                        added_htlc: false,
                        pending_htlcs,
                        //it seems unnecessary for the recipient to reserve a
                        //place for tracking whether or not they themselves
                        //revoked a state because they will simply never
                        //broadcast an old state, so they have no use for the
                        //proof-of-revocation
                        // absolute_revocation_preimage: null,
                        // conditional_revocation_sig: null,
                        // conditional_revocation_vout: null,
                    }
                    state.channel_states.push( ch_state );
                    return true;
                },
                prepareHtlcPartOne: async ( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, htlc_locktime ) => {
                    //the minimum htlc amount is 330, because that is the
                    //dust limit for taproot addresses, but in our case
                    //it is even lower: 330 + 240 -- because we use anchor
                    //outputs and thus we always need at least 570 sats as
                    //a minimum for each htlc
                    if ( amnt < 570 ) return console.log( "error: htlc limit too low" );

                    //get requisite data from the recipient
                    if ( !recipients_revhashes ) recipients_revhashes = prompt( 'enter two revhashes created by the recipient' );
                    var data_for_doing_part_three = await hedgehog.prepareHtlcPartTwo( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, htlc_locktime );
                    return data_for_doing_part_three;
                },
                prepareHtlcPartTwo: async ( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, htlc_locktime ) => {
                    //prepare the variables you need to send money via an HTLC
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    console.log( 'i am alice, right?', am_alice );
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var pmt_preimage = null;
                    if ( !pmthash ) pmt_preimage = hedgehog.getPrivkey();
                    if ( pmt_preimage ) pmthash = await hedgehog.sha256( hedgehog.hexToBytes( pmt_preimage ) );
                    //TODO: ensure the following hashes are valid
                    var r_midstate_revhash = recipients_revhashes[ 0 ];
                    var r_reveal_p2_revhash = recipients_revhashes[ 1 ];

                    //get the two versions of the initial HTLC
                    var sender_is_funder = true;
                    var senders_inital_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, pmthash, htlc_locktime );
                    var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_inital_htlc_scripts, 1 );
                    sender_is_funder = false;
                    var recipients_inital_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, !am_sender, pmthash, htlc_locktime );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_inital_htlc_scripts, 1 );
                    console.log( 'senders_initial_htlc_addy:', senders_initial_htlc_addy );
                    console.log( 'recipients_initial_htlc_addy:', recipients_initial_htlc_addy );

                    var sender_is_revoker = true;
                    var recovery_htlc_scripts = hedgehog.getRevocableScripts( chan_id, sender_is_revoker, am_sender, s_recovery_p2_revhash );
                    var [ recovery_htlc_addy ] = hedgehog.getAddressData( recovery_htlc_scripts, 0 );
                    console.log( 'recovery_htlc_scripts:', recovery_htlc_scripts );
                    console.log( 'recovery_htlc_addy:', recovery_htlc_addy );

                    //he also creates a "reveal-part-two htlc"
                    var sender_is_revoker = false;
                    var reveal_htlc_scripts = hedgehog.getRevocableScripts( chan_id, sender_is_revoker, !am_sender, r_reveal_p2_revhash );
                    var [ reveal_htlc_addy ] = hedgehog.getAddressData( reveal_htlc_scripts, 0 );
                    console.log( 'reveal_htlc_addy:', reveal_htlc_addy );

                    //the sender is about to create a recovery-part-one tx, but first he needs to know the txid of the tx that funds the initial htlc
                    if ( am_sender ) var creating_counterparties_version = false;
                    else var creating_counterparties_version = true;
                    sender_is_funder = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ senders_initial_htlc_addy, amnt, sender_is_funder, s_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    if ( am_sender ) var am_sender_for_senders_version = false;
                    else var am_sender_for_senders_version = true;
                    var senders_version_of_tx1 = hedgehog.getTx1( chan_id, am_sender_for_senders_version, htlc_addy_and_amnt );
                    if ( am_sender ) var creating_counterparties_version = true;
                    else var creating_counterparties_version = false;
                    sender_is_funder = false;
                    htlc_addy_and_amnt = [ recipients_initial_htlc_addy, amnt, sender_is_funder, r_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    if ( am_sender ) var am_sender_for_recipients_version = true;
                    else var am_sender_for_recipients_version = false;
                    var recipients_version_of_tx1 = hedgehog.getTx1( chan_id, am_sender_for_recipients_version, htlc_addy_and_amnt );
                    var sender = am_sender === am_alice ? "alice" : "bob";
                    var use_custom_midstate_revhash = true;
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, htlc_addy_and_amnt, use_custom_midstate_revhash, null, pending_htlcs, do_not_delete );
                    var [ _, _, _, _, _, _, _, _, _, recipients_tx2 ] = txs;
                    var senders_version_of_tx1_txid = tapscript.Tx.util.getTxid( senders_version_of_tx1 );
                    var recipients_version_of_tx1_txid = tapscript.Tx.util.getTxid( recipients_version_of_tx1 );
                    // console.log( 'senders_version_of_tx1_txid:', senders_version_of_tx1_txid );
                    // console.log( 'recipients_version_of_tx1_txid:', recipients_version_of_tx1_txid );
                    // console.log( 'senders_version_of_tx1:', JSON.stringify( senders_version_of_tx1 ) );
                    // console.log( 'recipients_version_of_tx1:', JSON.stringify( recipients_version_of_tx1 ) );

                    //the sender creates the recovery-part-one txs which use the recovery path to send the money from the initial htlc to the recovery-part-two htlc
                    var senders_recovery_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( senders_version_of_tx1_txid, 2, amnt, senders_initial_htlc_addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - 240, recovery_htlc_addy ),
                            hedgehog.getVout( 240, "51024e73" ),
                        ],
                    });
                    var recipients_recovery_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( recipients_version_of_tx1_txid, 2, amnt, recipients_initial_htlc_addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - 240, recovery_htlc_addy ),
                            hedgehog.getVout( 240, "51024e73" ),
                        ],
                    });
                    var senders_recovery_part_one_txid = tapscript.Tx.util.getTxid( senders_recovery_part_one_tx );
                    var recipients_recovery_part_one_txid = tapscript.Tx.util.getTxid( recipients_recovery_part_one_tx );
                    console.log( 'recipients_recovery_part_one_txid:', senders_recovery_part_one_txid );
                    console.log( 'recipients_recovery_part_one_txid:', recipients_recovery_part_one_txid );

                    //the sender creates the recovery-part-three txs which take his money back out of the recovery-part-two htlc after a relative timelock of 2 weeks expires
                    if ( am_sender ) var senders_address = am_alice ? tapscript.Address.fromScriptPubKey( [ 1, state.alices_pub ] ) : tapscript.Address.fromScriptPubKey( [ 1, state.bobs_pub ] );
                    else var senders_address = am_alice ? tapscript.Address.fromScriptPubKey( [ 1, state.bobs_pub ] ) : tapscript.Address.fromScriptPubKey( [ 1, state.alices_pub ] );
                    var senders_recovery_part_one_txid = tapscript.Tx.util.getTxid( senders_recovery_part_one_tx );
                    var recipients_recovery_part_one_txid = tapscript.Tx.util.getTxid( recipients_recovery_part_one_tx );
                    var senders_recovery_part_three_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            //TODO: change the relative timelock from 3 to 2016
                            hedgehog.getVin( senders_recovery_part_one_txid, 0, amnt - 240, recovery_htlc_addy, 3 ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - 240, senders_address ),
                            hedgehog.getVout( 240, "51024e73" ),
                        ],
                    });
                    var recipients_recovery_part_three_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            //TODO: change the relative timelock from 3 to 2016
                            hedgehog.getVin( recipients_recovery_part_one_txid, 0, amnt - 240, recovery_htlc_addy, 3 ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - 240, senders_address ),
                            hedgehog.getVout( 240, "51024e73" ),
                        ],
                    });
                    var senders_recovery_part_three_txid = tapscript.Tx.util.getTxid( senders_recovery_part_three_tx );
                    var recipients_recovery_part_three_txid = tapscript.Tx.util.getTxid( recipients_recovery_part_three_tx );
                    console.log( 'senders_recovery_part_three_txid:', senders_recovery_part_three_txid );
                    console.log( 'recipients_recovery_part_three_txid:', recipients_recovery_part_three_txid );

                    //the sender also creates the reveal-part-one txs which use the reveal path to send the money from the initial htlc to the reveal-part-two htlc
                    var senders_reveal_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( senders_version_of_tx1_txid, 2, amnt, senders_initial_htlc_addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - 240, reveal_htlc_addy ),
                            hedgehog.getVout( 240, "51024e73" ),
                        ],
                    });
                    var recipients_reveal_part_one_tx = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( recipients_version_of_tx1_txid, 2, amnt, recipients_initial_htlc_addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt - 240, reveal_htlc_addy ),
                            hedgehog.getVout( 240, "51024e73" ),
                        ],
                    });
                    var senders_reveal_part_one_txid = tapscript.Tx.util.getTxid( senders_reveal_part_one_tx );
                    var recipients_reveal_part_one_txid = tapscript.Tx.util.getTxid( recipients_reveal_part_one_tx );
                    console.log( 'senders_reveal_part_one_txid:', senders_reveal_part_one_txid );
                    console.log( 'recipients_reveal_part_one_txid:', recipients_reveal_part_one_txid );

                    return {
                        pmt_preimage,
                        pmthash,
                        r_midstate_revhash,
                        r_reveal_p2_revhash,
                        s_recovery_p2_revhash,
                        senders_version_of_tx1,
                        recipients_version_of_tx1,
                        senders_recovery_part_one_tx,
                        recipients_recovery_part_one_tx,
                        senders_recovery_part_three_tx,
                        recipients_recovery_part_three_tx,
                        senders_reveal_part_one_tx,
                        recipients_reveal_part_one_tx,
                        recipients_tx2,
                    }
                },
                sendHtlc: async ( chan_id, amnt, htlc_locktime, pmthash, block_when_i_must_force_close ) => {
                    //prepare variables for sending htlc
                    var state = hedgehog.state[ chan_id ];
                    if ( !state ) return console.log( 'error, there is no channel with this chan_id:', chan_id, 'available channels:', Object.keys( hedgehog.state ) );
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var pmt_preimage = null;
                    if ( !pmthash ) pmt_preimage = hedgehog.getPrivkey();
                    if ( pmt_preimage ) pmthash = await hedgehog.sha256( hedgehog.hexToBytes( pmt_preimage ) );
                    var s_midstate_rev_preimage = hedgehog.getPrivkey();
                    var s_midstate_revhash = await hedgehog.sha256( hedgehog.hexToBytes( s_midstate_rev_preimage ) );
                    var s_recovery_p2_rev_preimage = hedgehog.getPrivkey();
                    var s_recovery_p2_revhash = await hedgehog.sha256( hedgehog.hexToBytes( s_recovery_p2_rev_preimage ) );
                    var am_sender = true;
                    var sender_is_funder = true;
                    var sender_is_revoker = true;
                    var data_for_recipient = { chan_id, pmthash, s_midstate_revhash };
                    var recipients_revhashes = await hedgehog.communicateWithUser( data_for_recipient );
                    // var recipients_revhashes = await hedgehog.receiveHtlcPartOne( data_for_recipient );
                    var data_for_doing_part_three = await hedgehog.prepareHtlcPartOne( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, htlc_locktime );

                    //save the data you need for doing part three
                    state.data_for_preparing_htlcs[ pmthash ] = [ "sender_part_two", data_for_doing_part_three ];

                    var {
                        pmthash,
                        r_midstate_revhash,
                        r_reveal_p2_revhash,
                        senders_version_of_tx1,
                        recipients_version_of_tx1,
                        senders_recovery_part_one_tx,
                        recipients_recovery_part_one_tx,
                        senders_recovery_part_three_tx,
                        recipients_recovery_part_three_tx,
                        senders_reveal_part_one_tx,
                        recipients_reveal_part_one_tx,
                    } = data_for_doing_part_three;

                    //prepare a data object to send to the counterparty
                    var data_for_counterparty = {
                        chan_id,
                        amnt,
                        htlc_locktime,
                    }

                    //sign the transactions needed by the counterparty
                    var recipients_inital_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, !sender_is_funder, !am_sender, pmthash, htlc_locktime );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_inital_htlc_scripts, 1 );
                    var sig_on_recipients_reveal_p1_tx = tapscript.Signer.taproot.sign( privkey, recipients_reveal_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 0 ]} ).hex;
                    var senders_inital_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, pmthash, htlc_locktime );
                    var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_inital_htlc_scripts, 1 );
                    var sig_on_senders_reveal_p1_tx = tapscript.Signer.taproot.sign( privkey, senders_reveal_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 0 ]} ).hex;

                    //add the signatures to the data object
                    data_for_counterparty[ "sig_on_recipients_reveal_p1_tx" ] = sig_on_recipients_reveal_p1_tx;
                    data_for_counterparty[ "sig_on_senders_reveal_p1_tx" ] = sig_on_senders_reveal_p1_tx;

                    //send the data object to your counterparty
                    data_for_counterparty[ "pmthash" ] = pmthash;
                    data_for_counterparty[ "s_recovery_p2_revhash" ] = s_recovery_p2_revhash;
                    var reply_from_counterparty = await hedgehog.communicateWithUser( data_for_counterparty );
                    // var reply_from_counterparty = await hedgehog.receiveHtlcPartTwo( data_for_counterparty );

                    //TODO: force close if the following error is thrown
                    if ( !reply_from_counterparty ) return console.log( 'error, your counterparty rejected your htlc' );

                    //prepare variables for validating the counterparty's signatures
                    var { sig_on_senders_recovery_p1_tx, sig_on_recipients_recovery_p1_tx, sig_on_senders_deposit_tx, sig_on_senders_tx2 } = reply_from_counterparty;
                    var recipients_pub = am_alice ? state.bobs_pub : state.alices_pub;

                    //validate the counterparty's recovery signatures
                    var senders_recovery_part_one_sighash = tapscript.Signer.taproot.hash( senders_recovery_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 1 ] }).hex;
                    var sig_on_senders_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_recovery_p1_tx, senders_recovery_part_one_sighash, recipients_pub );
                    var recipients_recovery_part_one_sighash = tapscript.Signer.taproot.hash( recipients_recovery_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ] }).hex;
                    var sig_on_recipients_recovery_p1_tx_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_recovery_p1_tx, recipients_recovery_part_one_sighash, recipients_pub );

                    //validate the counterparty's sigs on tx1 and tx2
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ _, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var deposit_sighash = tapscript.Signer.taproot.hash( senders_version_of_tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var sig_on_deposit_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_deposit_tx, deposit_sighash, recipients_pub );
                    var creating_counterparties_version = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ senders_initial_htlc_addy, amnt, sender_is_funder, s_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    var sender_for_tx1 = am_alice ? "bob" : "alice";
                    var am_alice_for_tx1 = am_alice ? false : true;
                    var use_custom_midstate_revhash = true;
                    var am_sender_for_script_override = false;
                    var uses_htlc_for_script_override = true;
                    var sender_is_funder_for_script_override = true;
                    var creating_counterparties_version_for_script_override = false;
                    var midstate_scripts_override = hedgehog.getMidstateScripts( chan_id, am_sender_for_script_override, s_midstate_revhash, uses_htlc_for_script_override, sender_is_funder_for_script_override, creating_counterparties_version_for_script_override );
                    var midstate_tree_override = hedgehog.getAddressData( midstate_scripts_override, 0 )[ 1 ];
                    var use_custom_midstate_revhash = null;
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice_for_tx1, am_sender, amnt, sender_for_tx1, htlc_addy_and_amnt, use_custom_midstate_revhash, midstate_scripts_override, pending_htlcs, do_not_delete );
                    var [ _, _, _, _, _, _, _, _, senders_tx1, senders_tx2 ] = txs;
                    var senders_pub = state.alices_pub;
                    if ( !am_alice ) var senders_pub = state.bobs_pub;
                    if ( senders_tx2.vout.length < 3 ) {
                        senders_tx2.vout[ 1 ].scriptPubKey = [ 1, senders_pub ];
                    } else {
                        senders_tx2.vout[ 1 ].scriptPubKey = [ 1, state.alices_pub ];
                        senders_tx2.vout[ 2 ].scriptPubKey = [ 1, state.bobs_pub ];
                    }
                    var senders_tx2_sighash = tapscript.Signer.taproot.hash( senders_tx2, 0, {extension: midstate_tree_override[ 0 ] }).hex;
                    var sig_on_senders_tx2_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_tx2, senders_tx2_sighash, recipients_pub );

                    //TODO: force close if the following error is thrown
                    if ( !sig_on_senders_recovery_p1_tx_is_valid || !sig_on_recipients_recovery_p1_tx_is_valid || !sig_on_deposit_is_valid || !sig_on_senders_tx2_is_valid ) return console.log( 'error, your counterparty sent you invalid signatures' );

                    //save the data provided by the counterparty
                    state.data_for_preparing_htlcs[ pmthash ] = [ "sender_part_three", {
                        ...data_for_doing_part_three,
                        sig_on_senders_recovery_p1_tx,
                        sig_on_recipients_recovery_p1_tx,
                    }];

                    //sign the recipients version of tx2
                    var recipients_inital_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, !sender_is_funder, !am_sender, pmthash, htlc_locktime );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_inital_htlc_scripts, 1 );
                    var creating_counterparties_version = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ recipients_initial_htlc_addy, amnt, !sender_is_funder, r_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    var sender = "bob";
                    var use_custom_midstate_revhash = true;
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender, amnt, sender, htlc_addy_and_amnt, use_custom_midstate_revhash, null, pending_htlcs, do_not_delete );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    //getTxData always returns 10 items. It also returns two additional items if a conditional revocation was needed on a prior state, so in that cirucmstance we also grab those two additional items so that we can sign them
                    if ( txs.length > 10 ) {
                        var conditional_revocation_tx = txs[ 10 ];
                        var prev_tx1 = txs[ 11 ];
                    }

                    //ensure tx1 is the same now as it was before
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    var prev_tx1_txid = tapscript.Tx.util.getTxid( recipients_version_of_tx1 );
                    console.log( 'tx1_txid:', tx1_txid );
                    console.log( 'prev_tx1_txid:', prev_tx1_txid );

                    //sign everything
                    var to_midstate_sig = tapscript.Signer.taproot.sign( privkey, tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var finalizer_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, {extension: midstate_tree[ 0 ] }).hex;

                    //update your state
                    var sender = am_alice ? "alice" : "bob";
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    var pending_htlcs = [];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    pending_htlcs.push({
                        pmt_preimage,
                        pmthash,
                        s_midstate_rev_preimage,
                        s_midstate_revhash,
                        s_recovery_p2_rev_preimage,
                        s_recovery_p2_revhash,
                        recipients_rev_preimages: null,
                        recipients_revhashes,
                        htlc_locktime,
                        amnt,
                        sender: am_alice ? "alice" : "bob",
                        txid_to_check: tapscript.Tx.util.getTxid( senders_version_of_tx1 ),
                        block_when_i_must_force_close,
                    });
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: 0,
                        tx1: tapscript.Tx.encode( tx1 ).hex,
                        absolute_revocation_hash,
                        absolute_revocation_preimage: null,
                        conditional_revocation_sig: null,
                        conditional_revocation_vout: null,
                        added_htlc: true,
                        pending_htlcs,
                    }
                    state.channel_states.push( ch_state );

                    //generate the hash you want your counterparty to use when they next send you money
                    var revocation_preimage = hedgehog.getPrivkey();
                    var revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_preimage ) );
                    if ( am_alice ) {
                        state.alices_revocation_preimages.push( revocation_preimage );
                        state.alices_revocation_hashes.push( revocation_hash );
                    } else {
                        state.bobs_revocation_preimages.push( revocation_preimage );
                        state.bobs_revocation_hashes.push( revocation_hash );
                    }

                    //send your counterparty the data they need to validate the new state
                    var my_revocation_preimages = state[ "alices_revocation_preimages" ];
                    if ( !am_alice ) my_revocation_preimages = state[ "bobs_revocation_preimages" ];
                    var obj = {
                        to_midstate_sig,
                        finalizer_sig,
                        chan_id,
                        revocation_hash,
                        pmthash,
                        revocation_of_previous_state: my_revocation_preimages[ my_revocation_preimages.length - 2 ],
                    }

                    //send the data to your counterparty and get their revocation preimage
                    var data_from_recipient = await hedgehog.communicateWithUser( obj );
                    // var data_from_recipient = await hedgehog.receiveHtlcPartThree( obj );

                    //validate and store it
                    var counterpartys_revhashes = state.alices_revocation_hashes;
                    var counterpartys_rev_preimages = state.alices_revocation_preimages;
                    if ( am_alice ) {
                        counterpartys_revhashes = state.bobs_revocation_hashes;
                        counterpartys_rev_preimages = state.bobs_revocation_preimages;
                    }
                    //TODO: force close if the following errors are thrown
                    if ( counterpartys_revhashes.length && !data_from_recipient.hasOwnProperty( "revocation_of_previous_state" ) ) return console.log( 'your counterparty tried to cheat you by not sending requisite data' );
                    if ( counterpartys_revhashes.length ) {
                        var revocation_of_previous_state = data_from_recipient.revocation_of_previous_state;
                        //if your counterparty was the last person to send money, and he did so in a state update that did *not* include an htlc, then he will have a revocation hash that he should *not* revoke here; you will use it next time you send him money, and if he revokes it here, he won't be able to safely receive that money; this also applies if 
                        var num_of_hashes_behind = 2;
                        var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                        if ( ( ( latest_state.from === "bob" && am_alice ) || ( latest_state.from === "alice" && !am_alice ) ) && !latest_state.uses_htlc ) num_of_hashes_behind = 2;
                        var expected_revhash = counterpartys_revhashes[ counterpartys_revhashes.length - num_of_hashes_behind ];
                        if ( typeof revocation_of_previous_state !== "string" ) return console.log( 'error, your counterparty tried to cheat you by sending invalid data' );
                        var actual_revhash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_of_previous_state ) );
                        if ( actual_revhash !== expected_revhash ) return console.log( `error, your counterparty tried to cheat you by refusing to revoke the previous state; the rev_preimage they sent you: ${revocation_of_previous_state} | its actual hash: ${actual_revhash} | the revhash you wanted: ${expected_revhash} | all your counterpartys revhashes: ${counterpartys_revhashes}` );

                        //add your counterparty's revocation preimage to your state unless you already
                        //have it
                        if ( !counterpartys_rev_preimages.includes( revocation_of_previous_state ) ) counterpartys_rev_preimages.push( revocation_of_previous_state );
                    }
                    return pmthash;
                },
                receiveHtlcPartOne: async data_from_sender => {
                    //prepare revocation hashes for use in the upcoming state update
                    var { chan_id, pmthash, s_midstate_revhash } = data_from_sender;
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    var midstate_rev_preimage = hedgehog.getPrivkey();
                    var midstate_revhash = await hedgehog.sha256( hedgehog.hexToBytes( midstate_rev_preimage ) );
                    var reveal_p2_rev_preimage = hedgehog.getPrivkey();
                    var reveal_p2_revhash = await hedgehog.sha256( hedgehog.hexToBytes( reveal_p2_rev_preimage ) );
                    var recipients_preimages = [ midstate_rev_preimage, reveal_p2_rev_preimage ];
                    var recipients_revhashes = [ midstate_revhash, reveal_p2_revhash ];
                    hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ] = [ "recipient_part_one", recipients_revhashes, recipients_preimages, s_midstate_revhash ];
                    return recipients_revhashes;
                },
                receiveHtlcPartTwo: async data_from_sender => {
                    //process the data from the sender
                    var { chan_id, amnt, sig_on_recipients_reveal_p1_tx, sig_on_senders_reveal_p1_tx, pmthash, s_recovery_p2_revhash, htlc_locktime } = data_from_sender;
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    //TODO: force close if the following errors are thrown
                    if ( !hedgehog.state.hasOwnProperty( chan_id ) ) return console.log( 'error, counterparty tried to cheat you by providing wrong chan id' );
                    if ( hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 0 ] !== "recipient_part_one" ) return console.log( 'error, counterparty tried to cheat you by providing wrong data for the current part of an htlc transfer' );

                    //prepare the variables needed for this state update
                    var state = hedgehog.state[ chan_id ];
                    var am_sender = false;
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var senders_pub = am_alice ? state.bobs_pub : state.alices_pub;
                    var sender_is_funder = true;
                    var sender_is_revoker = true;

                    //prepare the htlc
                    var recipients_revhashes = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 1 ];
                    var recipients_rev_preimages = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 2 ];
                    var s_midstate_revhash = hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 3 ];
                    var data_for_doing_part_three = await hedgehog.prepareHtlcPartTwo( chan_id, amnt, pmthash, am_sender, recipients_revhashes, s_recovery_p2_revhash, s_midstate_revhash, htlc_locktime );
                    var { recipients_version_of_tx1, recipients_reveal_part_one_tx, senders_version_of_tx1, senders_recovery_part_one_tx, senders_recovery_part_three_tx, senders_reveal_part_one_tx, recipients_recovery_part_one_tx } = data_for_doing_part_three;

                    //ensure you can move the money from the initial htlc if you learn the preimage
                    var recipients_inital_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, !sender_is_funder, am_sender, pmthash, htlc_locktime );
                    var [ recipients_initial_htlc_addy, recipients_initial_htlc_tree, recipients_initial_htlc_cblock ] = hedgehog.getAddressData( recipients_inital_htlc_scripts, 1 );
                    var recipients_reveal_part_one_sighash = tapscript.Signer.taproot.hash( recipients_reveal_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 0 ] }).hex;
                    var sig_on_recipients_reveal_p1_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_recipients_reveal_p1_tx, recipients_reveal_part_one_sighash, senders_pub );

                    //ensure the same is true even if the sender is the one who puts the money into the inital htlc
                    var senders_inital_htlc_scripts = hedgehog.getInitialHTLCScripts( chan_id, sender_is_funder, am_sender, pmthash, htlc_locktime );
                    var [ senders_initial_htlc_addy, senders_initial_htlc_tree, senders_initial_htlc_cblock ] = hedgehog.getAddressData( senders_inital_htlc_scripts, 1 );
                    var senders_reveal_part_one_sighash = tapscript.Signer.taproot.hash( senders_reveal_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 0 ] }).hex;
                    var sig_on_senders_reveal_p1_is_valid = await nobleSecp256k1.schnorr.verify( sig_on_senders_reveal_p1_tx, senders_reveal_part_one_sighash, senders_pub );

                    //TODO: force close if the following error is thrown
                    if ( !sig_on_recipients_reveal_p1_is_valid || !sig_on_senders_reveal_p1_is_valid )  return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );

                    //sign the transactions that let the sender recover his money if you never learn the preimage
                    var sig_on_senders_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, senders_recovery_part_one_tx, 0, {extension: senders_initial_htlc_tree[ 1 ]} ).hex;
                    var sig_on_recipients_recovery_p1_tx = tapscript.Signer.taproot.sign( privkey, recipients_recovery_part_one_tx, 0, {extension: recipients_initial_htlc_tree[ 1 ]} ).hex;
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ channel, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var sig_on_senders_deposit_tx = tapscript.Signer.taproot.sign( privkey, senders_version_of_tx1, 0, {extension: channel_tree[ 0 ]} ).hex;

                    //sign the sender's version of tx2 as well
                    var creating_counterparties_version = true;
                    var sender_of_htlc = ( am_sender === am_alice ) ? "alice" : "bob";
                    var htlc_addy_and_amnt = [ senders_initial_htlc_addy, amnt, sender_is_funder, s_midstate_revhash, creating_counterparties_version, sender_of_htlc ];
                    var sender = am_alice ? "alice" : "bob";
                    var am_sender_for_tx1 = true;
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    var do_not_delete = true;
                    var txs = hedgehog.getTxData( chan_id, am_alice, am_sender_for_tx1, amnt, sender, htlc_addy_and_amnt, null, null, pending_htlcs, do_not_delete );
                    var [ recipients_new_balance, channel_tree, channel_cblock, midstate_tree, midstate_cblock, amnt, conditional_revocation_needed, absolute_revocation_hash, tx1, tx2 ] = txs;
                    tx2.vin[ 0 ].prevout.scriptPubKey = tx1.vout[ 0 ].scriptPubKey;
                    var senders_tx2_sighash = tapscript.Signer.taproot.hash( tx2, 0, {extension: midstate_tree[ 0 ] }).hex;
                    var sig_on_senders_tx2 = tapscript.Signer.taproot.sign( privkey, tx2, 0, {extension: midstate_tree[ 0 ]} ).hex;

                    hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ] = [ "recipient_part_two", {recipients_rev_preimages, recipients_revhashes, s_midstate_revhash, data_for_doing_part_three, part_twos_data_from_sender: data_from_sender, recipients_inital_htlc_scripts, recipients_new_balance} ];

                    //return the signatures so you can provide them to the sender
                    return {
                        sig_on_senders_recovery_p1_tx,
                        sig_on_recipients_recovery_p1_tx,
                        sig_on_senders_deposit_tx,
                        sig_on_senders_tx2,
                    }
                },
                receiveHtlcPartThree: async data_from_sender => {
                    //process the data from the sender
                    var { to_midstate_sig, finalizer_sig, chan_id, revocation_hash, pmthash, revocation_of_previous_state } = data_from_sender;
                    var absolute_revocation_hash = revocation_hash;
                    var chan_id = data_from_sender.chan_id;
                    if ( chan_id.startsWith( "a_" ) ) chan_id = "b_" + chan_id.substring( 2 );
                    else chan_id = "a_" + chan_id.substring( 2 );
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    var counterpartys_revhashes = state.alices_revocation_hashes;
                    var counterpartys_rev_preimages = state.alices_revocation_preimages;
                    if ( am_alice ) {
                        counterpartys_revhashes = state.bobs_revocation_hashes;
                        counterpartys_rev_preimages = state.bobs_revocation_preimages;
                    }
                    var expected_revhash = counterpartys_revhashes[ counterpartys_revhashes.length - 1 ];
                    //TODO: force close if the following errors are thrown
                    if ( typeof revocation_of_previous_state !== "string" ) return console.log( 'error, your counterparty tried to cheat you by sending invalid data' );
                    var actual_revhash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_of_previous_state ) );
                    if ( actual_revhash !== expected_revhash ) return console.log( 'error, your counterparty tried to cheat you by refusing to revoke the previous state' );
                    if ( !hedgehog.state.hasOwnProperty( chan_id ) ) return console.log( 'error, counterparty tried to cheat you by providing wrong chan id' );
                    if ( hedgehog.state[ chan_id ].data_for_preparing_htlcs[ pmthash ][ 0 ] !== "recipient_part_two" ) return console.log( 'error, counterparty tried to cheat you by providing wrong data for the current part of an htlc transfer' );

                    //add your counterparty's revocation preimage to your state unless you already
                    //have it
                    if ( !counterpartys_rev_preimages.includes( revocation_of_previous_state ) ) counterpartys_rev_preimages.push( revocation_of_previous_state );

                    //do not allow the sender to reuse a revocation hash
                    var revocation_hash = data_from_sender.revocation_hash;
                    if ( counterpartys_revhashes.includes( revocation_hash ) ) return;

                    //prepare the variables necessary for validating the new state
                    var am_sender = false;
                    var sender = am_alice ? "bob" : "alice";
                    var senders_pub = am_alice ? state.bobs_pub : state.alices_pub;
                    var pmthash = data_from_sender.pmthash;

                    //get data from previous part of process
                    var data_from_part_two = state.data_for_preparing_htlcs[ pmthash ];
                    var amnt = data_from_part_two[ 1 ].part_twos_data_from_sender.amnt;
                    var htlc_locktime = data_from_part_two[ 1 ].part_twos_data_from_sender.htlc_locktime;
                    var recipients_new_balance = data_from_part_two[ 1 ].recipients_new_balance;
                    var recipients_inital_htlc_scripts = data_from_part_two[ 1 ].recipients_inital_htlc_scripts;
                    var recipients_rev_preimages = data_from_part_two[ 1 ].recipients_rev_preimages;
                    var recipients_revhashes = data_from_part_two[ 1 ].recipients_revhashes;
                    var s_midstate_revhash = data_from_part_two[ 1 ].s_midstate_revhash;
                    var data_for_doing_part_three = data_from_part_two[ 1 ].data_for_doing_part_three;
                    var { recipients_version_of_tx1, recipients_reveal_part_one_tx, senders_version_of_tx1, senders_recovery_part_one_tx, senders_recovery_part_three_tx, senders_reveal_part_one_tx, recipients_recovery_part_one_tx, r_midstate_revhash, recipients_tx2, s_recovery_p2_revhash } = data_for_doing_part_three;

                    //ensure you can broadcast tx1
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ channel, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var deposit_sighash = tapscript.Signer.taproot.hash( recipients_version_of_tx1, 0, {extension: channel_tree[ 0 ] }).hex;
                    var sig_on_deposit_is_valid = await nobleSecp256k1.schnorr.verify( to_midstate_sig, deposit_sighash, senders_pub );
                    //TODO: force close if the following error is thrown
                    if ( !sig_on_deposit_is_valid )  return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );

                    //ensure you can broadcast tx2
                    var uses_htlc = true;
                    var sender_is_funding_htlc = false;
                    var recipients_midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, r_midstate_revhash, uses_htlc, sender_is_funding_htlc );
                    var recipients_midstate_tree = hedgehog.getAddressData( recipients_midstate_scripts, 0 )[ 1 ];
                    var tx2_sighash = tapscript.Signer.taproot.hash( recipients_tx2, 0, {extension: recipients_midstate_tree[ 0 ] }).hex;
                    var sig_on_tx2_is_valid = await nobleSecp256k1.schnorr.verify( finalizer_sig, tx2_sighash, senders_pub );
                    //TODO: force close if the following error is thrown
                    if ( !sig_on_deposit_is_valid )  return console.log( 'error, counterparty tried to cheat you by providing invalid signatures' );

                    //store the revocation data given by your counterparty for future use
                    if ( am_alice ) state.bobs_revocation_hashes.push( revocation_hash );
                    else state.alices_revocation_hashes.push( revocation_hash );

                    //update your state
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    var pending_htlcs = [];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    pending_htlcs.push({
                        pmt_preimage: null,
                        pmthash,
                        s_midstate_rev_preimage: null,
                        s_midstate_revhash,
                        s_recovery_p2_rev_preimage: null,
                        s_recovery_p2_revhash,
                        recipients_rev_preimages,
                        recipients_revhashes,
                        htlc_locktime,
                        amnt,
                        sender: am_alice ? "bob" : "alice",
                        txid_to_check: tapscript.Tx.util.getTxid( senders_version_of_tx1 ),
                    });
                    var ch_state = {
                        from: sender,
                        amnt: recipients_new_balance,
                        amnt_sent: 0,
                        to_midstate_sig,
                        finalizer_sig,
                        tx1: tapscript.Tx.encode( recipients_version_of_tx1 ).hex,
                        absolute_revocation_hash: s_midstate_revhash,
                        added_htlc: true,
                        pending_htlcs,
                    }
                    state.channel_states.push( ch_state );

                    //revoke all old states
                    var my_revocation_preimages = state.alices_revocation_preimages;
                    var my_revocation_hashes = state.alices_revocation_hashes;
                    if ( !am_alice ) {
                        my_revocation_preimages = state.bobs_revocation_preimages;
                        my_revocation_hashes = state.bobs_revocation_hashes;
                    }
                    var data_for_sender = {}
                    if ( my_revocation_preimages.length > 1 ) data_for_sender[ "revocation_of_previous_state" ] = my_revocation_preimages[ my_revocation_preimages.length - 2 ];
                    return data_for_sender;
                },
                findPreimage: async ( chan_id, pmthash ) => {
                    return new Promise( resolve => {
                        var channel_states = hedgehog.state[ chan_id ].channel_states;
                        channel_states.every( state => {
                            if ( state.pending_htlcs ) {
                                state.pending_htlcs.every( htlc => {
                                    if ( htlc.pmthash === pmthash && htlc.pmt_preimage ) resolve( htlc.pmt_preimage );
                                    return true;
                                });
                            }
                            return true;
                        });
                    });
                },
                resolveHtlcAsSender: async ( chan_id, preimage ) => {
                    console.log( chan_id, preimage );
                },
                resolveHtlcAsRecipient: async ( chan_id, pmthash ) => {

                },
                forceClose: async ( chan_id, txid, txdata, try_to_cheat ) => {
                    //prepare variables needed for force closing the channel
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    var privkey = am_alice ? state.alices_priv : state.bobs_priv;
                    var pubkey = hedgehog.getPubkey( privkey );
                    var reversed = JSON.parse( JSON.stringify( state.channel_states ) );
                    reversed = reversed.reverse();

                    //if you detected that your counterparty force closed and broadcasted
                    //tx1, check if you have a later state or the ability to broadcast a
                    //justice transaction or a disappearance transaction, and if you can
                    //do so, do it
                    if ( txid ) {
                        var senders_pub = am_alice ? state.bobs_pub : state.alices_pub;

                        //look for a revoked state state with that txid
                        var revoked_state = null;
                        var tx1 = null;
                        var revhash = null;
                        reversed.every( ( item, index ) => {
                            var txid_to_check = tapscript.Tx.util.getTxid( item.tx1 );
                            if ( txid_to_check === txid ) {
                                var this_state_is_revoked = item.absolute_revocation_preimage || item.conditional_revocation_sig;
                                if ( this_state_is_revoked ) revoked_state = item;
                                else {
                                    tx1 = item.tx1;
                                    revhash = item.absolute_revocation_hash;
                                }
                                return;
                            }
                            return true;
                        });

                        //if you could not find a revoked state with that txid, that means your counterparty
                        //is trying to broadcast the latest state, which is good. But if they disappear
                        //you should be ready to broadcast the disappearance tx, so prepare to do that
                        if ( !revoked_state ) {
                            //prepare a tx that sweeps the funds if your counterparty disappeared
                            var txfee = 500;
                            var disappearance_tx = tapscript.Tx.create({
                                version: 2,
                                vin: [{
                                    txid,
                                    vout: 0,
                                    prevout: tapscript.Tx.decode( tx1 ).vout[ 0 ],
                                    //TODO: change the 6 to 2026
                                    sequence: 6,
                                }],
                                vout: [{
                                    value: Number( tapscript.Tx.decode( tx1 ).vout[ 0 ].value ) - txfee,
                                    scriptPubKey: [ 1, pubkey ],
                                }],
                            });

                            //sign the disappearance tx
                            var am_sender = true;
                            var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, revhash );
                            var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 1 );
                            var mysig = tapscript.Signer.taproot.sign( privkey, disappearance_tx, 0, {extension: midstate_tree[ 1 ]} ).hex;
                            disappearance_tx.vin[ 0 ].witness = [ mysig, midstate_scripts[ 1 ], midstate_cblock ];

                            //broadcast the disappearance tx
                            return { disappearance_tx }
                        }

                        //if you found a revoked state and it was *fully* revoked, broadcast a justice transaction
                        var am_sender = true;
                        var revhash = revoked_state.absolute_revocation_hash;
                        var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, revhash );
                        var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 0 );
                        if ( revoked_state.absolute_revocation_preimage ) {
                            //prepare variables needed in the justice tx
                            var preimage = revoked_state.absolute_revocation_preimage;
                            var txfee = 500;

                            //prepare the justice tx
                            var justice_tx = tapscript.Tx.create({
                                version: 2,
                                vin: [{
                                    txid: tapscript.Tx.util.getTxid( revoked_state[ "tx1" ] ),
                                    vout: 0,
                                    prevout: tapscript.Tx.decode( revoked_state[ "tx1" ] ).vout[ 0 ],
                                }],
                                vout: [{
                                    value: tapscript.Tx.decode( revoked_state[ "tx1" ] ).vout[ 0 ].value - txfee,
                                    scriptPubKey: [ 1, pubkey ],
                                }],
                            });

                            //sign the justice tx
                            var midstate_cblock = hedgehog.getAddressData( midstate_scripts, 2 );
                            var mysig = tapscript.Signer.taproot.sign( privkey, justice_tx, 0, {extension: midstate_tree[ 2 ]} ).hex;
                            justice_tx.vin[ 0 ].witness = [ mysig, preimage, midstate_scripts[ 2 ], midstate_cblock ];

                            //broadcast the justice tx
                            console.log( 'broadcast this justice transaction:' );
                            console.log( tapscript.Tx.encode( justice_tx ).hex );
                            return { justice_tx }
                        }

                        //if you have a revoked transaction that was *not* absolutely revoked but only conditionally revoked, prepare a transaction updating the state to the latest state
                        var alt_tx2 = tapscript.Tx.create({
                            version: 3,
                            vin: [{
                                txid: tapscript.Tx.util.getTxid( revoked_state[ "tx1" ] ),
                                vout: 0,
                                prevout: tapscript.Tx.decode( revoked_state[ "tx1" ] ).vout[ 0 ],
                            }],
                            vout: revoked_state[ "conditional_revocation_vout" ],
                        });

                        //get all sigs required to broadcast it
                        var revsig = revoked_state[ "conditional_revocation_sig" ];
                        var mysig = tapscript.Signer.taproot.sign( privkey, alt_tx2, 0, {extension: midstate_tree[ 0 ]} ).hex;
                        alt_tx2.vin[ 0 ].witness = [ mysig, revsig, midstate_scripts[ 0 ], midstate_cblock ];
                        if ( am_alice ) alt_tx2.vin[ 0 ].witness = [ revsig, mysig, midstate_scripts[ 0 ], midstate_cblock ];

                        //get utxos to cover the fees
                        var addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], hedgehog.network );
                        if ( !txdata ) {
                            console.log( 'send 500 sats into this address:' );
                            console.log( addy );
                            var txid2 = prompt( `send 500 sats into the address in your console and enter the txid` );
                            if ( !txid2 ) return;
                            var vout2 = Number( prompt( `and the vout` ) );
                            var amnt2 = Number( prompt( `and the amount` ) );
                        } else {
                            var [ txid2, vout2, amnt2 ] = txdata;
                        }

                        //prepare a fee-paying tx
                        var tx2_txid = tapscript.Tx.util.getTxid( alt_tx2 );
                        var tx2_fee = tapscript.Tx.create({
                            version: 3,
                            vin: [
                                hedgehog.getVin( tx2_txid, 0, 240, "51024e73" ),
                                hedgehog.getVin( txid2, vout2, amnt2, addy ),
                            ],
                            vout: [{
                                value: 0,
                                scriptPubKey: [ "OP_RETURN", "" ],
                            }],
                        });
                        var fee2_sig = tapscript.Signer.taproot.sign( privkey, tx2_fee, 1 ).hex;
                        tx2_fee.vin[ 1 ].witness = [ fee2_sig ];

                        //broadcast the transactions
                        return { alt_tx2, tx2_fee }
                    }

                    //all the code after this point is for preparing and broadcasting the latest state
                    //m_r_s = most recent state where I received money
                    var m_r_s = null;
                    var counterparty = am_alice ? "bob" : "alice";
                    reversed.every( ( item, index ) => {
                        if ( item.from === counterparty ) {
                            m_r_s = item;
                            return;
                        }
                        return true;
                    });

                    //if try_to_cheat is enabled, then instead of broadcasting
                    //the latest state, we broadcast the one where we first received
                    //money
                    if ( try_to_cheat ) {
                        state.channel_states.every( ( item, index ) => {
                            if ( item.from === counterparty ) {
                                m_r_s = item;
                                return;
                            }
                            return true;
                        });
                    }

                    //prepare tx1
                    var channel_scripts = hedgehog.getChannelScripts( chan_id );
                    var [ channel, channel_tree, channel_cblock ] = hedgehog.getAddressData( channel_scripts, 0 );
                    var total_in_channel = hedgehog.getBalances( chan_id ).reduce( ( accumulator, currentValue ) => accumulator + currentValue, 0 );
                    var tx1 = tapscript.Tx.decode( m_r_s.tx1 );
                    //in order to save space in the database, I don't store the prevout of tx1, so here I add it back in
                    tx1.vin[ 0 ].prevout = {
                        value: total_in_channel,
                        scriptPubKey: tapscript.Address.toScriptPubKey( channel ),
                    }

                    //sign tx1
                    var recipients_to_midstate_sig = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: channel_tree[ 0 ] }).hex;
                    var senders_to_midstate_sig = m_r_s.to_midstate_sig;
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ senders_to_midstate_sig, recipients_to_midstate_sig, channel_scripts[ 0 ], channel_cblock ];
                    else tx1.vin[ 0 ].witness = [ recipients_to_midstate_sig, senders_to_midstate_sig, channel_scripts[ 0 ], channel_cblock ];

                    //prepare tx2
                    var am_sender = false;
                    var tx1_txid = tapscript.Tx.util.getTxid( m_r_s.tx1 );
                    var revhash = m_r_s.absolute_revocation_hash;
                    var midstate_scripts = hedgehog.getMidstateScripts( chan_id, am_sender, revhash );
                    var [ midstate, midstate_tree, midstate_cblock ] = hedgehog.getAddressData( midstate_scripts, 0 );
                    var amnt = m_r_s.amnt;
                    var tx2 = hedgehog.getTx2( chan_id, am_sender, tx1_txid, midstate, amnt );

                    //sign tx2
                    var recipients_finalizer_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: midstate_tree[ 0 ] }).hex;
                    var senders_finalizer_sig = m_r_s.finalizer_sig;
                    if ( am_alice ) tx2.vin[ 0 ].witness = [ senders_finalizer_sig, recipients_finalizer_sig, midstate_scripts[ 0 ], midstate_cblock ];
                    else tx2.vin[ 0 ].witness = [ recipients_finalizer_sig, senders_finalizer_sig, midstate_scripts[ 0 ], midstate_cblock ];

                    //prepare a tx that pays the fee for tx1
                    var addy = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], hedgehog.network );
                    if ( !txdata ) {
                        console.log( 'send 1000 sats into this address:' );
                        console.log( addy );
                        var txid2 = prompt( `send 1000 sats into the address in your console and enter the txid` );
                        if ( !txid2 ) return;
                        var vout2 = Number( prompt( `and the vout` ) );
                        var amnt2 = Number( prompt( `and the amount` ) );
                    } else {
                        var [ txid2, vout2, amnt2 ] = txdata;
                    }
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    var tx1_fee = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( tx1_txid, 1, 240, "51024e73" ),
                            hedgehog.getVin( txid2, vout2, amnt2, addy ),
                        ],
                        vout: [
                            hedgehog.getVout( amnt2 - 250, addy ),
                        ],
                    });
                    var fee_sig = tapscript.Signer.taproot.sign( privkey, tx1_fee, 1 ).hex;
                    tx1_fee.vin[ 1 ].witness = [ fee_sig ];

                    //prepare a tx that pays the fee for tx2
                    var tx1_fee_txid = tapscript.Tx.util.getTxid( tx1_fee );
                    var tx2_txid = tapscript.Tx.util.getTxid( tx2 );
                    var tx2_fee = tapscript.Tx.create({
                        version: 3,
                        vin: [
                            hedgehog.getVin( tx2_txid, 0, 240, "51024e73" ),
                            hedgehog.getVin( tx1_fee_txid, 0, amnt2 - 250, addy ),
                        ],
                        vout: [{
                            value: 0,
                            scriptPubKey: [ "OP_RETURN", "" ],
                        }],
                    });
                    var fee2_sig = tapscript.Signer.taproot.sign( privkey, tx2_fee, 1 ).hex;
                    tx2_fee.vin[ 1 ].witness = [ fee2_sig ];

                    //broadcast everything
                    return { tx1, tx1_fee, tx2, tx2_fee }
                },
                runBasicTests: async ( test_on_regtest, b_force, disappearance, a_force, justice ) => {
                    //prepare a keypair
                    var privkey = hedgehog.getPrivkey();
                    var pubkey = hedgehog.getPubkey( privkey );
                    var preimage = hedgehog.getPrivkey();
                    var hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    hedgehog.keypairs[ pubkey ] = {privkey, preimage}

                    //test opening a channel
                    console.log( 'testing opening a channel...' );
                    var bobs_pubkey = Object.keys( hedgehog.keypairs )[ 0 ];
                    var bobs_hash = await hedgehog.sha256( hedgehog.hexToBytes( hedgehog.keypairs[ bobs_pubkey ].preimage ) );
                    var bobs_pubkey_and_hash = [ bobs_pubkey, bobs_hash ];
                    var txdata = null;
                    var txdata2 = null;
                    //txdata2 is used later when testing force closures later. You can test them on regtest or testnet by commenting out the two lines below. If you do, then the openChannel command will prompt you to manually enter a txid, vout, and amount for your funding transaction, and the forceClose command will promt you to manually enter similar data for a transaction that pays the fee for your force closures.
                    if ( !test_on_regtest ) {
                        txdata = [ "a".repeat( 64 ), 0, 10_000 ];
                        txdata2 = [ "a".repeat( 64 ), 0, 1_000 ];
                    }
                    var show_logs = !txdata2;
                    var data_for_bob = await hedgehog.openChannel( bobs_pubkey_and_hash, txdata );
                    var channel_is_valid = await hedgehog.openChannel( null, null, data_for_bob );
                    console.log( 'channel_is_valid, right?', channel_is_valid );
                    console.log( `alice's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 1 ]}` );
                    var test0 = "failed";
                    if ( channel_is_valid ) test0 = "passed";

                    //test sending from bob to alice
                    console.log( 'testing a payment of 8000 sats from bob to alice...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 8_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `bob's payment to alice worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test1 = "failed";
                    if ( they_agree ) test1 = "passed";

                    //test sending from alice to bob
                    console.log( 'testing a payment of 2000 sats from alice to bob...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's payment to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test2 = "failed";
                    if ( they_agree ) test2 = "passed";

                    //test a second consecutive payment from alice to bob
                    console.log( 'testing a second payment from alice to bob of 3_000 sats...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 3_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's second payment to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test3 = "failed";
                    if ( they_agree ) test3 = "passed";

                    //test two payments from bob to alice, where alice does not notice the first
                    console.log( 'testing two payments from bob to alice of 2_000 sats apiece...' );
                    console.log( 'note that alice will not notice the first one...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    // await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `bob's two payments to alice worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test4 = "failed";
                    if ( they_agree ) test4 = "passed";

                    //test two payments from alice to bob, where bob does not notice the first
                    console.log( 'testing two payments from alice to bob of 2_000 sats apiece...' );
                    console.log( 'note that bob will not notice the first one...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    // await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's two payments to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test5 = "failed";
                    if ( they_agree ) test5 = "passed";

                    //test two payments from bob to alice, where alice notices both
                    console.log( 'testing two payments from bob to alice of 2_000 sats apiece...' );
                    console.log( 'note that alice will notice both...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( b_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `bob's two payments to alice worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test6 = "failed";
                    if ( they_agree ) test6 = "passed";

                    //test three payments from alice to bob, where bob notices all of them
                    console.log( 'testing three payments from alice to bob of 2_000 sats apiece...' );
                    console.log( 'note that bob will notice all of them...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var data_for_recipient = await hedgehog.send( a_chan_id, 2_000 );
                    await hedgehog.receive( data_for_recipient );
                    var what_alice_thinks_the_balances_are = hedgehog.getBalances( a_chan_id );
                    var what_bob_thinks_the_balances_are = hedgehog.getBalances( b_chan_id );
                    var they_agree = ( JSON.stringify( what_alice_thinks_the_balances_are ) === JSON.stringify( what_bob_thinks_the_balances_are ) );
                    console.log( `alice's three payments to bob worked, right?`, they_agree );
                    console.log( `alice's balance: ${hedgehog.getBalances( a_chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( a_chan_id )[ 1 ]}` );
                    var test7 = "failed";
                    if ( they_agree ) test7 = "passed";

                    //test a force closure by bob when he has the latest state
                    console.log( 'testing a force closure by bob when he has the latest state...' );
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    //the txid variable is used for checking if your counterparty broadcasted the latest state.
                    //if you detect that your counterparty broadcasted tx1 of the force closure transactions,
                    //you can get its txid and pass it to the forceClose command, and if your counterparty did
                    //*not* broadcast the latest state, it will do one of two things: if they broadcasted a
                    //state that they *fully* revoked, it will return a justice transaction that takes their
                    //money; if they broadcasted a state that they *conditionally* revoked, it will return a
                    //transaction that updates the state to the latest one
                    var txid = null;
                    var test8;
                    console.log( 0 );
                    if ( b_force || disappearance ) {
                        console.log( 1 );
                        if ( test_on_regtest && ( b_force || disappearance ) ) alert( `we are about to test a force closure by bob, so you will be prompted to send additional money in so that he may cover the fees associated with his force closure` );
                        var force_closure_txs = await hedgehog.forceClose( b_chan_id, txid, txdata2 );
                        var { tx1, tx1_fee, tx2, tx2_fee } = force_closure_txs;
                        if ( b_force && show_logs ) {
                            console.log( 'broadcast this to create the midstate:' );
                            console.log( tapscript.Tx.encode( tx1 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx1_fee ).hex );
                            console.log( 'then wait 2 weeks' );
                            console.log( 'then broadcast this to finalize your state:' );
                            console.log( tapscript.Tx.encode( tx2 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx2_fee ).hex );
                        }
                        console.log( `alice got the amount she should, right?`, tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( a_chan_id )[ 0 ] );
                        console.log( `bob got the amount he should, right?`, tx2.vout[ 2 ][ "value" ] === hedgehog.getBalances( a_chan_id )[ 1 ] - 480 );
                        test8 = "failed";
                        if ( tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( a_chan_id )[ 0 ] && hedgehog.getBalances( a_chan_id )[ 1 ] - 480 ) test8 = "passed";
                    }
                    if ( b_force ) return { test0, test1, test2, test3, test4, test5, test6, test7, test8 };

                    //test that alice can recover the money bob abandoned if bob disappears before broadcasting tx2
                    var test9;
                    if ( disappearance ) {
                        console.log( 'testing that alice can recover the money bob abandoned if bob disappears before broadcasting tx2...' );
                        var a_chan_id = data_for_bob.chan_id;
                        var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                        var { disappearance_tx } = await hedgehog.forceClose( a_chan_id, tx1_txid );
                        var total_in_channel = hedgehog.getBalances( a_chan_id ).reduce( ( accumulator, currentValue ) => accumulator + currentValue, 0 );
                        if ( show_logs ) {
                            console.log( 'broadcast this to create the midstate:' );
                            console.log( tapscript.Tx.encode( tx1 ).hex );
                            console.log( 'wait 2026 blocks' );
                            console.log( 'broadcast this disappearance_tx transaction because Bob never broadcasted tx2:' );
                            console.log( tapscript.Tx.encode( disappearance_tx ).hex );
                        }
                        console.log( 'alice can sweep everything after 2026 blocks, right?', disappearance_tx.vout[ 0 ].value === total_in_channel - 240 - 500 );
                        test9 = "failed";
                        if ( disappearance_tx.vout[ 0 ].value === total_in_channel - 240 - 500 ) test9 = "passed";
                        if ( disappearance ) return { test0, test1, test2, test3, test4, test5, test6, test7, test8, test9 };
                    }

                    //test a force closure by alice when she does *not* have the latest state
                    console.log( 'testing a force closure by alice when she does *not* have the latest state...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var txid = null;
                    if ( test_on_regtest ) alert( `we are about to test a force closure by alice in a situation where she does not have the latest state. Consequently, you will be prompted to send additional money in so that she may cover the fees associated with her force closure` );
                    var alices_force_closure_txs = await hedgehog.forceClose( a_chan_id, txid, txdata2 );
                    var { tx1, tx1_fee } = alices_force_closure_txs;
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );
                    if ( test_on_regtest && a_force ) alert( `since Alice did not have the latest state, she broadcasted the previous state, and bob will have to finalize it in the latest state so that he does not lose any money; consequently, bob will need to broadcast a transaction, and therefore you will be prompted *again* to send in *even more* additional money in so that he may cover the fees required to finalize the state` );
                    var test10;
                    if ( a_force ) {
                        var bobs_force_closure_txs = await hedgehog.forceClose( b_chan_id, tx1_txid, txdata2 );
                        var { alt_tx2: tx2, tx2_fee } = bobs_force_closure_txs;
                        if ( show_logs ) {
                            console.log( 'broadcast this to create the midstate:' );
                            console.log( tapscript.Tx.encode( tx1 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx1_fee ).hex );
                            console.log( 'broadcast this to finalize in the latest state:' );
                            console.log( tapscript.Tx.encode( tx2 ).hex );
                            console.log( 'broadcast this to pay the fee:' );
                            console.log( tapscript.Tx.encode( tx2_fee ).hex );
                        }
                        console.log( `alice got the amount she should, right?`, tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( b_chan_id )[ 0 ], tx2.vout[ 1 ][ "value" ], hedgehog.getBalances( b_chan_id )[ 0 ] );
                        console.log( `bob got the amount he should, right?`, tx2.vout[ 2 ][ "value" ] === hedgehog.getBalances( b_chan_id )[ 1 ] - 480, tx2.vout[ 2 ][ "value" ], hedgehog.getBalances( b_chan_id )[ 1 ] );
                        test10 = "failed";
                        if ( tx2.vout[ 1 ][ "value" ] === hedgehog.getBalances( b_chan_id )[ 0 ] && hedgehog.getBalances( b_chan_id )[ 1 ] - 480 ) test10 = "passed";
                        return { test0, test1, test2, test3, test4, test5, test6, test7, test8, test9, test10 }
                    }

                    //test a force closure by bob when she does *not* have the latest state
                    console.log( 'testing a force closure by alice when she does *not* have the latest state...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var txid = null;
                },
                runHTLCTests: async test_on_regtest => {
                    //prepare a keypair
                    var privkey = hedgehog.getPrivkey();
                    var pubkey = hedgehog.getPubkey( privkey );
                    var preimage = hedgehog.getPrivkey();
                    var hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    hedgehog.keypairs[ pubkey ] = {privkey, preimage}

                    //test opening a channel
                    console.log( 'testing opening a channel...' );
                    var bobs_pubkey = Object.keys( hedgehog.keypairs )[ 0 ];
                    var bobs_hash = await hedgehog.sha256( hedgehog.hexToBytes( hedgehog.keypairs[ bobs_pubkey ].preimage ) );
                    var bobs_pubkey_and_hash = [ bobs_pubkey, bobs_hash ];
                    var txdata = null;
                    var txdata2 = null;
                    //txdata2 is used later when testing force closures later. You can test them on regtest or testnet by commenting out the two lines below. If you do, then the openChannel command will prompt you to manually enter a txid, vout, and amount for your funding transaction, and the forceClose command will promt you to manually enter similar data for a transaction that pays the fee for your force closures.
                    if ( !test_on_regtest ) {
                        txdata = [ "a".repeat( 64 ), 0, 10_000 ];
                        txdata2 = [ "a".repeat( 64 ), 0, 1_000 ];
                    }
                    var show_logs = !txdata2;
                    var data_for_bob = await hedgehog.openChannel( bobs_pubkey_and_hash, txdata );
                    var channel_is_valid = await hedgehog.openChannel( null, null, data_for_bob );
                    console.log( 'channel_is_valid, right?', channel_is_valid );
                    console.log( `alice's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 0 ]} | bob's balance: ${hedgehog.getBalances( data_for_bob.chan_id )[ 1 ]}` );
                    var test0 = "failed";
                    if ( channel_is_valid ) test0 = "passed";

                    //test sending an HTLC from bob to alice
                    console.log( 'testing an HTLC payment of 8000 sats from bob to alice...' );
                    var a_chan_id = data_for_bob.chan_id;
                    var b_chan_id = "b_" + data_for_bob.chan_id.substring( 2 );
                    var chan_id = b_chan_id;
                    var amnt = 8_000;
                    var htlc_locktime = 20;
                    var pmthash = await hedgehog.sendHtlc( chan_id, amnt, htlc_locktime );
                    var preimage = await hedgehog.findPreimage( chan_id, pmthash );
                    await hedgehog.resolveHtlcAsSender( chan_id, preimage );
                    console.log( 'yay' );
                },
                runAllTests: async () => {
                    var test_on_regtest = confirm( `click ok if you want to test on regtest, which requires manually entering transaction data. Otherwise click cancel and we will just assume the signatures generated by these tests are valid` );
                    var b_force = await hedgehog.runBasicTests( test_on_regtest, true );
                    var disappearance = await hedgehog.runBasicTests( test_on_regtest, false, true );
                    var a_force = await hedgehog.runBasicTests( test_on_regtest, false, false, true );
                    console.log( 'in these tests, Bob force closes the channel in the latest state:' );
                    console.log( b_force );
                    console.log( 'in these tests, Bob initiates a force closure but then disappears before finalizing, so Alice sweeps the funds:' );
                    console.log( disappearance );
                    console.log( 'in these tests, Alice force closes the channel in the previous state, and Bob corrects it:' );
                    console.log( a_force );
                    console.log( 'note that in the above example, it is okay for test8 and test9 to be undefined because we did not run test8 or test9, which are only relevant when Bob initiates a force closure' );
                },
                communicateWithUser: async data_for_user => {
                    throw( 'batteries not included -- you are supposed to overwrite this function with something that *actually* communicates with the user' );
                }
            }
        </script>
        <script>
            var hedgehog_client = {
                network: "testnet4/",
                explorer: "mempool.space",
                server: null,
                relays: null,
                backup_privkey: null,
                backup_relays: [ 'wss://nostrue.com' ],
                nostr_privkey: null,
                two_way_comms: {},
                checks: {},
                num_of_checks: 0,
                showPage: page => {
                    $( '.welcome_page' ).classList.add( "hidden" );
                    $( '.wallet_page' ).classList.add( "hidden" );
                    $( '.loading_page' ).classList.add( "hidden" );
                    $( '.checks_page' ).classList.add( "hidden" );
                    $( '.check_page' ).classList.add( "hidden" );
                    $( `.${page}` ).classList.remove( "hidden" );
                },
                onboard: async ( server_id, check_hex ) => {
                    if ( !server_id && !url_params.hasOwnProperty( "server_id" ) ) {
                        var server_id = prompt( `enter a server id. Don't know one? Ask bitcoiners to recommend you a good hedgehog server and get its server id from them.` );
                        var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#server_id=${server_id}#onboard=true`;
                        window.location.href = url;
                        window.location.reload();
                        return;
                    } else if ( url_params.hasOwnProperty( "server_id" ) ) {
                        var server_id = url_params.server_id;
                    }
                    url_params.server_id = server_id;
                    var [ server, relays ] = hedgehog_client.convertNEvent( server_id );
                    hedgehog_client.server = server;
                    hedgehog_client.relays = relays;
                    //TODO: ensure the backup string includes nostr relays where you will store your data, so that you load that data from them when you log in later
                    var backup_privkey = super_nostr.getPrivkey();
                    var backup_string = hedgehog_client.convertPubkeyAndRelaysToNprofile( "nbackup", backup_privkey, hedgehog_client.backup_relays );
                    var content = `
                        <p>Here is your backup string</p>
                        <p class="show_backup_string">${backup_string}</p>
                        <p>Store it safely.</p>
                        <p><button class="done_storing_backup_string">Done</button></p>
                    `;
                    var loop = async () => {
                        if ( $( '.modal' ) ) return;
                        await hedgehog_client.waitSomeTime( 100 );
                        loop();
                    }
                    await loop();
                    showModal( content );
                    $( '.done_storing_backup_string' ).onclick = () => {
                        var content = `
                            <p>Are you sure? A lot of people just click done without actually storing it. Don't be like them! You'll lose your money!</p>
                            <p class="show_backup_string">${backup_string}</p>
                            <p><button class="really_done_storing_backup_string">Yes, I am really done</button></p>
                        `;
                        showModal( content );
                        $( '.really_done_storing_backup_string' ).onclick = () => {
                            if ( window.location.href.includes( "onboard=true" ) ) {
                                url_params.backup_string = backup_string;
                                var str_to_add = '';
                                Object.keys( url_params ).forEach( item => {
                                    if ( item === "onboard" ) return;
                                    str_to_add = str_to_add + `#${item}=${url_params[ item ]}`;
                                });
                                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + str_to_add;
                                window.location.href = url;
                                window.location.reload();
                                return;
                            } else {
                                if ( check_hex ) hedgehog_client.login( backup_string, check_hex );
                                else hedgehog_client.login( backup_string );
                                modalVanish();
                            }
                        }
                    }
                },
                login: async ( backup_string, check_hex ) => {
                    var [ backup_privkey, backup_relays ] = hedgehog_client.convertNEvent( backup_string );
                    hedgehog_client.backup_privkey = backup_privkey;
                    hedgehog_client.backup_relays = backup_relays;
                    hedgehog_client.showPage( 'loading_page' );
                    await hedgehog_client.downloadState();
                    hedgehog_client.showPage( 'wallet_page' );
                    hedgehog_client.nostr_privkey = super_nostr.getPrivkey();
                    //TODO: allow people to use more than one hedgehog server
                    if ( url_params.server_id && !hedgehog_client.server ) {
                        var server_id = url_params.server_id;
                        var [ server, relays ] = hedgehog_client.convertNEvent( server_id );
                        hedgehog_client.server = server;
                        hedgehog_client.relays = relays;
                    }
                    //TODO: load data from the nostr relays in your backup string so that you know what relays the server uses, which should be stored there
                    await hedgehog_client.listenOnNostr();
                    if ( check_hex ) {
                        url_params.check_hex = check_hex;
                        var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                        var fee_payment = {encrypted_channel_fee_data: check_data.encrypted_channel_fee_data, encryption_pubkey: check_data.check_encryption_pubkey, encrypted_chan_id: check_data.check_encrypted_chan_id};
                        hedgehog_client.makeJITChannelPartOne( 40_000, fee_payment );
                        return;
                    }
                },
                downloadState: async () => {
                    var backup_privkey = hedgehog_client.backup_privkey;
                    var backup_pubkey = super_nostr.getPubkey( backup_privkey );
                    var relay = hedgehog_client.backup_relays[ 0 ];
                    var ids = null;
                    var authors = [ backup_pubkey ];
                    var kinds = [ 16108 ];
                    var until = null;
                    var since = null;
                    var limit = 1;
                    var alt_event = localStorage.hedgehog_client_state ? localStorage.hedgehog_client_state : "";
                    if ( alt_event ) alt_event = JSON.parse( alt_event );
                    //var events = await super_nostr.getEvents( relay, ids, authors, kinds, until, since, limit );
                    var events = [];
                    if ( !events.length && !alt_event ) {
                        console.log( 'no state' );
                        hedgehog_client.uploadStateLoop();
                        hedgehog_client.balanceLoop();
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    var state_event = events[ 0 ];
                    var real_event = state_event;
                    if ( !real_event ) real_event = alt_event;
                    if ( alt_event && alt_event.length > JSON.stringify( real_event ).length ) real_event = JSON.parse( alt_event );
                    try {
                        real_event.content = await super_nostr.alt_decrypt( backup_privkey, backup_pubkey, real_event.content );                        
                    } catch ( e ) {
                        console.log( 'no state' );
                        hedgehog_client.uploadStateLoop();
                        hedgehog_client.balanceLoop();
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    var {
                        network,
                        explorer,
                        server,
                        relays,
                        checks,
                        state,
                    } = JSON.parse( real_event.content );
                    hedgehog.state = state;
                    hedgehog_client.network = network;
                    hedgehog_client.explorer = explorer;
                    hedgehog_client.server = server;
                    hedgehog_client.relays = relays;
                    hedgehog_client.checks = checks;
                    hedgehog_client.uploadStateLoop();
                    hedgehog_client.balanceLoop();
                    hedgehog_client.handleChecksLoop();
                },
                uploadStateLoop: async () => {
                    await hedgehog_client.waitSomeTime( 3000 );
                    var backup_privkey = hedgehog_client.backup_privkey;
                    var backup_pubkey = super_nostr.getPubkey( backup_privkey );
                    var { network, explorer, server, relays, checks } = hedgehog_client;
                    var state = hedgehog.state;
                    if ( !Object.keys( state ).length ) $( '.open_channel' ).classList.remove( "hidden" );
                    var plaintext = JSON.stringify({ network, explorer, server, relays, checks, state });
                    var encrypted = await super_nostr.alt_encrypt( backup_privkey, backup_pubkey, plaintext );
                    var event = await super_nostr.prepEvent( backup_privkey, encrypted, 16108 );
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    if ( !socket_id ) {
                        hedgehog_client.uploadStateLoop();
                        return;
                    }
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    // super_nostr.sendEvent( event, socket );
                    localStorage.hedgehog_client_state = JSON.stringify( event );
                    hedgehog_client.uploadStateLoop();
                },
                getBalance: chan_id => {
                    if ( !chan_id ) return [ 0, 0 ];
                    var income = 0;
                    var expenses = 0;
                    hedgehog.state[ chan_id ].channel_states.forEach( ( item, index ) => {
                        if ( item.from === "bob" && !item.added_htlc ) income = income + item.amnt_sent;
                        if ( index && item.from === "alice" && !item.added_htlc ) expenses = expenses + item.amnt_sent;
                    });
                    var in_checks = 0;
                    Object.keys( hedgehog_client.checks ).forEach( check_id => {
                        var check = hedgehog_client.checks[ check_id ];
                        in_checks = in_checks + check.check_amount + check.channel_fee;
                    });
                    return [ income - expenses, in_checks ];
                },
                balanceLoop: async () => {
                    //TODO: allow more than one channel
                    var chan_id = hedgehog_client.getChanId();
                    if ( !chan_id ) {
                        await hedgehog_client.waitSomeTime( 1000 );
                        hedgehog_client.balanceLoop();
                    }
                    if ( Object.keys( hedgehog_client.checks ).length ) {
                        $( '.checks_amnt_p' ).classList.remove( "hidden" );
                    } else {
                        $( '.checks_amnt_p' ).classList.add( "hidden" );
                    }
                    var [ balance_not_in_checks, balance_in_checks ] = hedgehog_client.getBalance( chan_id );
                    $( '.balance' ).innerText = balance_not_in_checks - balance_in_checks;
                    $( '.balance_in_checks' ).innerText = balance_in_checks;
                    await hedgehog_client.waitSomeTime( 100 );
                    hedgehog_client.balanceLoop();
                },
                openChannel: async () => {
                    hedgehog_client.makeJITChannelPartOne( 40_000 );
                },
                receive: async () => {
                    var chan_id = hedgehog_client.getChanId();
                    if ( !chan_id ) return alert( 'open a channel first' );
                    var amnt_or_check = prompt( `enter the amount of sats you want to receive, or enter a check` );
                    if ( !amnt_or_check ) return;
                    if ( !isNaN( amnt_or_check ) ) {
                        amnt_or_check = Number( amnt_or_check );
                        hedgehog_client.prepToReceiveLNPartOne( chan_id, amnt_or_check );
                    }
                    url_params.check = amnt_or_check;
                    hedgehog_client.checkPage();
                },
                makeJITChannelPartOne: async ( amount, fee_payment ) => {
                    var msg_for_server = JSON.stringify({
                        msg_type: "channel_request",
                        msg_value: {
                            amount,
                            fee_payment,
                        }
                    });
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.makeJITChannelPartTwo( privkey, amount );
                    super_nostr.sendEvent( event, hedgehog_client.relays[ 0 ] );
                },
                makeJITChannelPartTwo: async ( privkey, amount ) => {
                    //prepare the necessary variables
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;
                    showModal( 'waiting for server...' );

                    //get the message from the server
                    var message_identifier = "channel_request_reply";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the data from the server
                    var json = JSON.parse( event.content );
                    if ( json.msg_type !== "channel_request_reply" ) return showModal( 'aborting -- server tried to cheat you by sending you bad data' );

                    //validate the utxo data
                    if ( typeof json.msg_value.utxos === "string" ) return showModal( 'aborting -- server did not have enough money to fund this channel' );
                    var all_is_well = true;
                    try {
                        var sum_of_utxos = 0;
                        var i; for ( i=0; i<json.msg_value.utxos.length; i++ ) {
                            var utxo = json.msg_value.utxos[ i ];
                            sum_of_utxos = sum_of_utxos + utxo.amnt;
                            var addy_is_segwit = utxo.addy.startsWith( "tb1" ) || utxo.addy.startsWith( "bc1" );
                            if ( !addy_is_segwit ) {
                                all_is_well = false;
                                break;
                            }
                            var utxo_exists = await hedgehog_client.utxoExists( utxo );
                            if ( !utxo_exists ) {
                                all_is_well = false;
                                break;
                            }
                        }
                        if ( sum_of_utxos < amount ) all_is_well = false;
                        if ( !all_is_well ) return showModal( 'aborting --- server tried to cheat you by sending you invalid utxo data' );
                    } catch ( e ) {each_utxo_is_valid = false;}

                    try {
                        //validate the invoice, if any
                        var fee_invoice = null;
                        if ( json.msg_value.hasOwnProperty( "fee_invoice" ) ) {
                            fee_invoice = json.msg_value.fee_invoice;
                            //TODO: uncomment the line below
                            // if ( !fee_invoice.startsWith( "ln" ) ) return showModal( 'aborting -- server refused to fund your channel' );
                        }

                        var bobs_pubkey_and_hash = [ json.msg_value.channel_pubkey_and_hash.pubkey, json.msg_value.channel_pubkey_and_hash.hash ];
                        var channel_capacity = json.msg_value.channel_capacity;
                        //TODO: ensure the channel_capacity makes sense with what you're being charged via the fee_invoice, if any
                        //TODO: ensure these values don't result in an invalid tx e.g. due to
                        //paying too low of a fee or having a negative vout value
                        var txfee = json.msg_value.fee;
                        var change_address = json.msg_value.change_address;
                        var chan_id = await hedgehog.prepChannel( bobs_pubkey_and_hash );
                        var channel_scripts = hedgehog.getChannelScripts( chan_id );
                        var channel = hedgehog.getAddressData( channel_scripts, 0 )[ 0 ];

                        var funding_vin = [];
                        json.msg_value.utxos.forEach( utxo => funding_vin.push( hedgehog.getVin( utxo.txid, utxo.vout, utxo.amnt, utxo.addy ) ) );
                        var funding_tx = tapscript.Tx.create({
                            version: 2,
                            vin: funding_vin,
                            vout: [
                                hedgehog.getVout( channel_capacity, channel ),
                            ],
                        });
                        if ( sum_of_utxos - channel_capacity - txfee > 330 ) funding_tx.vout.push( hedgehog.getVout( sum_of_utxos - channel_capacity - txfee, change_address ) );
                        var funding_txid = tapscript.Tx.util.getTxid( funding_tx );
                        var txdata = [ funding_txid, 0, channel_capacity ];
                        var data_for_bob = await hedgehog.openChannel( bobs_pubkey_and_hash, txdata, null, chan_id );

                        //send channel data to server
                        var msg_for_server = JSON.stringify({
                            msg_type: "channel_init",
                            msg_value: data_for_bob,
                        });
                        var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                        var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                        hedgehog_client.makeJITChannelPartThree( privkey, chan_id, fee_invoice );
                        super_nostr.sendEvent( event, relays[ 0 ] );

                        //cash check, if any
                        if ( !json.msg_value.need_fee_invoice ) modalVanish();
                        if ( url_params.hasOwnProperty( "check_hex" ) ) {
                            showModal( `<p>Cashing check...</p>` );
                            var check_hex = url_params.check_hex;
                            var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                            var { check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey } = check_data;
                            hedgehog_client.cashCheck( chan_id, check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey );
                        }
                    } catch ( e ) {
                        showModal( `aborting -- unknown error, ${e}` );
                    }
                },
                makeJITChannelPartThree: async ( privkey, chan_id, fee_invoice ) => {
                    if ( fee_invoice ) {
                        //prepare the necessary variables
                        var pubkey = super_nostr.getPubkey( privkey );
                        var server = hedgehog_client.server;
                        var relays = hedgehog_client.relays;

                        showModal( `<p>This invoice will buy you a channel with 80k sats of inbound capacity</p><p>${fee_invoice}</p>` );

                        //get the message from the server
                        var message_identifier = "channel_init_reply";
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        var loop = async () => {
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var event = await loop();
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        var message_to_show_user = `<p>Payment detected. Waiting for channel funding tx to confirm (${hedgehog.state[ chan_id ].funding_txinfo[ 0 ]})</p>`;
                        //inform the user what's up
                        showModal( message_to_show_user );
                    }
                    $( '.open_channel' ).classList.add( "hidden" );
                },
                prepToReceiveLNPartOne: async ( chan_id, amount, skip_to_resolution ) => {
                    //prepare the needed variables
                    var privkey = hedgehog_client.nostr_privkey;
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;
                    var preimage = super_nostr.getPrivkey();
                    var hash = await super_nostr.sha256( super_nostr.hexToBytes( preimage ) );

                    if ( skip_to_resolution ) {
                        preimage = skip_to_resolution;
                        hash = await super_nostr.sha256( super_nostr.hexToBytes( preimage ) );
                    }

                    if ( !skip_to_resolution ) {
                        //request the server to help you bridge LN to hedgehog
                        var msg_for_server = JSON.stringify({
                            msg_type: "request_ln_pmt_to_user",
                            msg_value: {
                                chan_id,
                                amount,
                                hash,
                            }
                        });
                        var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                        var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                        hedgehog_client.makeJITChannelPartTwo( privkey, amount );
                        super_nostr.sendEvent( event, hedgehog_client.relays[ 0 ] );

                        //get the message from the server
                        var message_identifier = "ln_invoice_for_user";
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        var loop = async () => {
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var event = await loop();
                        delete hedgehog_client.two_way_comms[ message_identifier ];

                        //parse the data from the server
                        var json = JSON.parse( event.content );

                        //validate the invoice
                        var ln_invoice = json.msg_value.ln_invoice;
                        //TODO: validate that the ln invoice has the payment hash you expect and the value you expect
                        //TODO: uncomment the line below
                        // if ( !ln_invoice.startsWith( "ln" ) ) return showModal( 'aborting -- server refused to fund your channel' );

                        //present the invoice to the user
                        showModal( `<p>Pay this invoice</p><p>${ln_invoice}</p>` );

                        //get the message from the server
                        var message_identifier = "ln_invoice_paid";
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                        var loop = async () => {
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var event = await loop();
                        delete hedgehog_client.two_way_comms[ message_identifier ];
                    }

                    //get the next message from the server
                    var message_identifier = "two_way_comms";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //tell the user what's up
                    if ( !skip_to_resolution ) showModal( `<p>Payment detected -- bridging from LN to hedgehog, please wait</p>` );

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    var data_for_htlc_p1 = json.msg_value;
                    delete data_for_htlc_p1[ "message_identifier" ];
                    var my_revhashes = await hedgehog.receiveHtlcPartOne( data_for_htlc_p1 );

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "two_way_comms",
                        msg_value: {message_identifier, data_for_server: my_revhashes},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.prepToReceiveLNPartTwo( privkey, chan_id, preimage );
                    super_nostr.sendEvent( event, relays[ 0 ] );
                },
                prepToReceiveLNPartTwo: async ( privkey, chan_id, preimage ) => {
                    //prepare the necessary variables
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;

                    //get the next message from the server
                    var message_identifier = "two_way_comms";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    var data_for_htlc_p2 = json.msg_value;
                    delete data_for_htlc_p2[ "message_identifier" ];
                    var data_for_server = await hedgehog.receiveHtlcPartTwo( data_for_htlc_p2 );

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "two_way_comms",
                        msg_value: {message_identifier, data_for_server},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.prepToReceiveLNPartThree( privkey, chan_id, preimage );
                    super_nostr.sendEvent( event, relays[ 0 ] );
                },
                prepToReceiveLNPartThree: async ( privkey, chan_id, preimage ) => {
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;

                    //get the next message from the server
                    var message_identifier = "two_way_comms";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    var data_for_htlc_p3 = json.msg_value;
                    delete data_for_htlc_p3[ "message_identifier" ];
                    var data_for_server = await hedgehog.receiveHtlcPartThree( data_for_htlc_p3 );

                    //store the preimage to the now-pending htlc
                    var pending_htlcs = hedgehog.state[ chan_id ].channel_states[ hedgehog.state[ chan_id ].channel_states.length - 1 ].pending_htlcs;
                    pending_htlcs[ pending_htlcs.length - 1 ].pmt_preimage = preimage;

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "two_way_comms",
                        msg_value: {message_identifier, data_for_server},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    hedgehog_client.prepToReceiveLNPartFour( privkey, chan_id, preimage );
                    super_nostr.sendEvent( event, relays[ 0 ] );
                },
                prepToReceiveLNPartFour: async ( privkey, chan_id, preimage ) => {
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;
                    showModal( `<p>resolving htlc</p>` );

                    //send channel data to server
                    var msg_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_user",
                        msg_value: {preimage, chan_id},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    super_nostr.sendEvent( event, relays[ 0 ] );

                    //TODO: if the server does not reply in a few seconds, force close
                    //get the next message from the server
                    var message_identifier = "resolve_htlc_to_user_part_two";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from the server
                    var json = JSON.parse( event.content );
                    var message_identifier = json.msg_value.message_identifier;
                    delete json.msg_value[ "message_identifier" ];
                    var new_state_info = json.msg_value;

                    //find the to-be-resolved htlc
                    var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    var index_of_pending_htlc = -1;
                    var amnt_of_pending_htlc = null;
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    pending_htlcs = latest_state.pending_htlcs;
                    pending_htlcs.every( ( htlc, index ) => {
                        if ( htlc.pmthash !== pmthash ) return true;
                        if ( am_alice && htlc.sender === "alice" ) return true;
                        if ( !am_alice && htlc.sender === "bob" ) return true;
                        index_of_pending_htlc = index;
                        amnt_of_pending_htlc = htlc.amnt;
                    });

                    //create a pending_htlcs array without that htlc
                    var new_pending_htlcs = JSON.parse( JSON.stringify( pending_htlcs ) );
                    var htlc_to_remove = JSON.parse( JSON.stringify( pending_htlcs[ index_of_pending_htlc ] ) );
                    new_pending_htlcs.splice( index_of_pending_htlc, 1 );

                    //create and sign a tx1 and tx2 based on that pending_htlcs array, and with the value of the htlc added to your side of the channel, and add the new state to your ch_states array
                    var amnt = amnt_of_pending_htlc;
                    //TODO: force close if the error below is thrown
                    if ( new_state_info.amnt !== amnt ) return console.log( 'error, your counterparty tried to cheat you by resolving an htlc for a wrong amount' );
                    var new_state_is_valid = await hedgehog.receive( new_state_info, new_pending_htlcs );
                    //TODO: force close if the error below is thrown
                    if ( !new_state_is_valid ) return console.log( 'error, your counterparty tried to cheat you by refusing to resolve an htlc' );

                    //revoke old state and tell counterparty
                    var state_update = await hedgehog.send( chan_id, 0 );
                    state_update[ "message_identifier" ] = message_identifier;
                    var msg_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_user_part_three",
                        msg_value: state_update,
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    super_nostr.sendEvent( event, relays[ 0 ] );

                    //TODO: if the server does not reply in a few seconds, force close
                    //get counterparty's revocations
                    var message_identifier = "resolve_htlc_to_user_part_four";
                    delete hedgehog_client.two_way_comms[ message_identifier ];
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from your counterparty
                    var json = JSON.parse( event.content );

                    //validate the new state
                    var s_midstate_rev_preimage = json.msg_value.s_midstate_rev_preimage;
                    var s_recovery_p2_rev_preimage = json.msg_value.s_recovery_p2_rev_preimage;
                    delete json.msg_value[ "s_midstate_rev_preimage" ];
                    delete json.msg_value[ "s_recovery_p2_rev_preimage" ];
                    if ( json.msg_value.amnt !== 0 ) return console.log( 'error, your counterparty tried to cheat by doing a non-blank state update' );
                    var new_state_is_valid = await hedgehog.receive( json.msg_value, new_pending_htlcs );
                    //TODO: force close if the error below is thrown
                    if ( !new_state_is_valid ) return console.log( 'error, your counterparty tried to cheat you by refusing to resolve an htlc' );

                    //verify he revoked his recovery-path and the htlc midstate
                    var calculated_midstate_hash = await hedgehog.sha256( hedgehog.hexToBytes( s_midstate_rev_preimage ) );
                    var expected_midstate_hash = htlc_to_remove.s_midstate_revhash;
                    var calculated_recovery_hash = await hedgehog.sha256( hedgehog.hexToBytes( s_recovery_p2_rev_preimage ) );
                    var expected_recovery_hash = htlc_to_remove.s_recovery_p2_revhash;
                    //TODO: force close if the error below is thrown
                    if ( calculated_midstate_hash !== expected_midstate_hash || calculated_recovery_hash !== expected_recovery_hash ) return console.log( 'error, your counterparty tried to cheat you by sending invalid revocation data' );

                    //save the revocation data
                    hedgehog.state[ chan_id ].channel_states[ hedgehog.state[ chan_id ].channel_states.length - 4 ].pending_htlcs[ index_of_pending_htlc ].s_midstate_rev_preimage = s_midstate_rev_preimage;
                    hedgehog.state[ chan_id ].channel_states[ hedgehog.state[ chan_id ].channel_states.length - 4 ].pending_htlcs[ index_of_pending_htlc ].s_recovery_p2_rev_preimage = s_recovery_p2_rev_preimage;

                    //send your counterparty your reveal-path rev_preimage and your htlc midstate rev_preimage
                    var msg_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_user_part_five",
                        msg_value: {recipients_rev_preimages: htlc_to_remove.recipients_rev_preimages, message_identifier: "resolve_htlc_to_user_part_five"},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    super_nostr.sendEvent( event, relays[ 0 ] );

                    //inform the user what's going on
                    showModal( 'received' );
                },
                listenOnNostr: async () => {
                    var nostr_privkey = hedgehog_client.nostr_privkey;
                    var nostr_pubkey = super_nostr.getPubkey( nostr_privkey );
                    var nostr_relays = hedgehog_client.relays;
                    var server = hedgehog_client.server;
                    var listenFunction = async socket => {
                        var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                        var filter  = {}
                        filter.authors = [ server ];
                        filter.kinds = [ 4 ];
                        filter[ "#p" ] = [ nostr_pubkey ];
                        filter.since = Math.floor( Date.now() / 1000 );
                        var subscription = [ "REQ", subId, filter ];
                        socket.send( JSON.stringify( subscription ) );
                    }
                    var handleFunction = async message => {
                        var [ type, subId, event ] = JSON.parse( message.data );
                        if ( !event || event === true ) return;
                        try {
                            event.content = await super_nostr.alt_decrypt( nostr_privkey, event.pubkey, event.content );
                            var json = JSON.parse( event.content );
                            console.log( json );
                            if ( json[ "msg_type" ] === "htlc_to_server_part_zero" ) {
                                var preimage = json[ "msg_value" ][ "preimage" ];
                                var chan_id = json[ "msg_value" ][ "chan_id" ];
                                chan_id = "a_" + chan_id.substring( 2 );
                                var privkey = hedgehog_client.nostr_privkey;
                                var pubkey = super_nostr.getPubkey( privkey );
                                var server = hedgehog_client.server;
                                var relays = hedgehog_client.relays;
                                var state = hedgehog.state[ chan_id ];
                                var am_alice = !!state.alices_priv;

                                //find the to-be-resolved htlc
                                var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                                var index_of_pending_htlc = -1;
                                var amnt_of_pending_htlc = null;
                                var pending_htlcs = [];
                                var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                                if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                                //TODO: force close if the error below is thrown
                                if ( !pending_htlcs.length ) return console.log( 'error, your counterparty sent you a preimage when you have no pending htlcs' );
                                pending_htlcs.every( ( htlc, index ) => {
                                    if ( htlc.pmthash !== pmthash ) return true;
                                    if ( am_alice && htlc.sender === "bob" ) return true;
                                    if ( !am_alice && htlc.sender === "alice" ) return true;
                                    index_of_pending_htlc = index;
                                    amnt_of_pending_htlc = htlc.amnt;
                                });

                                //TODO: abort if either of the errors below are thrown
                                if ( index_of_pending_htlc < 0 ) return console.log( 'aborting because the server tried to cheat you by getting you to resolve an htlc that does not exist' );
                                if ( pending_htlcs[ index_of_pending_htlc ].sender !== "alice" ) return console.log( 'aborting because the server tried to cheat you by getting you to resolve an htlc you did not create' );

                                hedgehog_client.resolveHtlcToServer( chan_id, preimage );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_value.hasOwnProperty( "more_message_info" ) && json.msg_value.more_message_info === "htlc_to_server_part_two" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = json.msg_value.data_for_counterparty;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_value.hasOwnProperty( "more_message_info" ) && json.msg_value.more_message_info === "htlc_to_server_part_four" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = json.msg_value.data_for_counterparty;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_value.hasOwnProperty( "more_message_info" ) && json.msg_value.more_message_info === "htlc_to_server_part_six" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = json.msg_value.data_for_counterparty;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            if ( json.hasOwnProperty( "msg_value" ) && json.msg_type === "resolve_htlc_to_server_part_three" ) {
                                var msg_id = json.msg_value.message_identifier;
                                hedgehog_client.two_way_comms[ msg_id ] = event;
                                setTimeout( () => {delete hedgehog_client.two_way_comms[ msg_id ]}, 2000 );
                                return;
                            }
                            hedgehog_client.two_way_comms[ json.msg_type ] = event;
                        }
                        catch ( e ) {
                            console.log( e );
                        }
                    }
                    await super_nostr.newPermanentConnection( nostr_relays[ 0 ], listenFunction, handleFunction );
                },
                convertNEvent: nevent => {
                    var arr = bech32.bech32.fromWords( bech32.bech32.decode( nevent, 100_000 ).words );
                    var hex = super_nostr.bytesToHex( arr );
                    if ( !hex.startsWith( "0020" ) ) var event_id = hex.substring( hex.length - 64 );
                    else var event_id = hex.substring( 4, 68 );
                    if ( !hex.startsWith( "0020" ) ) hex = hex.substring( 0, hex.length - 64 );
                    else hex = hex.substring( 68 );
                    var relays = [];
                    var loop = () => {
                        if ( hex.startsWith( "01" ) ) {
                            var relay_length = parseInt( hex.substring( 2, 4 ), 16 );
                            relays.push( hedgehog_client.hexToText( hex.substring( 4, 4 + relay_length * 2 ) ) );
                            hex = hex.substring( 4 + relay_length * 2 );
                            loop();
                        }
                    }
                    loop();
                    return [ event_id, relays ];
                },
                hexToText: hex => {
                    var bytes = new Uint8Array( Math.ceil( hex.length / 2 ) );
                    var i; for ( i=0; i<hex.length; i++ ) bytes[ i ] = parseInt( hex.substr( i * 2, 2 ), 16 );
                    var text = new TextDecoder().decode( bytes );
                    return text;
                },
                utxoExists: async utxo => {
                    try {
                        return new Promise( async resolve => {
                            var { txid, vout, addy, amnt } = utxo;
                            var url = `https://${hedgehog_client.explorer}/${hedgehog_client.network}api/tx/${txid}`;
                            var data = await fetch( url );
                            var json = await data.json();
                            json.vout.forEach( vout => {
                                if ( vout.scriptpubkey_address === addy && vout.value === amnt ) resolve( true );
                            });
                            resolve( false );
                        });
                    } catch ( e ) {return false;}
                },
                sendBtn: async () => {
                    var chan_id = hedgehog_client.getChanId();
                    if ( !chan_id ) return alert( 'open a channel first' );
                    var invoice = prompt( `enter an LN invoice` );
                    if ( !invoice ) return;
                    hedgehog_client.sendViaLN( chan_id, invoice );
                },
                send: async ( chan_id, amnt, pmthash ) => {
                    var htlc_locktime = 2026;
                    var worked = await hedgehog.sendHtlc( chan_id, amnt, htlc_locktime, pmthash );
                    return !!worked;
                },
                sendViaLN: async ( chan_id, invoice ) => {
                    var pmthash = hedgehog_client.getInvoicePmthash( invoice );
                    var amnt = hedgehog_client.getInvoiceAmount( invoice );
                    var htlc_pending = await hedgehog_client.send( chan_id, amnt, pmthash );
                    if ( !htlc_pending ) return console.log( 'error, no htlc was created' );
                    hedgehog_client.askServerToPayLNInvoice( chan_id, invoice );
                },
                askServerToPayLNInvoice: async ( chan_id, invoice ) => {
                    var privkey = super_nostr.getPrivkey();
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;

                    //encrypt the channel id
                    var encryption_privkey = super_nostr.getPrivkey();
                    var encryption_pubkey = super_nostr.getPubkey( encryption_privkey );
                    var encrypted_chan_id = await super_nostr.alt_encrypt( encryption_privkey, server, chan_id );

                    //send invoice to server
                    var message_for_counterparty = JSON.stringify({
                        msg_type: "pay_ln_invoice_for_user",
                        msg_value: {encrypted_chan_id, invoice, encryption_pubkey},
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_counterparty );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    super_nostr.sendEvent( event, relays[ 0 ] );
                },
                resolveHtlcToServer: async ( chan_id, preimage ) => {
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;
                    var state = hedgehog.state[ chan_id ];
                    var am_alice = !!state.alices_priv;

                    //find the relevant htlc
                    var pmthash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                    var index_of_pending_htlc = -1;
                    var amnt_of_pending_htlc = null;
                    var pending_htlcs = [];
                    var latest_state = state.channel_states[ state.channel_states.length - 1 ];
                    if ( latest_state && latest_state.hasOwnProperty( "pending_htlcs" ) ) pending_htlcs = latest_state.pending_htlcs;
                    pending_htlcs.every( ( htlc, index ) => {
                        if ( htlc.pmthash !== pmthash ) return true;
                        if ( am_alice && htlc.sender === "bob" ) return true;
                        if ( !am_alice && htlc.sender === "alice" ) return true;
                        index_of_pending_htlc = index;
                        amnt_of_pending_htlc = htlc.amnt;
                    });

                    //create a pending_htlcs array without that htlc
                    var new_pending_htlcs = JSON.parse( JSON.stringify( pending_htlcs ) );
                    var htlc_to_remove = JSON.parse( JSON.stringify( pending_htlcs[ index_of_pending_htlc ] ) );
                    new_pending_htlcs.splice( index_of_pending_htlc, 1 );

                    //create and sign a tx1 and tx2 based on that pending_htlcs array, and with the value of the htlc added to your counterparty's side of the channel, and add the new state to your ch_states array
                    var amnt = amnt_of_pending_htlc;
                    console.log( 'my revocation preimages:', state.alices_revocation_preimages, 'my revocation hashes:', state.alices_revocation_hashes );
                    var object_for_counterparty = await hedgehog.send( chan_id, amnt, new_pending_htlcs );
                    object_for_counterparty[ "pmt_preimage" ] = preimage;

                    //get your counterparty to sign the new state
                    var message_identifier = super_nostr.getPrivkey();
                    var message_for_counterparty = JSON.stringify({
                        msg_type: "resolve_htlc_to_server_part_two",
                        msg_value: {...object_for_counterparty, message_identifier},
                    });
                    console.log( 'replying:', message_for_counterparty );
                    var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_counterparty );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    super_nostr.sendEvent( event, relays[ 0 ] );

                    //TODO: if your counterparty does not reply in a few seconds, force close
                    //get the next message from your counterparty
                    hedgehog_client.two_way_comms[ message_identifier ] = "waiting_for_info";
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) || ( hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) && hedgehog_client.two_way_comms[ message_identifier ] === "waiting_for_info" ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from your counterparty
                    var json = JSON.parse( event.content );
                    delete json.msg_value[ "message_identifier" ];

                    //validate the new state
                    if ( json.msg_value.amnt !== 0 ) return console.log( 'error, your counterparty tried to cheat by doing a non-blank state update' );
                    var new_state_is_valid = await hedgehog.receive( json.msg_value, new_pending_htlcs );
                    //TODO: force close if the error below is thrown
                    if ( !new_state_is_valid ) return console.log( 'error, your counterparty tried to cheat you by refusing to resolve an htlc' );

                    //revoke all prior states
                    //send your counterparty the following items: your recovery-path rev_preimage, your htlc midstate rev_preimage, and a new blank state update
                    var state_update = await hedgehog.send( chan_id, 0 );
                    state_update[ "message_identifier" ] = "resolve_htlc_to_server_part_four";
                    var message_for_server = JSON.stringify({
                        msg_type: "resolve_htlc_to_server_part_four",
                        msg_value: {...state_update, s_midstate_rev_preimage: htlc_to_remove.s_midstate_rev_preimage, s_recovery_p2_rev_preimage: htlc_to_remove.s_recovery_p2_rev_preimage},
                    });
                    console.log( 'replying:', message_for_server );
                    var emsg = await super_nostr.alt_encrypt( privkey, server, message_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    super_nostr.sendEvent( event, relays[ 0 ] );

                    //TODO: if your counterparty does not reply in a few seconds, force close
                    //ensure your counterparty sent you their reveal-path revocation preimage, their htlc midstate rev_preimage
                    var message_identifier = "resolve_htlc_to_server_part_five";
                    hedgehog_client.two_way_comms[ message_identifier ] = "waiting_for_info";
                    var loop = async () => {
                        await hedgehog_client.waitSomeTime( 100 );
                        if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) || ( hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) && hedgehog_client.two_way_comms[ message_identifier ] === "waiting_for_info" ) ) return loop();
                        return hedgehog_client.two_way_comms[ message_identifier ];
                    }
                    var event = await loop();
                    delete hedgehog_client.two_way_comms[ message_identifier ];

                    //parse the message from your counterparty
                    var json = JSON.parse( event.content );
                    delete json.msg_value[ "message_identifier" ];

                    //verify he revoked his recovery-path and the htlc midstate
                    var recipients_rev_preimages = json.msg_value.recipients_rev_preimages;
                    var calculated_midstate_hash = await hedgehog.sha256( hedgehog.hexToBytes( recipients_rev_preimages[ 0 ] ) );
                    var expected_midstate_hash = htlc_to_remove.recipients_revhashes[ 0 ];
                    var calculated_reveal_hash = await hedgehog.sha256( hedgehog.hexToBytes( recipients_rev_preimages[ 1 ] ) );
                    var expected_reveal_hash = htlc_to_remove.recipients_revhashes[ 1 ];
                    //TODO: force close if the error below is thrown
                    if ( calculated_midstate_hash !== expected_midstate_hash || calculated_reveal_hash !== expected_reveal_hash ) return console.log( 'error, your counterparty tried to cheat you by sending invalid revocation data' );

                    //save the revocation data
                    state.channel_states[ state.channel_states.length - 4 ].pending_htlcs[ index_of_pending_htlc ].recipients_rev_preimages = recipients_rev_preimages;

                    console.log( 'htlc resolved' );
                    return;
                },
                setUpComms: async () => {
                    hedgehog.communicateWithUser = async data_for_counterparty => {
                        console.log( data_for_counterparty );
                        var chan_id = data_for_counterparty.chan_id;
                        var message_identifier = hedgehog.getPrivkey();
                        if ( data_for_counterparty.hasOwnProperty( "pmthash" ) && data_for_counterparty.hasOwnProperty( "s_midstate_revhash" ) ) {
                            var more_message_info = "htlc_to_server_part_one";
                            data_for_counterparty[ "message_identifier" ] = message_identifier;
                            data_for_counterparty[ "more_message_info" ] = more_message_info;
                            var msg_for_counterparty = JSON.stringify({
                                msg_type: "two_way_comms",
                                msg_value: data_for_counterparty,
                            });
                        }
                        if ( data_for_counterparty.hasOwnProperty( "amnt" ) && data_for_counterparty.hasOwnProperty( "htlc_locktime" ) && data_for_counterparty.hasOwnProperty( "sig_on_recipients_reveal_p1_tx" ) && data_for_counterparty.hasOwnProperty( "sig_on_senders_reveal_p1_tx" ) && data_for_counterparty.hasOwnProperty( "pmthash" ) && data_for_counterparty.hasOwnProperty( "s_recovery_p2_revhash" ) ) {
                            var more_message_info = "htlc_to_server_part_three";
                            data_for_counterparty[ "message_identifier" ] = message_identifier;
                            data_for_counterparty[ "more_message_info" ] = more_message_info;
                            var msg_for_counterparty = JSON.stringify({
                                msg_type: "two_way_comms",
                                msg_value: data_for_counterparty,
                            });
                        }
                        if ( data_for_counterparty.hasOwnProperty( "to_midstate_sig" ) && data_for_counterparty.hasOwnProperty( "finalizer_sig" ) && data_for_counterparty.hasOwnProperty( "revocation_hash" ) && data_for_counterparty.hasOwnProperty( "pmthash" ) && data_for_counterparty.hasOwnProperty( "revocation_of_previous_state" ) ) {
                            var more_message_info = "htlc_to_server_part_five";
                            data_for_counterparty[ "message_identifier" ] = message_identifier;
                            data_for_counterparty[ "more_message_info" ] = more_message_info;
                            var msg_for_counterparty = JSON.stringify({
                                msg_type: "two_way_comms",
                                msg_value: data_for_counterparty,
                            });
                        }
                        console.log( 'sending data:', msg_for_counterparty );
                        var privkey = hedgehog_client.nostr_privkey;
                        var pubkey = super_nostr.getPubkey( privkey );
                        var counterparty_pubkey = hedgehog_client.server;
                        var relays = hedgehog_client.relays;
                        var emsg = await super_nostr.alt_encrypt( privkey, counterparty_pubkey, msg_for_counterparty );
                        var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", counterparty_pubkey ] ] );
                        super_nostr.sendEvent( event, relays[ 0 ] );

                        var loop = async () => {
                            console.log( 'looking for', message_identifier );
                            await hedgehog_client.waitSomeTime( 100 );
                            if ( !hedgehog_client.two_way_comms.hasOwnProperty( message_identifier ) ) return loop();
                            return hedgehog_client.two_way_comms[ message_identifier ];
                        }
                        var reply = await loop();
                        return reply;
                    }
                },
                waitSomeTime: num => new Promise( resolve => setTimeout( resolve, num ) ),
                getInvoicePmthash: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var i; for ( i=0; i<decoded[ "tags" ].length; i++ ) {
                        if ( decoded[ "tags" ][ i ][ "tagName" ] === "payment_hash" ) return decoded[ "tags" ][ i ][ "data" ].toString();
                    }
                },
                getInvoiceAmount: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var amount = Math.floor( decoded[ "millisatoshis" ] / 1000 ).toString();
                    return Number( amount );
                },
                convertPubkeyAndRelaysToNprofile: ( prefix, pubkey, relays ) => {
                    var relays_str = "";
                    relays.forEach( relay => {
                        var relay_str = hedgehog_client.textToHex( relay );
                        var len = ( relay_str.length / 2 ).toString( 16 );
                        if ( len.length % 2 ) len = "0" + len;
                        relays_str = relays_str + "01" + len + relay_str;
                    });
                    var hex = relays_str + "0020" + pubkey;
                    var bytes = super_nostr.hexToBytes( hex );
                    var nevent = bech32.bech32.encode( prefix, bech32.bech32.toWords( bytes ), 100_000 );
                    return nevent;
                },
                textToHex: text => {
                    var encoded = new TextEncoder().encode( text );
                    return Array.from( encoded )
                        .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                        .join( "" );
                },
                showChecks: () => hedgehog_client.showPage( "checks_page" ),
                newCheck: () => {
                    var new_check_html = `
                        <p style="font-weight: bold;">New check</p>
                        <p>Enter a label</p>
                        <p><input class="new_check_label" placeholder="Money for rent"></p>
                        <p>Enter an amount in sats</p>
                        <p><input class="new_check_amount" type="number" min="2000" step="1" placeholder="2000"></p>
                        <p class="channel_fee_info"><input type="checkbox" class="include_channel_fee" id="include_channel_fee"> <label for="include_channel_fee">Include channel fee</label>
                        <p>If a channel fee is included, an extra payment of 1000 sats will be added to your check to pay for a new channel for your recipient, if necessary. The channel fee has to be a separate payment to reduce trust in the server: the channel fee goes to the server, not the recipient, so the server can steal it. But he promises not to, and in fact he promises to refund the unused portion of the channel fee.</p>
                        <p><button class="submit_new_check">Submit</button></p>
                    `;
                    showModal( new_check_html );
                    $( '.submit_new_check' ).onclick = async () => {
                        var chan_id = hedgehog_client.getChanId();
                        if ( !chan_id ) return alert( 'open a channel first' );
                        var check_label = $( '.new_check_label' ).value;
                        var check_amount = Number( $( '.new_check_amount' ).value );
                        if ( !check_label ) return alert( 'check must be labeled, try again' );
                        if ( String( check_amount ).includes( "," ) || String( check_amount ).includes( "." ) ) return alert( 'check amount must be a number with no commas or periods, try again' );
                        if ( check_amount < 2000 ) return alert( 'check amount must be 2000 or greater' );
                        var balance = hedgehog_client.getBalance( chan_id )[ 0 ] - hedgehog_client.getBalance( chan_id )[ 1 ];
                        var sum_needed = check_amount;
                        //TODO: instead of hard coding a channel fee of 1000 sats, use mempool data to estimate it and add a 10% buffer
                        var channel_fee = 1000;
                        var include_channel_fee = $( '.include_channel_fee' ).checked;
                        if ( include_channel_fee ) sum_needed = sum_needed + channel_fee;
                        if ( sum_needed > balance ) return alert( `your balance is not high enough for this check, you need an extra ${balance - sum_needed} sats` );
                        var check_privkey = super_nostr.getPrivkey();
                        var check_pubkey = super_nostr.getPubkey( check_privkey );
                        var check_relays = hedgehog_client.backup_relays;
                        var check_id = hedgehog_client.convertPubkeyAndRelaysToNprofile( "hh_check_", check_privkey, check_relays );
                        var check_preimage = super_nostr.getPrivkey();
                        var check_absolute_timelock = 0;
                        var check_encryption_privkey = super_nostr.getPrivkey();
                        var server = hedgehog_client.server;
                        var relays = hedgehog_client.relays;
                        var check_encrypted_chan_id = await super_nostr.alt_encrypt( check_encryption_privkey, server, chan_id );
                        var check_encryption_pubkey = super_nostr.getPubkey( check_encryption_privkey );
                        var check_server_id = hedgehog_client.convertPubkeyAndRelaysToNprofile( "nprofile", server, relays );
                        var channel_fee_data = {}
                        var encrypted_channel_fee_data = null;
                        if ( include_channel_fee ) {
                            channel_fee_data.fee_amount = channel_fee;
                            channel_fee_data.fee_preimage = super_nostr.getPrivkey();
                            channel_fee_data.fee_absolute_timelock = 0;
                            encrypted_channel_fee_data = await super_nostr.alt_encrypt( check_encryption_privkey, server, JSON.stringify( channel_fee_data ) );
                        }
                        //create an encrypted kind 16109 message on nostr with the following content: the htlc preimage, the amount, the blockheight of an absolute timelock (can be 0), the server_id, an encrypted channel id, and similar info a second time for a “channel fee” payment (optional)
                        var data_to_put_on_nostr = JSON.stringify({
                            check_amount,
                            check_preimage,
                            check_absolute_timelock,
                            check_server_id,
                            check_encrypted_chan_id,
                            check_encryption_pubkey,
                            encrypted_channel_fee_data,
                        });
                        var encrypted_data = await super_nostr.alt_encrypt( check_privkey, check_pubkey, data_to_put_on_nostr );
                        var event = await super_nostr.prepEvent( check_privkey, encrypted_data, 16109 );
                        var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                        var socket = super_nostr.sockets[ socket_id ].socket;
                        super_nostr.sendEvent( event, socket );
                        var check_data = {
                            data_to_put_on_nostr: JSON.parse( data_to_put_on_nostr ),
                            check_amount,
                            check_label,
                            check_status: "ready to cash",
                            channel_fee: include_channel_fee ? channel_fee : 0,
                        }
                        //use the check_preimage and, if necessary, the fee_preimage to create one or two pending htlcs
                        showModal( '<p>Preparing check...</p>' );
                        var check_pmthash = await hedgehog.sha256( hedgehog.hexToBytes( check_preimage ) );
                        await hedgehog_client.send( chan_id, check_amount, check_pmthash );
                        if ( include_channel_fee ) {
                            var fee_pmthash = await hedgehog.sha256( hedgehog.hexToBytes( channel_fee_data.fee_preimage ) );
                            await hedgehog_client.send( chan_id, channel_fee_data.fee_amount, fee_pmthash );
                        }
                        hedgehog_client.checks[ check_id ] = check_data;
                        modalVanish();
                    }
                },
                handleChecksLoop: async () => {
                    var num_of_checks = hedgehog_client.num_of_checks;
                    var checks = Object.keys( hedgehog_client.checks );
                    if ( !checks.length ) {
                        $( '.pending_checks' ).innerHTML = `[None]`;
                        await hedgehog_client.waitSomeTime( 100 );
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    if ( checks.length === num_of_checks ) {
                        await hedgehog_client.waitSomeTime( 100 );
                        hedgehog_client.handleChecksLoop();
                        return;
                    }
                    hedgehog_client.num_of_checks = checks.length;
                    $( '.pending_checks' ).innerHTML = ``;
                    checks.forEach( check_id => {
                        var check = hedgehog_client.checks[ check_id ];
                        var url = `${window.location.protocol}//${window.location.hostname}/${window.location.pathname}#check=${check_id}`;
                        var qr = hedgehog_client.createQR( url.toUpperCase() );
                        var check_html = `
                            <div>Label: <span class="check_label">${check.check_label}</span></div>
                            <div>Amount: <span class="check_amount">${check.channel_fee ? String( check.check_amount ) + "&nbsp;+&nbsp;" + String( check.channel_fee ) : check.check_amount}</span></div>
                            <div>Status: <span class="check_status">${check.check_status}</span></div>
                            <div><button class="check_btn void_this_check">Void this check</button></div>
                            <div><button class="check_btn view_check_qr">View qr code</button></div>
                            <div><button class="check_btn view_payment_string">View payment string</button></div>
                            <div class="check_qr_code hidden"></div>
                            <div class="check_payment_string hidden">${url}</div>
                        `;
                        var div = document.createElement( "div" );
                        div.classList.add( "check" );
                        div.classList.add( check_id );
                        div.innerHTML = check_html;
                        div.getElementsByClassName( "check_qr_code" )[ 0 ].append( qr );
                        div.getElementsByClassName( "void_this_check" )[ 0 ].onclick = () => {
                            showModal( `This button doesn't do anything yet` );
                        }
                        div.getElementsByClassName( "view_check_qr" )[ 0 ].onclick = () => {
                            var item = $( `.${check_id} .check_qr_code` );
                            if ( item.classList.contains( "hidden" ) ) item.classList.remove( "hidden" );
                            else item.classList.add( "hidden" );
                        }
                        div.getElementsByClassName( "view_payment_string" )[ 0 ].onclick = () => {
                            var item = $( `.${check_id} .check_payment_string` );
                            if ( item.classList.contains( "hidden" ) ) item.classList.remove( "hidden" );
                            else item.classList.add( "hidden" );
                        }
                        $( '.pending_checks' ).append( div );
                    });
                    await hedgehog_client.waitSomeTime( 100 );
                    hedgehog_client.handleChecksLoop();
                },
                getChanId: () => Object.keys( hedgehog.state )[ 0 ],
                createQR: content => {
                    var dataUriPngImage = document.createElement( "img" ),
                    s = QRCode.generatePNG( content, {
                        ecclevel: "M",
                        format: "html",
                        fillcolor: "#FFFFFF",
                        textcolor: "#000000",
                        margin: 4,
                        modulesize: 8,
                    });
                    dataUriPngImage.src = s;
                    dataUriPngImage.className = "qr_code";
                    dataUriPngImage.style.width = "100%";
                    return dataUriPngImage;
                },
                checkPage: async () => {
                    //show check page
                    hedgehog_client.showPage( "check_page" );

                    //prepare requisite variables
                    var check_id = url_params.check;
                    var [ check_privkey, check_relays ] = hedgehog_client.convertNEvent( check_id );
                    var privkey = check_privkey;
                    var check_pubkey = super_nostr.getPubkey( check_privkey );
                    var relay = check_relays[ 0 ];
                    var ids = null;
                    var authors = [ check_pubkey ];
                    var kinds = [ 16109 ];
                    var until = null;
                    var since = null;
                    var limit = 1;
                    var events = await super_nostr.getEvents( relay, ids, authors, kinds, until, since, limit );
                    if ( !events.length ) $( '.check_info' ).innerHTML = `Sorry, someone sent you an uncashable check.`;
                    var check = events[ 0 ];
                    check.content = await super_nostr.alt_decrypt( check_privkey, check_pubkey, check.content );
                    var json = JSON.parse( check.content );
                    var { check_amount: check_amnt, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id: encrypted_chan_id, check_encryption_pubkey: encryption_pubkey, encrypted_channel_fee_data } = json;
                    var check_pmthash = await hedgehog.sha256( hedgehog.hexToBytes( check_preimage ) );

                    //listen on nostr
                    var nostr_privkey = check_privkey;
                    var nostr_pubkey = check_pubkey;
                    var check_server_id = json.check_server_id;
                    var [ server, relays ] = hedgehog_client.convertNEvent( check_server_id );
                    var listenFunction = async socket => {
                        var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                        var filter  = {}
                        filter.authors = [ server ];
                        filter.kinds = [ 4 ];
                        filter[ "#p" ] = [ nostr_pubkey ];
                        filter.since = Math.floor( Date.now() / 1000 );
                        var subscription = [ "REQ", subId, filter ];
                        socket.send( JSON.stringify( subscription ) );
                    }
                    var handleFunction = async message => {
                        var [ type, subId, event ] = JSON.parse( message.data );
                        if ( !event || event === true ) return;
                        try {
                            event.content = await super_nostr.alt_decrypt( nostr_privkey, event.pubkey, event.content );
                            var json = JSON.parse( event.content );
                            if ( json[ "msg_type" ] === "get_check_status_reply" ) {
                                if ( json.msg_value === "irredeemable" ) $( '.check_info' ).innerHTML = `Sorry, someone sent you an uncashable check.`;
                                if ( json.msg_value === "redeemable" ) {
                                    $( '.check_info' ).innerHTML = `
                                        <p>The check is worth ${check_amnt} sats. How do you want to cash it?</p>
                                        <ol>
                                            <li><span class="new_hedgehog_channel bluelink">Click here</a> to set up a new hedgehog channel and receive it into there</li>
                                            <li><span class="have_hedgehog_channel bluelink">Click here</a> if you already have a hedgehog channel and want to receive it into there</li>
                                            <li><span class="check_to_ln bluelink">Click here</a> to receive the money into a compatible lightning wallet</li>
                                        </ol>
                                    `;
                                    $( '.new_hedgehog_channel' ).onclick = () => {
                                        var check_hex = hedgehog_client.textToHex( check.content );
                                        hedgehog_client.onboard( check_server_id, check_hex );
                                    }
                                    $( '.have_hedgehog_channel' ).onclick = () => {
                                        var check_hex = hedgehog_client.textToHex( check.content );
                                        var check_data = JSON.parse( hedgehog_client.hexToText( check_hex ) );
                                        var { check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey } = check_data;
                                        hedgehog_client.cashCheck( chan_id, check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey );
                                    }
                                    $( '.check_to_ln' ).onclick = () => {
                                        showModal( `This button does not do anything yet` );
                                    }
                                }
                            }
                        }
                        catch ( e ) {
                            console.log( e );
                        }
                    }
                    await super_nostr.newPermanentConnection( relays[ 0 ], listenFunction, handleFunction );

                    //ensure check is redeemable
                    var nostr_relays = relays;
                    var counterparty_pubkey = server;
                    var msg_for_counterparty = JSON.stringify({
                        msg_type: "get_check_status",
                        msg_value: { encrypted_chan_id, check_pmthash, check_amnt, encryption_pubkey, check_absolute_timelock },
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, counterparty_pubkey, msg_for_counterparty );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", counterparty_pubkey ] ] );
                    super_nostr.sendEvent( event, nostr_relays[ 0 ] );
                },
                cashCheck: async ( chan_id, check_amount, check_preimage, check_absolute_timelock, check_server_id, check_encrypted_chan_id, check_encryption_pubkey ) => {
                    //prepare the needed variables
                    var state = hedgehog.state[ chan_id ];
                    var privkey = hedgehog_client.nostr_privkey;
                    var privkey = hedgehog_client.nostr_privkey;
                    var pubkey = super_nostr.getPubkey( privkey );
                    var server = hedgehog_client.server;
                    var relays = hedgehog_client.relays;
                    var check_pmthash = await super_nostr.sha256( super_nostr.hexToBytes( check_preimage ) );

                    //request the server to send you a hedgehog htlc
                    var msg_for_server = JSON.stringify({
                        msg_type: "request_hh_pmt_to_user",
                        msg_value: {
                            chan_id,
                            check_amount,
                            check_pmthash,
                            check_absolute_timelock,
                            check_server_id,
                            check_encrypted_chan_id,
                            check_encryption_pubkey,
                        }
                    });
                    var emsg = await super_nostr.alt_encrypt( privkey, server, msg_for_server );
                    var event = await super_nostr.prepEvent( privkey, emsg, 4, [ [ "p", server ] ] );
                    super_nostr.sendEvent( event, hedgehog_client.relays[ 0 ] );

                    hedgehog_client.prepToReceiveLNPartOne( chan_id, check_amount, check_preimage );
                },
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .onboard_in_log_in {
                color: blue;
                text-decoration: underline;
                cursor: pointer;
            }
            .show_backup_string {
                padding: 1rem;
                background-color: tan;
                font-family: mono;
            }
            .check {
                background-color: lightgreen;
                padding: 1rem;
                border: 1px solid green;
            }
            .unfunded {
                background-color: lightblue;
            }
            .check_btn, .check_qr_code, .check_payment_string {
                margin-top: 1rem;
            }
            .check_qr_code {
                max-width: 15rem;
            }
            .check_payment_string {
                background-color: tan;
                padding: 1rem;
            }
            .channel_fee_info {
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .include_channel_fee {
                width: .7rem;
                margin-right: 0.5rem;
            }
            .checks_amnt_p, .checks_amnt_p * {
                font-size: .9rem;
            }
            .bluelink {
                color: blue;
                text-decoration: underline;
                cursor: pointer;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <style>
            .black-bg {
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
                background-color: black;
                opacity: .5;
                width: 100vw;
                height: 100vh;
            }
            .modal {
                position: fixed;
                box-sizing: border-box;
                top: 50%;
                left: 50%;
                transform: translate(-50%,-50%);
                width: 90%;
                max-width: 560px;
                background-color: white;
                border-radius: 1rem;
                padding: 20px;
                color: black;
                text-align: center;
                word-wrap: break-word;
            }
            .modal * {
                color: black;
            }
            .modal input, .modal textarea {
                max-width: 90%;
            }
        </style>
        <script>
            var modalVanish = () => {
                $( ".black-bg" ).classList.add( "hidden" );
                $( ".modal" ).classList.add( "hidden" );
            }
            var showModal = content => {
                $( ".modal" ).innerHTML = `<div class="x_modal" style="position: absolute;right: 1rem;top: 0.5rem;font-size: 2rem; cursor: pointer; color: black;" onclick="modalVanish()">&times;</div>`;
                $( ".modal" ).innerHTML += `<div style="overflow-y: auto; max-height: 80vh; margin-top: 1.5rem;">${content}</div>`;
                $( ".black-bg" ).classList.remove( "hidden" );
                $( ".modal" ).classList.remove( "hidden" );
            }
        </script>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = {}
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                url_params[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <div class="welcome_page">
            <h1>Welcome to hedgehog</h1>
            <p>A lightning-like layer two for bitcoin, but better</p>
            <p><button class="log_in">Log in</button></p>
            <p><button class="onboard">Onboard</button></p>
        </div>
        <div class="wallet_page hidden">
            <h1>Your wallet</h1>
            <p>Balance: <span class="balance">0</span> sats</p>
            <p class="checks_amnt_p hidden">In checks: <span class="balance_in_checks">0</span> sats</p>
            <p><button class="open_channel hidden">Open channel</button></p>
            <p><button class="receive">Receive</button></p>
            <p><button class="send">Send</button></p>
            <p><button class="checks">Checks</button></p>
            <p><button class="exit">Exit</button></p>
        </div>
        <div class="checks_page hidden">
            <h1>Checks</h1>
            <p><button class="new_check">New check</button> <button class="back_btn">Back</button></p>
            <h2>Pending checks</h2>
            <div class="pending_checks"></div>
        </div>
        <div class="check_page hidden">
            <h1>Time to redeem your check</h1>
            <div class="check_info">loading check info...</div>
        </div>
        <div class="loading_page hidden">
            <p>Loading...</p>
        </div>
        <script>
            hedgehog_client.setUpComms();
            $( '.log_in' ).onclick = () => {
                var content = `
                    <p>Enter your backup string</p>
                    <p><input class="backup_string"></input></p>
                    <p><button class="submit_backup_string">Submit</button></p>
                    <p>Don't have a backup string? <span class="onboard_in_log_in">Onboard!</span></p>
                `;
                showModal( content );
                $( '.onboard_in_log_in' ).onclick = () => {hedgehog_client.onboard();}
            }
            $( '.onboard' ).onclick = () => {hedgehog_client.onboard();}
            $( '.open_channel' ).onclick = hedgehog_client.openChannel;
            $( '.receive' ).onclick = hedgehog_client.receive;
            $( '.send' ).onclick = hedgehog_client.sendBtn;
            $( '.checks' ).onclick = hedgehog_client.showChecks;
            $( '.new_check' ).onclick = hedgehog_client.newCheck;
            $$( '.back_btn' ).forEach( item => item.onclick = () => hedgehog_client.showPage( "wallet_page" ) );
            if ( url_params.onboard ) hedgehog_client.onboard();
            if ( url_params.backup_string ) hedgehog_client.login( url_params.backup_string );
            if ( url_params.check ) hedgehog_client.checkPage();
        </script>
        <div class="black-bg hidden" onclick="modalVanish();"></div>
        <div class="modal hidden"></div>
    </body>
</html> 
